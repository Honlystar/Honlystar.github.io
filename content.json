{"meta":{"title":"星空守候的博客","subtitle":"相信自己,相信未来","description":"这是属于星空守候的专属个人空间，这里是web开发工程师的天堂，这里欢迎每一个开发者，希望你们在这里有所提高","author":"rain","url":"https://www.onlystar.site"},"pages":[],"posts":[{"title":"'promise的初步使用'","slug":"promise的初步使用","date":"2017-10-17T12:06:07.000Z","updated":"2017-10-21T14:09:09.561Z","comments":true,"path":"20171017/200607/","link":"","permalink":"https://www.onlystar.site/20171017/200607/","excerpt":"","text":"背景在前端开发中，经常会遇到这样的困境：一个接口的参数会需要使用另一个接口获取，这时候聪明的做法就是使用回调函数，这样就可以解决问题，但是这种做法增加了函数的嵌套深度，如果需要的是好几个接口的返回数据,这样层层的回调,就比较头疼痛了，这就是所谓的回调地狱。Promise正是在这种情况下应运而生,它完美优雅的解决了回调地狱难题。123456789step1(function (value1) &#123; step2(value1, function(value2)&#123; step3(value2,function(value3) &#123; step4(value3,function(value4) &#123; // ... &#125;); &#125;); &#125;);&#125;); Promise 是异步编程的一种解决方案，Promise 可以认为是一个对象，它可以获取异步操的最终完成（或失败）及其结果值的表示 Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（成功时）和rejected（失败时） Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected. 基本用法ES6 规定，Promise对象是一个构造函数，用来生成Promise实例,该函数的两个参数分别是两个函数resolve和reject1234567var promise = new Promise(function(resolve, reject) &#123; if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); then方法then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数,then方法返回的是一个新的Promise实例12345promise.then(function(value) &#123; // success&#125;, function(value) &#123; // failure&#125;); 如果异步操作成功，则用 resolve 方法将状态从“未完成”变为“成功”，如果异步操作失败，则用 reject方法将状态从“未完成”变为“失败” 这里是promised基本使用的一个demo,定义做饭，吃饭,洗碗三个方法1234567891011121314151617181920212223242526272829303132333435363738//做饭function cook()&#123; console.log(&apos;开始做饭。&apos;); var p = new Promise(function(resolve, reject)&#123; console.log(&apos;做饭完毕！&apos;); resolve(&apos;鸡蛋炒饭&apos;); &#125;); return p;&#125;//吃饭function eat(data)&#123; console.log(&apos;开始吃饭：&apos; + data); var p = new Promise(function(resolve, reject)&#123; console.log(&apos;吃饭完毕!&apos;); resolve(&apos;一块碗和一双筷子&apos;); &#125;); return p;&#125;//洗碗function wash(data)&#123; console.log(&apos;开始洗碗：&apos; + data); var p = new Promise(function(resolve, reject)&#123; console.log(&apos;洗碗完毕!&apos;); resolve(&apos;干净的碗筷&apos;); &#125;); return p;&#125;//调用三个过程cook().then(function(data)&#123; return eat(data);&#125;).then(function(data)&#123; return wash(data);&#125;).then(function(data)&#123; console.log(data);&#125;); 程序成功运行的结果:1234567开始做饭。做饭完毕！开始吃饭：鸡蛋炒饭吃饭完毕!开始洗碗：一块碗和一双筷子洗碗完毕!干净的碗筷 all方法有时候需要多个异步任务全部执行完成后再执行后面的操作，这时候就需要用到Promise.all()，它接收一个Promise的对象的数组作为参数，当这个数组里的所有Promise对象全部变成resolve或者reject的时候，它才会去调用后面的.then()。123456Promise.all([cook(), eat(),wash()]).then(function(results)&#123; console.log(results); console.log(&quot;做吃洗完毕：&quot;);&#125;); 成功的运行结果:12345678开始做饭。做饭完毕！开始吃饭：undefined吃饭完毕!开始洗碗：undefined洗碗完毕!做吃洗完毕：[&quot;鸡蛋炒饭&quot;, &quot;一块碗和一双筷子&quot;, &quot;干净的碗筷&quot;]","categories":[{"name":"ES6","slug":"ES6","permalink":"https://www.onlystar.site/categories/ES6/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.onlystar.site/tags/js/"},{"name":"promise","slug":"promise","permalink":"https://www.onlystar.site/tags/promise/"}]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2017-10-15T13:09:39.000Z","updated":"2017-10-21T14:11:56.956Z","comments":true,"path":"20171015/210939/","link":"","permalink":"https://www.onlystar.site/20171015/210939/","excerpt":"","text":"这是我个人博客搭建好的第一篇博客，欢迎大家来捧捧场哦","categories":[{"name":"web","slug":"web","permalink":"https://www.onlystar.site/categories/web/"}],"tags":[{"name":"测试","slug":"测试","permalink":"https://www.onlystar.site/tags/测试/"}]}]}