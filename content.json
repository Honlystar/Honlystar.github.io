{"meta":{"title":"星空守候的博客","subtitle":"相信自己,相信未来","description":"这是属于星空守候的专属个人空间，这里是web开发工程师的天堂，这里欢迎每一个开发者，希望你们在这里有所提高","author":"rain","url":"https://www.onlystar.site"},"pages":[{"title":"","date":"2017-10-22T06:21:38.538Z","updated":"2017-10-22T06:18:13.566Z","comments":true,"path":"echarts/index.html","permalink":"https://www.onlystar.site/echarts/index.html","excerpt":"","text":"Echarts图形展示 div.container .row div[id^=\"main\"]{ width: 600px; height:400px; margin:0px auto; margin-top:60px; margin-bottom:20px; /* margin-left:5px; */ /* border-bottom:1px solid #aaa; */ } div.heard { margin-left:190px; color:#777; } Echarts // 基于准备好的dom，初始化echarts实例 var myChart1 = echarts.init(document.getElementById('main1'),'infographic'); // 指定图表的配置项和数据 var option1 = { title: { text: 'ECharts 柱状图' }, tooltip: { //提示悬浮层的位置，默认不设置为跟随鼠标位置 }, legend: { //图例组件 data:['销量','存量'] //图例项的名称 }, xAxis: { type : 'category', //坐标轴类型，类目轴 data: [\"衬衫\",\"羊毛衫\",\"雪纺衫\",\"裤子\",\"高跟鞋\",\"袜子\"] //类目数据 }, yAxis: {}, series: [{ //系列列表，图标类型 name: '销量', type: 'bar', data: [5, 20, 36, 10, 10, 40] //系列中的数据内容数组 }, { name:'存量', type:'bar', data:[10, 5, 20, 18, 30, 8] } ] }; // 使用刚指定的配置项和数据显示图表。 myChart1.setOption(option1); var myChart2 = echarts.init(document.getElementById('main2'),'macarons'); //指定图标的配置项和数据 var option2 = { title: { //标题组件 text: 'ECharts 折线图', subtext: '实时数据' }, tooltip: { trigger: 'axis' // 提示悬浮车触发类型，坐标轴触发 item为数据项图形触发 }, legend: { data:['意向','预购','成交'] }, toolbox: { //工具栏 show: true, feature: { //工具配置项 magicType: {show: true, type: ['stack', 'tiled']}, //动态类型切换，工具打开，动态类型为 堆叠模式 平铺模式 （line:折线图 bar：柱状图） saveAsImage: {show: true} //保存为图片 } }, xAxis: { type: 'category', boundaryGap: false,//关闭坐标轴两边留白 data: ['周一','周二','周三','周四','周五','周六','周日'] }, yAxis: { type: 'value' //坐标轴类型 数值轴 }, series: [{ name: '成交', type: 'line', smooth: true, //平滑显示曲线 data: [10, 12, 21, 54, 260, 830, 710] }, { name: '预购', type: 'line', smooth: true, data: [30, 182, 434, 791, 390, 30, 10] }, { name: '意向', type: 'line', smooth: true, data: [1320, 1132, 601, 234, 120, 90, 20] }] }; myChart2.setOption(option2); var myChart3 = echarts.init(document.getElementById('main3'),'roma') var option3 = { title: { text: 'Echarts 圆环', subtext: '实时数据', x:'center' }, tooltip: { trigger: 'item', formatter: \"{a} {b}: {c} ({d}%)\" }, legend: { orient: 'vertical', //图例列表的布局朝向 horizontal 水平朝向 x: 'left', data:['直接访问','邮件营销','联盟广告','视频广告','搜索引擎'] }, series: [ { name:'访问来源', type:'pie', radius: ['50%', '70%'], avoidLabelOverlap: false,//关闭防止标签重叠策略 label: { normal: { show: false, position: 'center' //标签的位置 饼图的中心 }, emphasis: { show: true, textStyle: { fontSize: '30', fontWeight: 'bold' } } }, labelLine: { normal: { show: false, //不现实视觉引导线 } }, data:[ {value:335, name:'直接访问'}, {value:310, name:'邮件营销'}, {value:234, name:'联盟广告'}, {value:135, name:'视频广告'}, {value:1548, name:'搜索引擎'} ] } ] }; myChart3.setOption(option3); var myChart4 = echarts.init(document.getElementById('main4'),'shine'); var option4 = { title: { text: '漏斗图', subtext: '实时数据' }, tooltip: { trigger: 'item', formatter: \"{a} {b} : {c}%\" }, toolbox: { feature: { dataView: {readOnly: false},//是否不可编辑 restore: {},//还原设置工具 saveAsImage: {} } }, legend: { data: ['展现','点击','访问','咨询','订单'] }, calculable: true,//是否启用拖拽重新计算功能 默认关闭 series: [ { name:'漏斗图', type:'funnel', //类型为漏斗图 left: '10%', top: 60, bottom: 60, width: '80%', min: 0, //制定数据最小值 max: 100,//制定数据最大值 minSize: '0%',//数据最小值映射的宽度 maxSize: '100%',//数据最大值映射的宽度 sort: 'descending',//数据的排列顺序 此处为递减 ascending为递增 none则按照data顺序 gap: 2,//数据图形之间的间距 label: { normal: { //图例被选中前状态 show: true, position: 'inside' }, emphasis: { //图例选中后状态 textStyle: { fontSize: 20 } } }, labelLine: { //标签视觉引导线 normal: { length: 10, lineStyle: { width: 1, type: 'solid' } } }, itemStyle: { normal: { borderColor: '#000',//图形的描边颜色 borderWidth: 1 //描边线宽 } }, data: [ {value: 60, name: '访问'}, {value: 40, name: '咨询'}, {value: 20, name: '订单'}, {value: 80, name: '点击'}, {value: 100, name: '展现'} ] } ] }; myChart4.setOption(option4); var myChart5 = echarts.init(document.getElementById('main5'),'vintage'); var option5 = { baseOption: { title : { text: '南丁格尔玫瑰图', subtext: '实时数据', x:'center' }, tooltip : { trigger: 'item', formatter: \"{a} {b} : {c} ({d}%)\" //悬浮提示框内容 系列名称 数据项名称 数值 百分比 }, legend: { data:['rose1','rose2','rose3','rose4','rose5','rose6','rose7','rose8'] }, toolbox: { show : true, feature : { mark : {show: true}, dataView : {show: true, readOnly: false}, //数据视图工具 是否不可编辑（此处编辑打开） magicType : { //动态类型切换 show: true, type: ['pie', 'funnel'] }, restore : {show: true}, //配置项还原工具 saveAsImage : {show: true} //保存为图片工具 } }, calculable : true,//是否启用拖拽重计算特性，默认为关闭（即值为false） series : [ { name:'半径模式', type:'pie', roseType : 'radius',//展示为男丁格尔图。扇形圆心角展现数据百分比，半径展现数据大小 label: { normal: { show: false }, emphasis: { show: true } }, lableLine: { normal: { show: false }, emphasis: { show: true } }, data:[ {value:10, name:'rose1'}, {value:5, name:'rose2'}, {value:15, name:'rose3'}, {value:25, name:'rose4'}, {value:20, name:'rose5'}, {value:35, name:'rose6'}, {value:30, name:'rose7'}, {value:40, name:'rose8'} ] }, { name:'面积模式', type:'pie', roseType : 'area',//所有扇形去圆心角相同，半径展现数据大小 data:[ {value:10, name:'rose1'}, {value:5, name:'rose2'}, {value:15, name:'rose3'}, {value:25, name:'rose4'}, {value:20, name:'rose5'}, {value:35, name:'rose6'}, {value:30, name:'rose7'}, {value:40, name:'rose8'} ] } ] }, media: [ //这里开始定义 media quey的逐条规则 { option: { //这里没有写规则，表示默认状态，即所有的规则都不满足时，采纳这个option legend: { right: 'center', bottom: 0, orient: 'horizontal' //横向排布 }, series: [ { radius: [20, '50%'], center: ['25%', '50%'] }, { radius: [30, '50%'], center: ['75%', '50%'] } ] } }, { query: { minAspectRatio: 1 //当长宽比大于1时 }, option: { legend: { right: 'center', bottom: 0, orient: 'horizontal' }, series: [ { radius: [20, '45%'], center: ['25%', '50%'] }, { radius: [30, '45%'], center: ['75%', '50%'] } ] } }, { query: { maxAspectRatio: 1 //当长宽比小于1时 }, option: { legend: { right: 'center', bottom: 0, orient: 'horizontal' }, series: [ { radius: [20, '45%'], center: ['50%', '30%'] }, { radius: [30, '45%'], center: ['50%', '70%'] } ] } }, { query: { maxWidth: 500 //当宽度小于500时 }, option: { legend: { right: 10, top: '15%', orient: 'vertical' //纵向排布 }, series: [ { radius: [20, '45%'], center: ['50%', '30%'] }, { radius: [30, '45%'], center: ['50%', '75%'] } ] } } ] }; myChart5.setOption(option5);"},{"title":"","date":"2017-10-22T06:21:24.298Z","updated":"2017-10-22T05:33:47.905Z","comments":true,"path":"echarts/infographic.js","permalink":"https://www.onlystar.site/echarts/infographic.js","excerpt":"","text":"(function (root, factory) {if (typeof define === 'function' && define.amd) { // AMD. Register as an anonymous module. define(['exports', 'echarts'], factory); } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') { // CommonJS factory(exports, require('echarts')); } else { // Browser globals factory({}, root.echarts); } }(this, function (exports, echarts) { var log = function (msg) { if (typeof console !== 'undefined') { console && console.error && console.error(msg); } }; if (!echarts) { log('ECharts is not Loaded'); return; } var colorPalette = [ '#C1232B','#27727B','#FCCE10','#E87C25','#B5C334', '#FE8463','#9BCA63','#FAD860','#F3A43B','#60C0DD', '#D7504B','#C6E579','#F4E001','#F0805A','#26C0C0' ]; var theme = { color: colorPalette, title: { textStyle: { fontWeight: 'normal', color: '#27727B' } }, visualMap: { color:['#C1232B','#FCCE10'] }, toolbox: { iconStyle: { normal: { borderColor: colorPalette[0] } } }, tooltip: { backgroundColor: 'rgba(50,50,50,0.5)', axisPointer : { type : 'line', lineStyle : { color: '#27727B', type: 'dashed' }, crossStyle: { color: '#27727B' }, shadowStyle : { color: 'rgba(200,200,200,0.3)' } } }, dataZoom: { dataBackgroundColor: 'rgba(181,195,52,0.3)', fillerColor: 'rgba(181,195,52,0.2)', handleColor: '#27727B' }, categoryAxis: { axisLine: { lineStyle: { color: '#27727B' } }, splitLine: { show: false } }, valueAxis: { axisLine: { show: false }, splitArea : { show: false }, splitLine: { lineStyle: { color: ['#ccc'], type: 'dashed' } } }, timeline: { lineStyle: { color: '#27727B' }, controlStyle: { normal: { color: '#27727B', borderColor: '#27727B' } }, symbol: 'emptyCircle', symbolSize: 3 }, line: { itemStyle: { normal: { borderWidth:2, borderColor:'#fff', lineStyle: { width: 3 } }, emphasis: { borderWidth:0 } }, symbol: 'circle', symbolSize: 3.5 }, candlestick: { itemStyle: { normal: { color: '#C1232B', color0: '#B5C334', lineStyle: { width: 1, color: '#C1232B', color0: '#B5C334' } } } }, graph: { color: colorPalette }, map: { label: { normal: { textStyle: { color: '#C1232B' } }, emphasis: { textStyle: { color: 'rgb(100,0,0)' } } }, itemStyle: { normal: { areaColor: '#ddd', borderColor: '#eee' }, emphasis: { areaColor: '#fe994e' } } }, gauge: { axisLine: { lineStyle: { color: [[0.2, '#B5C334'],[0.8, '#27727B'],[1, '#C1232B']] } }, axisTick: { splitNumber: 2, length: 5, lineStyle: { color: '#fff' } }, axisLabel: { textStyle: { color: '#fff' } }, splitLine: { length: '5%', lineStyle: { color: '#fff' } }, title : { offsetCenter: [0, -20] } } }; echarts.registerTheme('infographic', theme); }));"},{"title":"","date":"2017-10-22T06:21:24.299Z","updated":"2017-10-22T05:33:46.738Z","comments":true,"path":"echarts/macarons.js","permalink":"https://www.onlystar.site/echarts/macarons.js","excerpt":"","text":"(function (root, factory) { if (typeof define === 'function' && define.amd) { // AMD. Register as an anonymous module. define(['exports', 'echarts'], factory); } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') { // CommonJS factory(exports, require('echarts')); } else { // Browser globals factory({}, root.echarts); } }(this, function (exports, echarts) { var log = function (msg) { if (typeof console !== 'undefined') { console && console.error && console.error(msg); } }; if (!echarts) { log('ECharts is not Loaded'); return; } var colorPalette = [ '#2ec7c9','#b6a2de','#5ab1ef','#ffb980','#d87a80', '#8d98b3','#e5cf0d','#97b552','#95706d','#dc69aa', '#07a2a4','#9a7fd1','#588dd5','#f5994e','#c05050', '#59678c','#c9ab00','#7eb00a','#6f5553','#c14089' ]; var theme = { color: colorPalette, title: { textStyle: { fontWeight: 'normal', color: '#008acd' } }, visualMap: { itemWidth: 15, color: ['#5ab1ef','#e0ffff'] }, toolbox: { iconStyle: { normal: { borderColor: colorPalette[0] } } }, tooltip: { backgroundColor: 'rgba(50,50,50,0.5)', axisPointer : { type : 'line', lineStyle : { color: '#008acd' }, crossStyle: { color: '#008acd' }, shadowStyle : { color: 'rgba(200,200,200,0.2)' } } }, dataZoom: { dataBackgroundColor: '#efefff', fillerColor: 'rgba(182,162,222,0.2)', handleColor: '#008acd' }, grid: { borderColor: '#eee' }, categoryAxis: { axisLine: { lineStyle: { color: '#008acd' } }, splitLine: { lineStyle: { color: ['#eee'] } } }, valueAxis: { axisLine: { lineStyle: { color: '#008acd' } }, splitArea : { show : true, areaStyle : { color: ['rgba(250,250,250,0.1)','rgba(200,200,200,0.1)'] } }, splitLine: { lineStyle: { color: ['#eee'] } } }, timeline : { lineStyle : { color : '#008acd' }, controlStyle : { normal : { color : '#008acd'}, emphasis : { color : '#008acd'} }, symbol : 'emptyCircle', symbolSize : 3 }, line: { smooth : true, symbol: 'emptyCircle', symbolSize: 3 }, candlestick: { itemStyle: { normal: { color: '#d87a80', color0: '#2ec7c9', lineStyle: { color: '#d87a80', color0: '#2ec7c9' } } } }, scatter: { symbol: 'circle', symbolSize: 4 }, map: { label: { normal: { textStyle: { color: '#d87a80' } } }, itemStyle: { normal: { borderColor: '#eee', areaColor: '#ddd' }, emphasis: { areaColor: '#fe994e' } } }, graph: { color: colorPalette }, gauge : { axisLine: { lineStyle: { color: [[0.2, '#2ec7c9'],[0.8, '#5ab1ef'],[1, '#d87a80']], width: 10 } }, axisTick: { splitNumber: 10, length :15, lineStyle: { color: 'auto' } }, splitLine: { length :22, lineStyle: { color: 'auto' } }, pointer : { width : 5 } } }; echarts.registerTheme('macarons', theme); }));"},{"title":"","date":"2017-10-22T06:21:24.300Z","updated":"2017-10-22T05:33:50.439Z","comments":true,"path":"echarts/roma.js","permalink":"https://www.onlystar.site/echarts/roma.js","excerpt":"","text":"(function (root, factory) {if (typeof define === 'function' && define.amd) { // AMD. Register as an anonymous module. define(['exports', 'echarts'], factory); } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') { // CommonJS factory(exports, require('echarts')); } else { // Browser globals factory({}, root.echarts); } }(this, function (exports, echarts) { var log = function (msg) { if (typeof console !== 'undefined') { console && console.error && console.error(msg); } }; if (!echarts) { log('ECharts is not Loaded'); return; } var colorPalette = ['#E01F54','#001852','#f5e8c8','#b8d2c7','#c6b38e', '#a4d8c2','#f3d999','#d3758f','#dcc392','#2e4783', '#82b6e9','#ff6347','#a092f1','#0a915d','#eaf889', '#6699FF','#ff6666','#3cb371','#d5b158','#38b6b6' ]; var theme = { color: colorPalette, visualMap: { color:['#e01f54','#e7dbc3'], textStyle: { color: '#333' } }, candlestick: { itemStyle: { normal: { color: '#e01f54', color0: '#001852', lineStyle: { width: 1, color: '#f5e8c8', color0: '#b8d2c7' } } } }, graph: { color: colorPalette }, gauge : { axisLine: { lineStyle: { color: [[0.2, '#E01F54'],[0.8, '#b8d2c7'],[1, '#001852']], width: 8 } } } }; echarts.registerTheme('roma', theme); }));"},{"title":"","date":"2017-10-22T06:21:24.301Z","updated":"2017-10-22T05:33:49.207Z","comments":true,"path":"echarts/shine.js","permalink":"https://www.onlystar.site/echarts/shine.js","excerpt":"","text":"(function (root, factory) {if (typeof define === 'function' && define.amd) { // AMD. Register as an anonymous module. define(['exports', 'echarts'], factory); } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') { // CommonJS factory(exports, require('echarts')); } else { // Browser globals factory({}, root.echarts); } }(this, function (exports, echarts) { var log = function (msg) { if (typeof console !== 'undefined') { console && console.error && console.error(msg); } }; if (!echarts) { log('ECharts is not Loaded'); return; } var colorPalette = [ '#c12e34','#e6b600','#0098d9','#2b821d', '#005eaa','#339ca8','#cda819','#32a487' ]; var theme = { color: colorPalette, title: { textStyle: { fontWeight: 'normal' } }, visualMap: { color:['#1790cf','#a2d4e6'] }, toolbox: { iconStyle: { normal: { borderColor: '#06467c' } } }, tooltip: { backgroundColor: 'rgba(0,0,0,0.6)' }, dataZoom: { dataBackgroundColor: '#dedede', fillerColor: 'rgba(154,217,247,0.2)', handleColor: '#005eaa' }, timeline: { lineStyle: { color: '#005eaa' }, controlStyle: { normal: { color: '#005eaa', borderColor: '#005eaa' } } }, candlestick: { itemStyle: { normal: { color: '#c12e34', color0: '#2b821d', lineStyle: { width: 1, color: '#c12e34', color0: '#2b821d' } } } }, graph: { color: colorPalette }, map: { label: { normal: { textStyle: { color: '#c12e34' } }, emphasis: { textStyle: { color: '#c12e34' } } }, itemStyle: { normal: { borderColor: '#eee', areaColor: '#ddd' }, emphasis: { areaColor: '#e6b600' } } }, gauge: { axisLine: { show: true, lineStyle: { color: [[0.2, '#2b821d'],[0.8, '#005eaa'],[1, '#c12e34']], width: 5 } }, axisTick: { splitNumber: 10, length:8, lineStyle: { color: 'auto' } }, axisLabel: { textStyle: { color: 'auto' } }, splitLine: { length: 12, lineStyle: { color: 'auto' } }, pointer: { length: '90%', width: 3, color: 'auto' }, title: { textStyle: { color: '#333' } }, detail: { textStyle: { color: 'auto' } } } }; echarts.registerTheme('shine', theme); }));"},{"title":"","date":"2017-10-22T06:21:24.302Z","updated":"2017-10-22T05:33:44.757Z","comments":true,"path":"echarts/vintage.js","permalink":"https://www.onlystar.site/echarts/vintage.js","excerpt":"","text":"(function (root, factory) { if (typeof define === 'function' && define.amd) { // AMD. Register as an anonymous module. define(['exports', 'echarts'], factory); } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') { // CommonJS factory(exports, require('echarts')); } else { // Browser globals factory({}, root.echarts); } }(this, function (exports, echarts) { var log = function (msg) { if (typeof console !== 'undefined') { console && console.error && console.error(msg); } }; if (!echarts) { log('ECharts is not Loaded'); return; } var colorPalette = ['#d87c7c','#919e8b', '#d7ab82', '#6e7074','#61a0a8','#efa18d', '#787464', '#cc7e63', '#724e58', '#4b565b']; echarts.registerTheme('vintage', { color: colorPalette, backgroundColor: '#fef8ef', graph: { color: colorPalette } }); }));"},{"title":"","date":"2017-10-22T06:21:24.295Z","updated":"2017-10-21T07:15:20.000Z","comments":true,"path":"echarts/echarts.js","permalink":"https://www.onlystar.site/echarts/echarts.js","excerpt":"","text":"(function webpackUniversalModuleDefinition(root, factory) { if(typeof exports === 'object' && typeof module === 'object') module.exports = factory(); else if(typeof define === 'function' && define.amd) define([], factory); else if(typeof exports === 'object') exports[\"echarts\"] = factory(); else root[\"echarts\"] = factory(); })(this, function() { return /******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ // Check if module is in cache /******/ if(installedModules[moduleId]) /******/ return installedModules[moduleId].exports; /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ exports: {}, /******/ id: moduleId, /******/ loaded: false /******/ }; /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ // Flag the module as loaded /******/ module.loaded = true; /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ // __webpack_public_path__ /******/ __webpack_require__.p = \"\"; /******/ // Load entry module and return exports /******/ return __webpack_require__(0); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ (function(module, exports, __webpack_require__) { /** * Export echarts as CommonJS module */ module.exports = __webpack_require__(1); // Import all charts and components __webpack_require__(116); __webpack_require__(142); __webpack_require__(149); __webpack_require__(158); __webpack_require__(162); __webpack_require__(172); __webpack_require__(196); __webpack_require__(208); __webpack_require__(229); __webpack_require__(233); __webpack_require__(237); __webpack_require__(254); __webpack_require__(260); __webpack_require__(267); __webpack_require__(273); __webpack_require__(277); __webpack_require__(286); __webpack_require__(290); __webpack_require__(293); __webpack_require__(316); __webpack_require__(322); __webpack_require__(323); __webpack_require__(324); __webpack_require__(334); __webpack_require__(301); __webpack_require__(338); __webpack_require__(351); __webpack_require__(238); __webpack_require__(294); __webpack_require__(354); __webpack_require__(366); __webpack_require__(370); __webpack_require__(371); __webpack_require__(384); __webpack_require__(399); __webpack_require__(405); __webpack_require__(408); __webpack_require__(411); __webpack_require__(420); __webpack_require__(432); /***/ }), /* 1 */ /***/ (function(module, exports, __webpack_require__) { // Enable DEV mode when using source code without build. which has no __DEV__ variable // In build process 'typeof __DEV__' will be replace with 'boolean' // So this code will be removed or disabled anyway after built. if (false) { // In browser if (typeof window !== 'undefined') { window.__DEV__ = true; } // In node else if (typeof global !== 'undefined') { global.__DEV__ = true; } } /*! * ECharts, a javascript interactive chart library. * * Copyright (c) 2015, Baidu Inc. * All rights reserved. * * LICENSE * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt */ /** * @module echarts */ var env = __webpack_require__(2); var GlobalModel = __webpack_require__(3); var ExtensionAPI = __webpack_require__(78); var CoordinateSystemManager = __webpack_require__(79); var OptionManager = __webpack_require__(80); var backwardCompat = __webpack_require__(81); var ComponentModel = __webpack_require__(72); var SeriesModel = __webpack_require__(83); var ComponentView = __webpack_require__(84); var ChartView = __webpack_require__(85); var graphic = __webpack_require__(20); var modelUtil = __webpack_require__(5); var throttle = __webpack_require__(86); var zrender = __webpack_require__(87); var zrUtil = __webpack_require__(4); var colorTool = __webpack_require__(33); var Eventful = __webpack_require__(27); var timsort = __webpack_require__(91); var each = zrUtil.each; var parseClassType = ComponentModel.parseClassType; var PRIORITY_PROCESSOR_FILTER = 1000; var PRIORITY_PROCESSOR_STATISTIC = 5000; var PRIORITY_VISUAL_LAYOUT = 1000; var PRIORITY_VISUAL_GLOBAL = 2000; var PRIORITY_VISUAL_CHART = 3000; var PRIORITY_VISUAL_COMPONENT = 4000; // FIXME // necessary? var PRIORITY_VISUAL_BRUSH = 5000; // Main process have three entries: `setOption`, `dispatchAction` and `resize`, // where they must not be invoked nestedly, except the only case: invoke // dispatchAction with updateMethod \"none\" in main process. // This flag is used to carry out this rule. // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]). var IN_MAIN_PROCESS = '__flagInMainProcess'; var HAS_GRADIENT_OR_PATTERN_BG = '__hasGradientOrPatternBg'; var OPTION_UPDATED = '__optionUpdated'; var ACTION_REG = /^[a-zA-Z0-9_]+$/; function createRegisterEventWithLowercaseName(method) { return function (eventName, handler, context) { // Event name is all lowercase eventName = eventName && eventName.toLowerCase(); Eventful.prototype[method].call(this, eventName, handler, context); }; } /** * @module echarts~MessageCenter */ function MessageCenter() { Eventful.call(this); } MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on'); MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off'); MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one'); zrUtil.mixin(MessageCenter, Eventful); /** * @module echarts~ECharts */ function ECharts(dom, theme, opts) { opts = opts || {}; // Get theme by name if (typeof theme === 'string') { theme = themeStorage[theme]; } /** * @type {string} */ this.id; /** * Group id * @type {string} */ this.group; /** * @type {HTMLElement} * @private */ this._dom = dom; /** * @type {module:zrender/ZRender} * @private */ var zr = this._zr = zrender.init(dom, { renderer: opts.renderer || 'canvas', devicePixelRatio: opts.devicePixelRatio, width: opts.width, height: opts.height }); /** * Expect 60 pfs. * @type {Function} * @private */ this._throttledZrFlush = throttle.throttle(zrUtil.bind(zr.flush, zr), 17); var theme = zrUtil.clone(theme); theme && backwardCompat(theme, true); /** * @type {Object} * @private */ this._theme = theme; /** * @type {Array.} * @private */ this._chartsViews = []; /** * @type {Object.} * @private */ this._chartsMap = {}; /** * @type {Array.} * @private */ this._componentsViews = []; /** * @type {Object.} * @private */ this._componentsMap = {}; /** * @type {module:echarts/CoordinateSystem} * @private */ this._coordSysMgr = new CoordinateSystemManager(); /** * @type {module:echarts/ExtensionAPI} * @private */ this._api = createExtensionAPI(this); Eventful.call(this); /** * @type {module:echarts~MessageCenter} * @private */ this._messageCenter = new MessageCenter(); // Init mouse events this._initEvents(); // In case some people write `window.onresize = chart.resize` this.resize = zrUtil.bind(this.resize, this); // Can't dispatch action during rendering procedure this._pendingActions = []; // Sort on demand function prioritySortFunc(a, b) { return a.prio - b.prio; } timsort(visualFuncs, prioritySortFunc); timsort(dataProcessorFuncs, prioritySortFunc); zr.animation.on('frame', this._onframe, this); // ECharts instance can be used as value. zrUtil.setAsPrimitive(this); } var echartsProto = ECharts.prototype; echartsProto._onframe = function () { // Lazy update if (this[OPTION_UPDATED]) { var silent = this[OPTION_UPDATED].silent; this[IN_MAIN_PROCESS] = true; updateMethods.prepareAndUpdate.call(this); this[IN_MAIN_PROCESS] = false; this[OPTION_UPDATED] = false; flushPendingActions.call(this, silent); triggerUpdatedEvent.call(this, silent); } }; /** * @return {HTMLElement} */ echartsProto.getDom = function () { return this._dom; }; /** * @return {module:zrender~ZRender} */ echartsProto.getZr = function () { return this._zr; }; /** * Usage: * chart.setOption(option, notMerge, lazyUpdate); * chart.setOption(option, { * notMerge: ..., * lazyUpdate: ..., * silent: ... * }); * * @param {Object} option * @param {Object|boolean} [opts] opts or notMerge. * @param {boolean} [opts.notMerge=false] * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently. */ echartsProto.setOption = function (option, notMerge, lazyUpdate) { if (true) { zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.'); } var silent; if (zrUtil.isObject(notMerge)) { lazyUpdate = notMerge.lazyUpdate; silent = notMerge.silent; notMerge = notMerge.notMerge; } this[IN_MAIN_PROCESS] = true; if (!this._model || notMerge) { var optionManager = new OptionManager(this._api); var theme = this._theme; var ecModel = this._model = new GlobalModel(null, null, theme, optionManager); ecModel.init(null, null, theme, optionManager); } this._model.setOption(option, optionPreprocessorFuncs); if (lazyUpdate) { this[OPTION_UPDATED] = {silent: silent}; this[IN_MAIN_PROCESS] = false; } else { updateMethods.prepareAndUpdate.call(this); // Ensure zr refresh sychronously, and then pixel in canvas can be // fetched after `setOption`. this._zr.flush(); this[OPTION_UPDATED] = false; this[IN_MAIN_PROCESS] = false; flushPendingActions.call(this, silent); triggerUpdatedEvent.call(this, silent); } }; /** * @DEPRECATED */ echartsProto.setTheme = function () { console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0'); }; /** * @return {module:echarts/model/Global} */ echartsProto.getModel = function () { return this._model; }; /** * @return {Object} */ echartsProto.getOption = function () { return this._model && this._model.getOption(); }; /** * @return {number} */ echartsProto.getWidth = function () { return this._zr.getWidth(); }; /** * @return {number} */ echartsProto.getHeight = function () { return this._zr.getHeight(); }; /** * @return {number} */ echartsProto.getDevicePixelRatio = function () { return this._zr.painter.dpr || window.devicePixelRatio || 1; }; /** * Get canvas which has all thing rendered * @param {Object} opts * @param {string} [opts.backgroundColor] */ echartsProto.getRenderedCanvas = function (opts) { if (!env.canvasSupported) { return; } opts = opts || {}; opts.pixelRatio = opts.pixelRatio || 1; opts.backgroundColor = opts.backgroundColor || this._model.get('backgroundColor'); var zr = this._zr; var list = zr.storage.getDisplayList(); // Stop animations zrUtil.each(list, function (el) { el.stopAnimation(true); }); return zr.painter.getRenderedCanvas(opts); }; /** * @return {string} * @param {Object} opts * @param {string} [opts.type='png'] * @param {string} [opts.pixelRatio=1] * @param {string} [opts.backgroundColor] * @param {string} [opts.excludeComponents] */ echartsProto.getDataURL = function (opts) { opts = opts || {}; var excludeComponents = opts.excludeComponents; var ecModel = this._model; var excludesComponentViews = []; var self = this; each(excludeComponents, function (componentType) { ecModel.eachComponent({ mainType: componentType }, function (component) { var view = self._componentsMap[component.__viewId]; if (!view.group.ignore) { excludesComponentViews.push(view); view.group.ignore = true; } }); }); var url = this.getRenderedCanvas(opts).toDataURL( 'image/' + (opts && opts.type || 'png') ); each(excludesComponentViews, function (view) { view.group.ignore = false; }); return url; }; /** * @return {string} * @param {Object} opts * @param {string} [opts.type='png'] * @param {string} [opts.pixelRatio=1] * @param {string} [opts.backgroundColor] */ echartsProto.getConnectedDataURL = function (opts) { if (!env.canvasSupported) { return; } var groupId = this.group; var mathMin = Math.min; var mathMax = Math.max; var MAX_NUMBER = Infinity; if (connectedGroups[groupId]) { var left = MAX_NUMBER; var top = MAX_NUMBER; var right = -MAX_NUMBER; var bottom = -MAX_NUMBER; var canvasList = []; var dpr = (opts && opts.pixelRatio) || 1; zrUtil.each(instances, function (chart, id) { if (chart.group === groupId) { var canvas = chart.getRenderedCanvas( zrUtil.clone(opts) ); var boundingRect = chart.getDom().getBoundingClientRect(); left = mathMin(boundingRect.left, left); top = mathMin(boundingRect.top, top); right = mathMax(boundingRect.right, right); bottom = mathMax(boundingRect.bottom, bottom); canvasList.push({ dom: canvas, left: boundingRect.left, top: boundingRect.top }); } }); left *= dpr; top *= dpr; right *= dpr; bottom *= dpr; var width = right - left; var height = bottom - top; var targetCanvas = zrUtil.createCanvas(); targetCanvas.width = width; targetCanvas.height = height; var zr = zrender.init(targetCanvas); each(canvasList, function (item) { var img = new graphic.Image({ style: { x: item.left * dpr - left, y: item.top * dpr - top, image: item.dom } }); zr.add(img); }); zr.refreshImmediately(); return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png')); } else { return this.getDataURL(opts); } }; /** * Convert from logical coordinate system to pixel coordinate system. * See CoordinateSystem#convertToPixel. * @param {string|Object} finder * If string, e.g., 'geo', means {geoIndex: 0}. * If Object, could contain some of these properties below: * { * seriesIndex / seriesId / seriesName, * geoIndex / geoId, geoName, * bmapIndex / bmapId / bmapName, * xAxisIndex / xAxisId / xAxisName, * yAxisIndex / yAxisId / yAxisName, * gridIndex / gridId / gridName, * ... (can be extended) * } * @param {Array|number} value * @return {Array|number} result */ echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel'); /** * Convert from pixel coordinate system to logical coordinate system. * See CoordinateSystem#convertFromPixel. * @param {string|Object} finder * If string, e.g., 'geo', means {geoIndex: 0}. * If Object, could contain some of these properties below: * { * seriesIndex / seriesId / seriesName, * geoIndex / geoId / geoName, * bmapIndex / bmapId / bmapName, * xAxisIndex / xAxisId / xAxisName, * yAxisIndex / yAxisId / yAxisName * gridIndex / gridId / gridName, * ... (can be extended) * } * @param {Array|number} value * @return {Array|number} result */ echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel'); function doConvertPixel(methodName, finder, value) { var ecModel = this._model; var coordSysList = this._coordSysMgr.getCoordinateSystems(); var result; finder = modelUtil.parseFinder(ecModel, finder); for (var i = 0; i < coordSysList.length; i++) { var coordSys = coordSysList[i]; if (coordSys[methodName] && (result = coordSys[methodName](ecModel, finder, value)) != null ) { return result; } } if (true) { console.warn( 'No coordinate system that supports ' + methodName + ' found by the given finder.' ); } } /** * Is the specified coordinate systems or components contain the given pixel point. * @param {string|Object} finder * If string, e.g., 'geo', means {geoIndex: 0}. * If Object, could contain some of these properties below: * { * seriesIndex / seriesId / seriesName, * geoIndex / geoId / geoName, * bmapIndex / bmapId / bmapName, * xAxisIndex / xAxisId / xAxisName, * yAxisIndex / yAxisId / yAxisName, * gridIndex / gridId / gridName, * ... (can be extended) * } * @param {Array|number} value * @return {boolean} result */ echartsProto.containPixel = function (finder, value) { var ecModel = this._model; var result; finder = modelUtil.parseFinder(ecModel, finder); zrUtil.each(finder, function (models, key) { key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) { var coordSys = model.coordinateSystem; if (coordSys && coordSys.containPoint) { result |= !!coordSys.containPoint(value); } else if (key === 'seriesModels') { var view = this._chartsMap[model.__viewId]; if (view && view.containPoint) { result |= view.containPoint(value, model); } else { if (true) { console.warn(key + ': ' + (view ? 'The found component do not support containPoint.' : 'No view mapping to the found component.' )); } } } else { if (true) { console.warn(key + ': containPoint is not supported'); } } }, this); }, this); return !!result; }; /** * Get visual from series or data. * @param {string|Object} finder * If string, e.g., 'series', means {seriesIndex: 0}. * If Object, could contain some of these properties below: * { * seriesIndex / seriesId / seriesName, * dataIndex / dataIndexInside * } * If dataIndex is not specified, series visual will be fetched, * but not data item visual. * If all of seriesIndex, seriesId, seriesName are not specified, * visual will be fetched from first series. * @param {string} visualType 'color', 'symbol', 'symbolSize' */ echartsProto.getVisual = function (finder, visualType) { var ecModel = this._model; finder = modelUtil.parseFinder(ecModel, finder, {defaultMainType: 'series'}); var seriesModel = finder.seriesModel; if (true) { if (!seriesModel) { console.warn('There is no specified seires model'); } } var data = seriesModel.getData(); var dataIndexInside = finder.hasOwnProperty('dataIndexInside') ? finder.dataIndexInside : finder.hasOwnProperty('dataIndex') ? data.indexOfRawIndex(finder.dataIndex) : null; return dataIndexInside != null ? data.getItemVisual(dataIndexInside, visualType) : data.getVisual(visualType); }; /** * Get view of corresponding component model * @param {module:echarts/model/Component} componentModel * @return {module:echarts/view/Component} */ echartsProto.getViewOfComponentModel = function (componentModel) { return this._componentsMap[componentModel.__viewId]; }; /** * Get view of corresponding series model * @param {module:echarts/model/Series} seriesModel * @return {module:echarts/view/Chart} */ echartsProto.getViewOfSeriesModel = function (seriesModel) { return this._chartsMap[seriesModel.__viewId]; }; var updateMethods = { /** * @param {Object} payload * @private */ update: function (payload) { // console.profile && console.profile('update'); var ecModel = this._model; var api = this._api; var coordSysMgr = this._coordSysMgr; var zr = this._zr; // update before setOption if (!ecModel) { return; } // Fixme First time update ? ecModel.restoreData(); // TODO // Save total ecModel here for undo/redo (after restoring data and before processing data). // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call. // Create new coordinate system each update // In LineView may save the old coordinate system and use it to get the orignal point coordSysMgr.create(this._model, this._api); processData.call(this, ecModel, api); stackSeriesData.call(this, ecModel); coordSysMgr.update(ecModel, api); doVisualEncoding.call(this, ecModel, payload); doRender.call(this, ecModel, payload); // Set background var backgroundColor = ecModel.get('backgroundColor') || 'transparent'; var painter = zr.painter; // TODO all use clearColor ? if (painter.isSingleCanvas && painter.isSingleCanvas()) { zr.configLayer(0, { clearColor: backgroundColor }); } else { // In IE8 if (!env.canvasSupported) { var colorArr = colorTool.parse(backgroundColor); backgroundColor = colorTool.stringify(colorArr, 'rgb'); if (colorArr[3] === 0) { backgroundColor = 'transparent'; } } if (backgroundColor.colorStops || backgroundColor.image) { // Gradient background // FIXME Fixed layer？ zr.configLayer(0, { clearColor: backgroundColor }); this[HAS_GRADIENT_OR_PATTERN_BG] = true; this._dom.style.background = 'transparent'; } else { if (this[HAS_GRADIENT_OR_PATTERN_BG]) { zr.configLayer(0, { clearColor: null }); } this[HAS_GRADIENT_OR_PATTERN_BG] = false; this._dom.style.background = backgroundColor; } } each(postUpdateFuncs, function (func) { func(ecModel, api); }); // console.profile && console.profileEnd('update'); }, /** * @param {Object} payload * @private */ updateView: function (payload) { var ecModel = this._model; // update before setOption if (!ecModel) { return; } ecModel.eachSeries(function (seriesModel) { seriesModel.getData().clearAllVisual(); }); doVisualEncoding.call(this, ecModel, payload); invokeUpdateMethod.call(this, 'updateView', ecModel, payload); }, /** * @param {Object} payload * @private */ updateVisual: function (payload) { var ecModel = this._model; // update before setOption if (!ecModel) { return; } ecModel.eachSeries(function (seriesModel) { seriesModel.getData().clearAllVisual(); }); doVisualEncoding.call(this, ecModel, payload, true); invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload); }, /** * @param {Object} payload * @private */ updateLayout: function (payload) { var ecModel = this._model; // update before setOption if (!ecModel) { return; } doLayout.call(this, ecModel, payload); invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload); }, /** * @param {Object} payload * @private */ prepareAndUpdate: function (payload) { var ecModel = this._model; prepareView.call(this, 'component', ecModel); prepareView.call(this, 'chart', ecModel); updateMethods.update.call(this, payload); } }; /** * @private */ function updateDirectly(ecIns, method, payload, mainType, subType) { var ecModel = ecIns._model; // broadcast if (!mainType) { each(ecIns._componentsViews.concat(ecIns._chartsViews), callView); return; } var query = {}; query[mainType + 'Id'] = payload[mainType + 'Id']; query[mainType + 'Index'] = payload[mainType + 'Index']; query[mainType + 'Name'] = payload[mainType + 'Name']; var condition = {mainType: mainType, query: query}; subType && (condition.subType = subType); // subType may be '' by parseClassType; // If dispatchAction before setOption, do nothing. ecModel && ecModel.eachComponent(condition, function (model, index) { callView(ecIns[ mainType === 'series' ? '_chartsMap' : '_componentsMap' ][model.__viewId]); }, ecIns); function callView(view) { view && view.__alive && view[method] && view[method]( view.__model, ecModel, ecIns._api, payload ); } } /** * Resize the chart * @param {Object} opts * @param {number} [opts.width] Can be 'auto' (the same as null/undefined) * @param {number} [opts.height] Can be 'auto' (the same as null/undefined) * @param {boolean} [opts.silent=false] */ echartsProto.resize = function (opts) { if (true) { zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.'); } this[IN_MAIN_PROCESS] = true; this._zr.resize(opts); var optionChanged = this._model && this._model.resetOption('media'); var updateMethod = optionChanged ? 'prepareAndUpdate' : 'update'; updateMethods[updateMethod].call(this); // Resize loading effect this._loadingFX && this._loadingFX.resize(); this[IN_MAIN_PROCESS] = false; var silent = opts && opts.silent; flushPendingActions.call(this, silent); triggerUpdatedEvent.call(this, silent); }; /** * Show loading effect * @param {string} [name='default'] * @param {Object} [cfg] */ echartsProto.showLoading = function (name, cfg) { if (zrUtil.isObject(name)) { cfg = name; name = ''; } name = name || 'default'; this.hideLoading(); if (!loadingEffects[name]) { if (true) { console.warn('Loading effects ' + name + ' not exists.'); } return; } var el = loadingEffects[name](this._api, cfg); var zr = this._zr; this._loadingFX = el; zr.add(el); }; /** * Hide loading effect */ echartsProto.hideLoading = function () { this._loadingFX && this._zr.remove(this._loadingFX); this._loadingFX = null; }; /** * @param {Object} eventObj * @return {Object} */ echartsProto.makeActionFromEvent = function (eventObj) { var payload = zrUtil.extend({}, eventObj); payload.type = eventActionMap[eventObj.type]; return payload; }; /** * @pubilc * @param {Object} payload * @param {string} [payload.type] Action type * @param {Object|boolean} [opt] If pass boolean, means opt.silent * @param {boolean} [opt.silent=false] Whether trigger events. * @param {boolean} [opt.flush=undefined] * true: Flush immediately, and then pixel in canvas can be fetched * immediately. Caution: it might affect performance. * false: Not not flush. * undefined: Auto decide whether perform flush. */ echartsProto.dispatchAction = function (payload, opt) { if (!zrUtil.isObject(opt)) { opt = {silent: !!opt}; } if (!actions[payload.type]) { return; } // Avoid dispatch action before setOption. Especially in `connect`. if (!this._model) { return; } // May dispatchAction in rendering procedure if (this[IN_MAIN_PROCESS]) { this._pendingActions.push(payload); return; } doDispatchAction.call(this, payload, opt.silent); if (opt.flush) { this._zr.flush(true); } else if (opt.flush !== false && env.browser.weChat) { // In WeChat embeded browser, `requestAnimationFrame` and `setInterval` // hang when sliding page (on touch event), which cause that zr does not // refresh util user interaction finished, which is not expected. // But `dispatchAction` may be called too frequently when pan on touch // screen, which impacts performance if do not throttle them. this._throttledZrFlush(); } flushPendingActions.call(this, opt.silent); triggerUpdatedEvent.call(this, opt.silent); }; function doDispatchAction(payload, silent) { var payloadType = payload.type; var escapeConnect = payload.escapeConnect; var actionWrap = actions[payloadType]; var actionInfo = actionWrap.actionInfo; var cptType = (actionInfo.update || 'update').split(':'); var updateMethod = cptType.pop(); cptType = cptType[0] != null && parseClassType(cptType[0]); this[IN_MAIN_PROCESS] = true; var payloads = [payload]; var batched = false; // Batch action if (payload.batch) { batched = true; payloads = zrUtil.map(payload.batch, function (item) { item = zrUtil.defaults(zrUtil.extend({}, item), payload); item.batch = null; return item; }); } var eventObjBatch = []; var eventObj; var isHighDown = payloadType === 'highlight' || payloadType === 'downplay'; each(payloads, function (batchItem) { // Action can specify the event by return it. eventObj = actionWrap.action(batchItem, this._model, this._api); // Emit event outside eventObj = eventObj || zrUtil.extend({}, batchItem); // Convert type to eventType eventObj.type = actionInfo.event || eventObj.type; eventObjBatch.push(eventObj); // light update does not perform data process, layout and visual. if (isHighDown) { // method, payload, mainType, subType updateDirectly(this, updateMethod, batchItem, 'series'); } else if (cptType) { updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub); } }, this); if (updateMethod !== 'none' && !isHighDown && !cptType) { // Still dirty if (this[OPTION_UPDATED]) { // FIXME Pass payload ? updateMethods.prepareAndUpdate.call(this, payload); this[OPTION_UPDATED] = false; } else { updateMethods[updateMethod].call(this, payload); } } // Follow the rule of action batch if (batched) { eventObj = { type: actionInfo.event || payloadType, escapeConnect: escapeConnect, batch: eventObjBatch }; } else { eventObj = eventObjBatch[0]; } this[IN_MAIN_PROCESS] = false; !silent && this._messageCenter.trigger(eventObj.type, eventObj); } function flushPendingActions(silent) { var pendingActions = this._pendingActions; while (pendingActions.length) { var payload = pendingActions.shift(); doDispatchAction.call(this, payload, silent); } } function triggerUpdatedEvent(silent) { !silent && this.trigger('updated'); } /** * Register event * @method */ echartsProto.on = createRegisterEventWithLowercaseName('on'); echartsProto.off = createRegisterEventWithLowercaseName('off'); echartsProto.one = createRegisterEventWithLowercaseName('one'); /** * @param {string} methodName * @private */ function invokeUpdateMethod(methodName, ecModel, payload) { var api = this._api; // Update all components each(this._componentsViews, function (component) { var componentModel = component.__model; component[methodName](componentModel, ecModel, api, payload); updateZ(componentModel, component); }, this); // Upate all charts ecModel.eachSeries(function (seriesModel, idx) { var chart = this._chartsMap[seriesModel.__viewId]; chart[methodName](seriesModel, ecModel, api, payload); updateZ(seriesModel, chart); updateProgressiveAndBlend(seriesModel, chart); }, this); // If use hover layer updateHoverLayerStatus(this._zr, ecModel); // Post render each(postUpdateFuncs, function (func) { func(ecModel, api); }); } /** * Prepare view instances of charts and components * @param {module:echarts/model/Global} ecModel * @private */ function prepareView(type, ecModel) { var isComponent = type === 'component'; var viewList = isComponent ? this._componentsViews : this._chartsViews; var viewMap = isComponent ? this._componentsMap : this._chartsMap; var zr = this._zr; for (var i = 0; i < viewList.length; i++) { viewList[i].__alive = false; } ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) { if (isComponent) { if (componentType === 'series') { return; } } else { model = componentType; } // Consider: id same and type changed. var viewId = '_ec_' + model.id + '_' + model.type; var view = viewMap[viewId]; if (!view) { var classType = parseClassType(model.type); var Clazz = isComponent ? ComponentView.getClass(classType.main, classType.sub) : ChartView.getClass(classType.sub); if (Clazz) { view = new Clazz(); view.init(ecModel, this._api); viewMap[viewId] = view; viewList.push(view); zr.add(view.group); } else { // Error return; } } model.__viewId = view.__id = viewId; view.__alive = true; view.__model = model; view.group.__ecComponentInfo = { mainType: model.mainType, index: model.componentIndex }; }, this); for (var i = 0; i < viewList.length;) { var view = viewList[i]; if (!view.__alive) { zr.remove(view.group); view.dispose(ecModel, this._api); viewList.splice(i, 1); delete viewMap[view.__id]; view.__id = view.group.__ecComponentInfo = null; } else { i++; } } } /** * Processor data in each series * * @param {module:echarts/model/Global} ecModel * @private */ function processData(ecModel, api) { each(dataProcessorFuncs, function (process) { process.func(ecModel, api); }); } /** * @private */ function stackSeriesData(ecModel) { var stackedDataMap = {}; ecModel.eachSeries(function (series) { var stack = series.get('stack'); var data = series.getData(); if (stack && data.type === 'list') { var previousStack = stackedDataMap[stack]; // Avoid conflict with Object.prototype if (stackedDataMap.hasOwnProperty(stack) && previousStack) { data.stackedOn = previousStack; } stackedDataMap[stack] = data; } }); } /** * Layout before each chart render there series, special visual encoding stage * * @param {module:echarts/model/Global} ecModel * @private */ function doLayout(ecModel, payload) { var api = this._api; each(visualFuncs, function (visual) { if (visual.isLayout) { visual.func(ecModel, api, payload); } }); } /** * Encode visual infomation from data after data processing * * @param {module:echarts/model/Global} ecModel * @param {object} layout * @param {boolean} [excludesLayout] * @private */ function doVisualEncoding(ecModel, payload, excludesLayout) { var api = this._api; ecModel.clearColorPalette(); ecModel.eachSeries(function (seriesModel) { seriesModel.clearColorPalette(); }); each(visualFuncs, function (visual) { (!excludesLayout || !visual.isLayout) && visual.func(ecModel, api, payload); }); } /** * Render each chart and component * @private */ function doRender(ecModel, payload) { var api = this._api; // Render all components each(this._componentsViews, function (componentView) { var componentModel = componentView.__model; componentView.render(componentModel, ecModel, api, payload); updateZ(componentModel, componentView); }, this); each(this._chartsViews, function (chart) { chart.__alive = false; }, this); // Render all charts ecModel.eachSeries(function (seriesModel, idx) { var chartView = this._chartsMap[seriesModel.__viewId]; chartView.__alive = true; chartView.render(seriesModel, ecModel, api, payload); chartView.group.silent = !!seriesModel.get('silent'); updateZ(seriesModel, chartView); updateProgressiveAndBlend(seriesModel, chartView); }, this); // If use hover layer updateHoverLayerStatus(this._zr, ecModel); // Remove groups of unrendered charts each(this._chartsViews, function (chart) { if (!chart.__alive) { chart.remove(ecModel, api); } }, this); } var MOUSE_EVENT_NAMES = [ 'click', 'dblclick', 'mouseover', 'mouseout', 'mousemove', 'mousedown', 'mouseup', 'globalout', 'contextmenu' ]; /** * @private */ echartsProto._initEvents = function () { each(MOUSE_EVENT_NAMES, function (eveName) { this._zr.on(eveName, function (e) { var ecModel = this.getModel(); var el = e.target; var params; // no e.target when 'globalout'. if (eveName === 'globalout') { params = {}; } else if (el && el.dataIndex != null) { var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex); params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {}; } // If element has custom eventData of components else if (el && el.eventData) { params = zrUtil.extend({}, el.eventData); } if (params) { params.event = e; params.type = eveName; this.trigger(eveName, params); } }, this); }, this); each(eventActionMap, function (actionType, eventType) { this._messageCenter.on(eventType, function (event) { this.trigger(eventType, event); }, this); }, this); }; /** * @return {boolean} */ echartsProto.isDisposed = function () { return this._disposed; }; /** * Clear */ echartsProto.clear = function () { this.setOption({ series: [] }, true); }; /** * Dispose instance */ echartsProto.dispose = function () { if (this._disposed) { if (true) { console.warn('Instance ' + this.id + ' has been disposed'); } return; } this._disposed = true; var api = this._api; var ecModel = this._model; each(this._componentsViews, function (component) { component.dispose(ecModel, api); }); each(this._chartsViews, function (chart) { chart.dispose(ecModel, api); }); // Dispose after all views disposed this._zr.dispose(); delete instances[this.id]; }; zrUtil.mixin(ECharts, Eventful); function updateHoverLayerStatus(zr, ecModel) { var storage = zr.storage; var elCount = 0; storage.traverse(function (el) { if (!el.isGroup) { elCount++; } }); if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) { storage.traverse(function (el) { if (!el.isGroup) { el.useHoverLayer = true; } }); } } /** * Update chart progressive and blend. * @param {module:echarts/model/Series|module:echarts/model/Component} model * @param {module:echarts/view/Component|module:echarts/view/Chart} view */ function updateProgressiveAndBlend(seriesModel, chartView) { // Progressive configuration var elCount = 0; chartView.group.traverse(function (el) { if (el.type !== 'group' && !el.ignore) { elCount++; } }); var frameDrawNum = +seriesModel.get('progressive'); var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node; if (needProgressive) { chartView.group.traverse(function (el) { // FIXME marker and other components if (!el.isGroup) { el.progressive = needProgressive ? Math.floor(elCount++ / frameDrawNum) : -1; if (needProgressive) { el.stopAnimation(true); } } }); } // Blend configration var blendMode = seriesModel.get('blendMode') || null; if (true) { if (!env.canvasSupported && blendMode && blendMode !== 'source-over') { console.warn('Only canvas support blendMode'); } } chartView.group.traverse(function (el) { // FIXME marker and other components if (!el.isGroup) { el.setStyle('blend', blendMode); } }); } /** * @param {module:echarts/model/Series|module:echarts/model/Component} model * @param {module:echarts/view/Component|module:echarts/view/Chart} view */ function updateZ(model, view) { var z = model.get('z'); var zlevel = model.get('zlevel'); // Set z and zlevel view.group.traverse(function (el) { if (el.type !== 'group') { z != null && (el.z = z); zlevel != null && (el.zlevel = zlevel); } }); } function createExtensionAPI(ecInstance) { var coordSysMgr = ecInstance._coordSysMgr; return zrUtil.extend(new ExtensionAPI(ecInstance), { // Inject methods getCoordinateSystems: zrUtil.bind( coordSysMgr.getCoordinateSystems, coordSysMgr ), getComponentByElement: function (el) { while (el) { var modelInfo = el.__ecComponentInfo; if (modelInfo != null) { return ecInstance._model.getComponent(modelInfo.mainType, modelInfo.index); } el = el.parent; } } }); } /** * @type {Object} key: actionType. * @inner */ var actions = {}; /** * Map eventType to actionType * @type {Object} */ var eventActionMap = {}; /** * Data processor functions of each stage * @type {Array.} * @inner */ var dataProcessorFuncs = []; /** * @type {Array.} * @inner */ var optionPreprocessorFuncs = []; /** * @type {Array.} * @inner */ var postUpdateFuncs = []; /** * Visual encoding functions of each stage * @type {Array.} * @inner */ var visualFuncs = []; /** * Theme storage * @type {Object.} */ var themeStorage = {}; /** * Loading effects */ var loadingEffects = {}; var instances = {}; var connectedGroups = {}; var idBase = new Date() - 0; var groupIdBase = new Date() - 0; var DOM_ATTRIBUTE_KEY = '_echarts_instance_'; /** * @alias module:echarts */ var echarts = { /** * @type {number} */ version: '3.7.2', dependencies: { zrender: '3.6.2' } }; function enableConnect(chart) { var STATUS_PENDING = 0; var STATUS_UPDATING = 1; var STATUS_UPDATED = 2; var STATUS_KEY = '__connectUpdateStatus'; function updateConnectedChartsStatus(charts, status) { for (var i = 0; i < charts.length; i++) { var otherChart = charts[i]; otherChart[STATUS_KEY] = status; } } zrUtil.each(eventActionMap, function (actionType, eventType) { chart._messageCenter.on(eventType, function (event) { if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) { if (event && event.escapeConnect) { return; } var action = chart.makeActionFromEvent(event); var otherCharts = []; zrUtil.each(instances, function (otherChart) { if (otherChart !== chart && otherChart.group === chart.group) { otherCharts.push(otherChart); } }); updateConnectedChartsStatus(otherCharts, STATUS_PENDING); each(otherCharts, function (otherChart) { if (otherChart[STATUS_KEY] !== STATUS_UPDATING) { otherChart.dispatchAction(action); } }); updateConnectedChartsStatus(otherCharts, STATUS_UPDATED); } }); }); } /** * @param {HTMLElement} dom * @param {Object} [theme] * @param {Object} opts * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default * @param {string} [opts.renderer] Currently only 'canvas' is supported. * @param {number} [opts.width] Use clientWidth of the input `dom` by default. * Can be 'auto' (the same as null/undefined) * @param {number} [opts.height] Use clientHeight of the input `dom` by default. * Can be 'auto' (the same as null/undefined) */ echarts.init = function (dom, theme, opts) { if (true) { // Check version if ((zrender.version.replace('.', '') - 0) < (echarts.dependencies.zrender.replace('.', '') - 0)) { throw new Error( 'ZRender ' + zrender.version + ' is too old for ECharts ' + echarts.version + '. Current version need ZRender ' + echarts.dependencies.zrender + '+' ); } if (!dom) { throw new Error('Initialize failed: invalid dom.'); } } var existInstance = echarts.getInstanceByDom(dom); if (existInstance) { if (true) { console.warn('There is a chart instance already initialized on the dom.'); } return existInstance; } if (true) { if (zrUtil.isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && ( (!dom.clientWidth && (!opts || opts.width == null)) || (!dom.clientHeight && (!opts || opts.height == null)) ) ) { console.warn('Can\\'t get dom width or height'); } } var chart = new ECharts(dom, theme, opts); chart.id = 'ec_' + idBase++; instances[chart.id] = chart; if (dom.setAttribute) { dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id); } else { dom[DOM_ATTRIBUTE_KEY] = chart.id; } enableConnect(chart); return chart; }; /** * @return {string|Array.} groupId */ echarts.connect = function (groupId) { // Is array of charts if (zrUtil.isArray(groupId)) { var charts = groupId; groupId = null; // If any chart has group zrUtil.each(charts, function (chart) { if (chart.group != null) { groupId = chart.group; } }); groupId = groupId || ('g_' + groupIdBase++); zrUtil.each(charts, function (chart) { chart.group = groupId; }); } connectedGroups[groupId] = true; return groupId; }; /** * @DEPRECATED * @return {string} groupId */ echarts.disConnect = function (groupId) { connectedGroups[groupId] = false; }; /** * @return {string} groupId */ echarts.disconnect = echarts.disConnect; /** * Dispose a chart instance * @param {module:echarts~ECharts|HTMLDomElement|string} chart */ echarts.dispose = function (chart) { if (typeof chart === 'string') { chart = instances[chart]; } else if (!(chart instanceof ECharts)){ // Try to treat as dom chart = echarts.getInstanceByDom(chart); } if ((chart instanceof ECharts) && !chart.isDisposed()) { chart.dispose(); } }; /** * @param {HTMLElement} dom * @return {echarts~ECharts} */ echarts.getInstanceByDom = function (dom) { var key; if (dom.getAttribute) { key = dom.getAttribute(DOM_ATTRIBUTE_KEY); } else { key = dom[DOM_ATTRIBUTE_KEY]; } return instances[key]; }; /** * @param {string} key * @return {echarts~ECharts} */ echarts.getInstanceById = function (key) { return instances[key]; }; /** * Register theme */ echarts.registerTheme = function (name, theme) { themeStorage[name] = theme; }; /** * Register option preprocessor * @param {Function} preprocessorFunc */ echarts.registerPreprocessor = function (preprocessorFunc) { optionPreprocessorFuncs.push(preprocessorFunc); }; /** * @param {number} [priority=1000] * @param {Function} processorFunc */ echarts.registerProcessor = function (priority, processorFunc) { if (typeof priority === 'function') { processorFunc = priority; priority = PRIORITY_PROCESSOR_FILTER; } if (true) { if (isNaN(priority)) { throw new Error('Unkown processor priority'); } } dataProcessorFuncs.push({ prio: priority, func: processorFunc }); }; /** * Register postUpdater * @param {Function} postUpdateFunc */ echarts.registerPostUpdate = function (postUpdateFunc) { postUpdateFuncs.push(postUpdateFunc); }; /** * Usage: * registerAction('someAction', 'someEvent', function () { ... }); * registerAction('someAction', function () { ... }); * registerAction( * {type: 'someAction', event: 'someEvent', update: 'updateView'}, * function () { ... } * ); * * @param {(string|Object)} actionInfo * @param {string} actionInfo.type * @param {string} [actionInfo.event] * @param {string} [actionInfo.update] * @param {string} [eventName] * @param {Function} action */ echarts.registerAction = function (actionInfo, eventName, action) { if (typeof eventName === 'function') { action = eventName; eventName = ''; } var actionType = zrUtil.isObject(actionInfo) ? actionInfo.type : ([actionInfo, actionInfo = { event: eventName }][0]); // Event name is all lowercase actionInfo.event = (actionInfo.event || actionType).toLowerCase(); eventName = actionInfo.event; // Validate action type and event name. zrUtil.assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName)); if (!actions[actionType]) { actions[actionType] = {action: action, actionInfo: actionInfo}; } eventActionMap[eventName] = actionType; }; /** * @param {string} type * @param {*} CoordinateSystem */ echarts.registerCoordinateSystem = function (type, CoordinateSystem) { CoordinateSystemManager.register(type, CoordinateSystem); }; /** * Get dimensions of specified coordinate system. * @param {string} type * @return {Array.} */ echarts.getCoordinateSystemDimensions = function (type) { var coordSysCreator = CoordinateSystemManager.get(type); if (coordSysCreator) { return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice(); } }; /** * Layout is a special stage of visual encoding * Most visual encoding like color are common for different chart * But each chart has it's own layout algorithm * * @param {number} [priority=1000] * @param {Function} layoutFunc */ echarts.registerLayout = function (priority, layoutFunc) { if (typeof priority === 'function') { layoutFunc = priority; priority = PRIORITY_VISUAL_LAYOUT; } if (true) { if (isNaN(priority)) { throw new Error('Unkown layout priority'); } } visualFuncs.push({ prio: priority, func: layoutFunc, isLayout: true }); }; /** * @param {number} [priority=3000] * @param {Function} visualFunc */ echarts.registerVisual = function (priority, visualFunc) { if (typeof priority === 'function') { visualFunc = priority; priority = PRIORITY_VISUAL_CHART; } if (true) { if (isNaN(priority)) { throw new Error('Unkown visual priority'); } } visualFuncs.push({ prio: priority, func: visualFunc }); }; /** * @param {string} name */ echarts.registerLoading = function (name, loadingFx) { loadingEffects[name] = loadingFx; }; /** * @param {Object} opts * @param {string} [superClass] */ echarts.extendComponentModel = function (opts/*, superClass*/) { // var Clazz = ComponentModel; // if (superClass) { // var classType = parseClassType(superClass); // Clazz = ComponentModel.getClass(classType.main, classType.sub, true); // } return ComponentModel.extend(opts); }; /** * @param {Object} opts * @param {string} [superClass] */ echarts.extendComponentView = function (opts/*, superClass*/) { // var Clazz = ComponentView; // if (superClass) { // var classType = parseClassType(superClass); // Clazz = ComponentView.getClass(classType.main, classType.sub, true); // } return ComponentView.extend(opts); }; /** * @param {Object} opts * @param {string} [superClass] */ echarts.extendSeriesModel = function (opts/*, superClass*/) { // var Clazz = SeriesModel; // if (superClass) { // superClass = 'series.' + superClass.replace('series.', ''); // var classType = parseClassType(superClass); // Clazz = ComponentModel.getClass(classType.main, classType.sub, true); // } return SeriesModel.extend(opts); }; /** * @param {Object} opts * @param {string} [superClass] */ echarts.extendChartView = function (opts/*, superClass*/) { // var Clazz = ChartView; // if (superClass) { // superClass = superClass.replace('series.', ''); // var classType = parseClassType(superClass); // Clazz = ChartView.getClass(classType.main, true); // } return ChartView.extend(opts); }; /** * ZRender need a canvas context to do measureText. * But in node environment canvas may be created by node-canvas. * So we need to specify how to create a canvas instead of using document.createElement('canvas') * * Be careful of using it in the browser. * * @param {Function} creator * @example * var Canvas = require('canvas'); * var echarts = require('echarts'); * echarts.setCanvasCreator(function () { * // Small size is enough. * return new Canvas(32, 32); * }); */ echarts.setCanvasCreator = function (creator) { zrUtil.createCanvas = creator; }; echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, __webpack_require__(99)); echarts.registerPreprocessor(backwardCompat); echarts.registerLoading('default', __webpack_require__(100)); // Default action echarts.registerAction({ type: 'highlight', event: 'highlight', update: 'highlight' }, zrUtil.noop); echarts.registerAction({ type: 'downplay', event: 'downplay', update: 'downplay' }, zrUtil.noop); // -------- // Exports // -------- echarts.zrender = zrender; echarts.List = __webpack_require__(101); echarts.Model = __webpack_require__(14); echarts.Axis = __webpack_require__(103); echarts.graphic = __webpack_require__(20); echarts.number = __webpack_require__(7); echarts.format = __webpack_require__(6); echarts.throttle = throttle.throttle; echarts.matrix = __webpack_require__(11); echarts.vector = __webpack_require__(10); echarts.color = __webpack_require__(33); echarts.util = {}; each([ 'map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter', 'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction', 'extend', 'defaults', 'clone', 'merge' ], function (name) { echarts.util[name] = zrUtil[name]; } ); echarts.helper = __webpack_require__(111); // PRIORITY echarts.PRIORITY = { PROCESSOR: { FILTER: PRIORITY_PROCESSOR_FILTER, STATISTIC: PRIORITY_PROCESSOR_STATISTIC }, VISUAL: { LAYOUT: PRIORITY_VISUAL_LAYOUT, GLOBAL: PRIORITY_VISUAL_GLOBAL, CHART: PRIORITY_VISUAL_CHART, COMPONENT: PRIORITY_VISUAL_COMPONENT, BRUSH: PRIORITY_VISUAL_BRUSH } }; module.exports = echarts; /***/ }), /* 2 */ /***/ (function(module, exports) { /** * echarts设备环境识别 * * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。 * @author firede[firede@firede.us] * @desc thanks zepto. */ var env = {}; if (typeof navigator === 'undefined') { // In node env = { browser: {}, os: {}, node: true, // Assume canvas is supported canvasSupported: true }; } else { env = detect(navigator.userAgent); } module.exports = env; // Zepto.js // (c) 2010-2013 Thomas Fuchs // Zepto.js may be freely distributed under the MIT license. function detect(ua) { var os = {}; var browser = {}; // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/); // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/); // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/); // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/); // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/); // var touchpad = webos && ua.match(/TouchPad/); // var kindle = ua.match(/Kindle\\/([\\d.]+)/); // var silk = ua.match(/Silk\\/([\\d._]+)/); // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/); // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/); // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/); // var playbook = ua.match(/PlayBook/); // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/); var firefox = ua.match(/Firefox\\/([\\d.]+)/); // var safari = webkit && ua.match(/Mobile\\//) && !chrome; // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome; var ie = ua.match(/MSIE\\s([\\d.]+)/) // IE 11 Trident/7.0; rv:11.0 || ua.match(/Trident\\/.+?rv:(([\\d.]+))/); var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+ var weChat = (/micromessenger/i).test(ua); // Todo: clean this up with a better OS/browser seperation: // - discern (more) between multiple browsers on android // - decide if kindle fire in silk mode is android or not // - Firefox on Android doesn't specify the Android version // - possibly devide in os, device and browser hashes // if (browser.webkit = !!webkit) browser.version = webkit[1]; // if (android) os.android = true, os.version = android[2]; // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.'); // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.'); // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null; // if (webos) os.webos = true, os.version = webos[2]; // if (touchpad) os.touchpad = true; // if (blackberry) os.blackberry = true, os.version = blackberry[2]; // if (bb10) os.bb10 = true, os.version = bb10[2]; // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2]; // if (playbook) browser.playbook = true; // if (kindle) os.kindle = true, os.version = kindle[1]; // if (silk) browser.silk = true, browser.version = silk[1]; // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true; // if (chrome) browser.chrome = true, browser.version = chrome[1]; if (firefox) { browser.firefox = true; browser.version = firefox[1]; } // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true; // if (webview) browser.webview = true; if (ie) { browser.ie = true; browser.version = ie[1]; } if (edge) { browser.edge = true; browser.version = edge[1]; } // It is difficult to detect WeChat in Win Phone precisely, because ua can // not be set on win phone. So we do not consider Win Phone. if (weChat) { browser.weChat = true; } // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) || // (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/))); // os.phone = !!(!os.tablet && !os.ipod && (android || iphone || webos || // (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) || // (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/)))); return { browser: browser, os: os, node: false, // 原生canvas支持，改极端点了 // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9) canvasSupported : document.createElement('canvas').getContext ? true : false, // @see // works on most browsers // IE10/11 does not support touch event, and MS Edge supports them but not by // default, so we dont check navigator.maxTouchPoints for them here. touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge, // . pointerEventsSupported: 'onpointerdown' in window // Firefox supports pointer but not by default, only MS browsers are reliable on pointer // events currently. So we dont use that on other browsers unless tested sufficiently. // Although IE 10 supports pointer event, it use old style and is different from the // standard. So we exclude that. (IE 10 is hardly used on touch device) && (browser.edge || (browser.ie && browser.version >= 11)) }; } /***/ }), /* 3 */ /***/ (function(module, exports, __webpack_require__) { /** * ECharts global model * * @module {echarts/model/Global} */ /** * Caution: If the mechanism should be changed some day, these cases * should be considered: * * (1) In `merge option` mode, if using the same option to call `setOption` * many times, the result should be the same (try our best to ensure that). * (2) In `merge option` mode, if a component has no id/name specified, it * will be merged by index, and the result sequence of the components is * consistent to the original sequence. * (3) `reset` feature (in toolbox). Find detailed info in comments about * `mergeOption` in module:echarts/model/OptionManager. */ var zrUtil = __webpack_require__(4); var modelUtil = __webpack_require__(5); var Model = __webpack_require__(14); var each = zrUtil.each; var filter = zrUtil.filter; var map = zrUtil.map; var isArray = zrUtil.isArray; var indexOf = zrUtil.indexOf; var isObject = zrUtil.isObject; var ComponentModel = __webpack_require__(72); var globalDefault = __webpack_require__(76); var OPTION_INNER_KEY = '\\0_ec_inner'; /** * @alias module:echarts/model/Global * * @param {Object} option * @param {module:echarts/model/Model} parentModel * @param {Object} theme */ var GlobalModel = Model.extend({ constructor: GlobalModel, init: function (option, parentModel, theme, optionManager) { theme = theme || {}; this.option = null; // Mark as not initialized. /** * @type {module:echarts/model/Model} * @private */ this._theme = new Model(theme); /** * @type {module:echarts/model/OptionManager} */ this._optionManager = optionManager; }, setOption: function (option, optionPreprocessorFuncs) { zrUtil.assert( !(OPTION_INNER_KEY in option), 'please use chart.getOption()' ); this._optionManager.setOption(option, optionPreprocessorFuncs); this.resetOption(null); }, /** * @param {string} type null/undefined: reset all. * 'recreate': force recreate all. * 'timeline': only reset timeline option * 'media': only reset media query option * @return {boolean} Whether option changed. */ resetOption: function (type) { var optionChanged = false; var optionManager = this._optionManager; if (!type || type === 'recreate') { var baseOption = optionManager.mountOption(type === 'recreate'); if (!this.option || type === 'recreate') { initBase.call(this, baseOption); } else { this.restoreData(); this.mergeOption(baseOption); } optionChanged = true; } if (type === 'timeline' || type === 'media') { this.restoreData(); } if (!type || type === 'recreate' || type === 'timeline') { var timelineOption = optionManager.getTimelineOption(this); timelineOption && (this.mergeOption(timelineOption), optionChanged = true); } if (!type || type === 'recreate' || type === 'media') { var mediaOptions = optionManager.getMediaOption(this, this._api); if (mediaOptions.length) { each(mediaOptions, function (mediaOption) { this.mergeOption(mediaOption, optionChanged = true); }, this); } } return optionChanged; }, /** * @protected */ mergeOption: function (newOption) { var option = this.option; var componentsMap = this._componentsMap; var newCptTypes = []; // 如果不存在对应的 component model 则直接 merge each(newOption, function (componentOption, mainType) { if (componentOption == null) { return; } if (!ComponentModel.hasClass(mainType)) { option[mainType] = option[mainType] == null ? zrUtil.clone(componentOption) : zrUtil.merge(option[mainType], componentOption, true); } else { newCptTypes.push(mainType); } }); // FIXME OPTION 同步是否要改回原来的 ComponentModel.topologicalTravel( newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this ); this._seriesIndices = this._seriesIndices || []; function visitComponent(mainType, dependencies) { var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]); var mapResult = modelUtil.mappingToExists( componentsMap.get(mainType), newCptOptionList ); modelUtil.makeIdAndName(mapResult); // Set mainType and complete subType. each(mapResult, function (item, index) { var opt = item.option; if (isObject(opt)) { item.keyInfo.mainType = mainType; item.keyInfo.subType = determineSubType(mainType, opt, item.exist); } }); var dependentModels = getComponentsByTypes( componentsMap, dependencies ); option[mainType] = []; componentsMap.set(mainType, []); each(mapResult, function (resultItem, index) { var componentModel = resultItem.exist; var newCptOption = resultItem.option; zrUtil.assert( isObject(newCptOption) || componentModel, 'Empty component definition' ); // Consider where is no new option and should be merged using {}, // see removeEdgeAndAdd in topologicalTravel and // ComponentModel.getAllClassMainTypes. if (!newCptOption) { componentModel.mergeOption({}, this); componentModel.optionUpdated({}, false); } else { var ComponentModelClass = ComponentModel.getClass( mainType, resultItem.keyInfo.subType, true ); if (componentModel && componentModel instanceof ComponentModelClass) { componentModel.name = resultItem.keyInfo.name; componentModel.mergeOption(newCptOption, this); componentModel.optionUpdated(newCptOption, false); } else { // PENDING Global as parent ? var extraOpt = zrUtil.extend( { dependentModels: dependentModels, componentIndex: index }, resultItem.keyInfo ); componentModel = new ComponentModelClass( newCptOption, this, this, extraOpt ); zrUtil.extend(componentModel, extraOpt); componentModel.init(newCptOption, this, this, extraOpt); // Call optionUpdated after init. // newCptOption has been used as componentModel.option // and may be merged with theme and default, so pass null // to avoid confusion. componentModel.optionUpdated(null, true); } } componentsMap.get(mainType)[index] = componentModel; option[mainType][index] = componentModel.option; }, this); // Backup series for filtering. if (mainType === 'series') { this._seriesIndices = createSeriesIndices(componentsMap.get('series')); } } }, /** * Get option for output (cloned option and inner info removed) * @public * @return {Object} */ getOption: function () { var option = zrUtil.clone(this.option); each(option, function (opts, mainType) { if (ComponentModel.hasClass(mainType)) { var opts = modelUtil.normalizeToArray(opts); for (var i = opts.length - 1; i >= 0; i--) { // Remove options with inner id. if (modelUtil.isIdInner(opts[i])) { opts.splice(i, 1); } } option[mainType] = opts; } }); delete option[OPTION_INNER_KEY]; return option; }, /** * @return {module:echarts/model/Model} */ getTheme: function () { return this._theme; }, /** * @param {string} mainType * @param {number} [idx=0] * @return {module:echarts/model/Component} */ getComponent: function (mainType, idx) { var list = this._componentsMap.get(mainType); if (list) { return list[idx || 0]; } }, /** * If none of index and id and name used, return all components with mainType. * @param {Object} condition * @param {string} condition.mainType * @param {string} [condition.subType] If ignore, only query by mainType * @param {number|Array.} [condition.index] Either input index or id or name. * @param {string|Array.} [condition.id] Either input index or id or name. * @param {string|Array.} [condition.name] Either input index or id or name. * @return {Array.} */ queryComponents: function (condition) { var mainType = condition.mainType; if (!mainType) { return []; } var index = condition.index; var id = condition.id; var name = condition.name; var cpts = this._componentsMap.get(mainType); if (!cpts || !cpts.length) { return []; } var result; if (index != null) { if (!isArray(index)) { index = [index]; } result = filter(map(index, function (idx) { return cpts[idx]; }), function (val) { return !!val; }); } else if (id != null) { var isIdArray = isArray(id); result = filter(cpts, function (cpt) { return (isIdArray && indexOf(id, cpt.id) >= 0) || (!isIdArray && cpt.id === id); }); } else if (name != null) { var isNameArray = isArray(name); result = filter(cpts, function (cpt) { return (isNameArray && indexOf(name, cpt.name) >= 0) || (!isNameArray && cpt.name === name); }); } else { // Return all components with mainType result = cpts.slice(); } return filterBySubType(result, condition); }, /** * The interface is different from queryComponents, * which is convenient for inner usage. * * @usage * var result = findComponents( * {mainType: 'dataZoom', query: {dataZoomId: 'abc'}} * ); * var result = findComponents( * {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}} * ); * var result = findComponents( * {mainType: 'series'}, * function (model, index) {...} * ); * // result like [component0, componnet1, ...] * * @param {Object} condition * @param {string} condition.mainType Mandatory. * @param {string} [condition.subType] Optional. * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName}, * where xxx is mainType. * If query attribute is null/undefined or has no index/id/name, * do not filtering by query conditions, which is convenient for * no-payload situations or when target of action is global. * @param {Function} [condition.filter] parameter: component, return boolean. * @return {Array.} */ findComponents: function (condition) { var query = condition.query; var mainType = condition.mainType; var queryCond = getQueryCond(query); var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap.get(mainType); return doFilter(filterBySubType(result, condition)); function getQueryCond(q) { var indexAttr = mainType + 'Index'; var idAttr = mainType + 'Id'; var nameAttr = mainType + 'Name'; return q && ( q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null ) ? { mainType: mainType, // subType will be filtered finally. index: q[indexAttr], id: q[idAttr], name: q[nameAttr] } : null; } function doFilter(res) { return condition.filter ? filter(res, condition.filter) : res; } }, /** * @usage * eachComponent('legend', function (legendModel, index) { * ... * }); * eachComponent(function (componentType, model, index) { * // componentType does not include subType * // (componentType is 'xxx' but not 'xxx.aa') * }); * eachComponent( * {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}, * function (model, index) {...} * ); * eachComponent( * {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}, * function (model, index) {...} * ); * * @param {string|Object=} mainType When mainType is object, the definition * is the same as the method 'findComponents'. * @param {Function} cb * @param {*} context */ eachComponent: function (mainType, cb, context) { var componentsMap = this._componentsMap; if (typeof mainType === 'function') { context = cb; cb = mainType; componentsMap.each(function (components, componentType) { each(components, function (component, index) { cb.call(context, componentType, component, index); }); }); } else if (zrUtil.isString(mainType)) { each(componentsMap.get(mainType), cb, context); } else if (isObject(mainType)) { var queryResult = this.findComponents(mainType); each(queryResult, cb, context); } }, /** * @param {string} name * @return {Array.} */ getSeriesByName: function (name) { var series = this._componentsMap.get('series'); return filter(series, function (oneSeries) { return oneSeries.name === name; }); }, /** * @param {number} seriesIndex * @return {module:echarts/model/Series} */ getSeriesByIndex: function (seriesIndex) { return this._componentsMap.get('series')[seriesIndex]; }, /** * @param {string} subType * @return {Array.} */ getSeriesByType: function (subType) { var series = this._componentsMap.get('series'); return filter(series, function (oneSeries) { return oneSeries.subType === subType; }); }, /** * @return {Array.} */ getSeries: function () { return this._componentsMap.get('series').slice(); }, /** * After filtering, series may be different * frome raw series. * * @param {Function} cb * @param {*} context */ eachSeries: function (cb, context) { assertSeriesInitialized(this); each(this._seriesIndices, function (rawSeriesIndex) { var series = this._componentsMap.get('series')[rawSeriesIndex]; cb.call(context, series, rawSeriesIndex); }, this); }, /** * Iterate raw series before filtered. * * @param {Function} cb * @param {*} context */ eachRawSeries: function (cb, context) { each(this._componentsMap.get('series'), cb, context); }, /** * After filtering, series may be different. * frome raw series. * * @parma {string} subType * @param {Function} cb * @param {*} context */ eachSeriesByType: function (subType, cb, context) { assertSeriesInitialized(this); each(this._seriesIndices, function (rawSeriesIndex) { var series = this._componentsMap.get('series')[rawSeriesIndex]; if (series.subType === subType) { cb.call(context, series, rawSeriesIndex); } }, this); }, /** * Iterate raw series before filtered of given type. * * @parma {string} subType * @param {Function} cb * @param {*} context */ eachRawSeriesByType: function (subType, cb, context) { return each(this.getSeriesByType(subType), cb, context); }, /** * @param {module:echarts/model/Series} seriesModel */ isSeriesFiltered: function (seriesModel) { assertSeriesInitialized(this); return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0; }, /** * @return {Array.} */ getCurrentSeriesIndices: function () { return (this._seriesIndices || []).slice(); }, /** * @param {Function} cb * @param {*} context */ filterSeries: function (cb, context) { assertSeriesInitialized(this); var filteredSeries = filter( this._componentsMap.get('series'), cb, context ); this._seriesIndices = createSeriesIndices(filteredSeries); }, restoreData: function () { var componentsMap = this._componentsMap; this._seriesIndices = createSeriesIndices(componentsMap.get('series')); var componentTypes = []; componentsMap.each(function (components, componentType) { componentTypes.push(componentType); }); ComponentModel.topologicalTravel( componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType, dependencies) { each(componentsMap.get(componentType), function (component) { component.restoreData(); }); } ); } }); /** * @inner */ function mergeTheme(option, theme) { zrUtil.each(theme, function (themeItem, name) { // 如果有 component model 则把具体的 merge 逻辑交给该 model 处理 if (!ComponentModel.hasClass(name)) { if (typeof themeItem === 'object') { option[name] = !option[name] ? zrUtil.clone(themeItem) : zrUtil.merge(option[name], themeItem, false); } else { if (option[name] == null) { option[name] = themeItem; } } } }); } function initBase(baseOption) { baseOption = baseOption; // Using OPTION_INNER_KEY to mark that this option can not be used outside, // i.e. `chart.setOption(chart.getModel().option);` is forbiden. this.option = {}; this.option[OPTION_INNER_KEY] = 1; /** * Init with series: [], in case of calling findSeries method * before series initialized. * @type {Object.} * @private */ this._componentsMap = zrUtil.createHashMap({series: []}); /** * Mapping between filtered series list and raw series list. * key: filtered series indices, value: raw series indices. * @type {Array.} * @private */ this._seriesIndices = null; mergeTheme(baseOption, this._theme.option); // TODO Needs clone when merging to the unexisted property zrUtil.merge(baseOption, globalDefault, false); this.mergeOption(baseOption); } /** * @inner * @param {Array.|string} types model types * @return {Object} key: {string} type, value: {Array.} models */ function getComponentsByTypes(componentsMap, types) { if (!zrUtil.isArray(types)) { types = types ? [types] : []; } var ret = {}; each(types, function (type) { ret[type] = (componentsMap.get(type) || []).slice(); }); return ret; } /** * @inner */ function determineSubType(mainType, newCptOption, existComponent) { var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType // Use determineSubType only when there is no existComponent. : ComponentModel.determineSubType(mainType, newCptOption); // tooltip, markline, markpoint may always has no subType return subType; } /** * @inner */ function createSeriesIndices(seriesModels) { return map(seriesModels, function (series) { return series.componentIndex; }) || []; } /** * @inner */ function filterBySubType(components, condition) { // Using hasOwnProperty for restrict. Consider // subType is undefined in user payload. return condition.hasOwnProperty('subType') ? filter(components, function (cpt) { return cpt.subType === condition.subType; }) : components; } /** * @inner */ function assertSeriesInitialized(ecModel) { // Components that use _seriesIndices should depends on series component, // which make sure that their initialization is after series. if (true) { if (!ecModel._seriesIndices) { throw new Error('Option should contains series.'); } } } zrUtil.mixin(GlobalModel, __webpack_require__(77)); module.exports = GlobalModel; /***/ }), /* 4 */ /***/ (function(module, exports) { /** * @module zrender/core/util */ // 用于处理merge时无法遍历Date等对象的问题 var BUILTIN_OBJECT = { '[object Function]': 1, '[object RegExp]': 1, '[object Date]': 1, '[object Error]': 1, '[object CanvasGradient]': 1, '[object CanvasPattern]': 1, // For node-canvas '[object Image]': 1, '[object Canvas]': 1 }; var TYPED_ARRAY = { '[object Int8Array]': 1, '[object Uint8Array]': 1, '[object Uint8ClampedArray]': 1, '[object Int16Array]': 1, '[object Uint16Array]': 1, '[object Int32Array]': 1, '[object Uint32Array]': 1, '[object Float32Array]': 1, '[object Float64Array]': 1 }; var objToString = Object.prototype.toString; var arrayProto = Array.prototype; var nativeForEach = arrayProto.forEach; var nativeFilter = arrayProto.filter; var nativeSlice = arrayProto.slice; var nativeMap = arrayProto.map; var nativeReduce = arrayProto.reduce; /** * Those data types can be cloned: * Plain object, Array, TypedArray, number, string, null, undefined. * Those data types will be assgined using the orginal data: * BUILTIN_OBJECT * Instance of user defined class will be cloned to a plain object, without * properties in prototype. * Other data types is not supported (not sure what will happen). * * Caution: do not support clone Date, for performance consideration. * (There might be a large number of date in `series.data`). * So date should not be modified in and out of echarts. * * @param {*} source * @return {*} new */ function clone(source) { if (source == null || typeof source != 'object') { return source; } var result = source; var typeStr = objToString.call(source); if (typeStr === '[object Array]') { result = []; for (var i = 0, len = source.length; i < len; i++) { result[i] = clone(source[i]); } } else if (TYPED_ARRAY[typeStr]) { var Ctor = source.constructor; if (source.constructor.from) { result = Ctor.from(source); } else { result = new Ctor(source.length); for (var i = 0, len = source.length; i < len; i++) { result[i] = clone(source[i]); } } } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) { result = {}; for (var key in source) { if (source.hasOwnProperty(key)) { result[key] = clone(source[key]); } } } return result; } /** * @memberOf module:zrender/core/util * @param {*} target * @param {*} source * @param {boolean} [overwrite=false] */ function merge(target, source, overwrite) { // We should escapse that source is string // and enter for ... in ... if (!isObject(source) || !isObject(target)) { return overwrite ? clone(source) : target; } for (var key in source) { if (source.hasOwnProperty(key)) { var targetProp = target[key]; var sourceProp = source[key]; if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp) ) { // 如果需要递归覆盖，就递归调用merge merge(targetProp, sourceProp, overwrite); } else if (overwrite || !(key in target)) { // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况 // NOTE，在 target[key] 不存在的时候也是直接覆盖 target[key] = clone(source[key], true); } } } return target; } /** * @param {Array} targetAndSources The first item is target, and the rests are source. * @param {boolean} [overwrite=false] * @return {*} target */ function mergeAll(targetAndSources, overwrite) { var result = targetAndSources[0]; for (var i = 1, len = targetAndSources.length; i < len; i++) { result = merge(result, targetAndSources[i], overwrite); } return result; } /** * @param {*} target * @param {*} source * @memberOf module:zrender/core/util */ function extend(target, source) { for (var key in source) { if (source.hasOwnProperty(key)) { target[key] = source[key]; } } return target; } /** * @param {*} target * @param {*} source * @param {boolean} [overlay=false] * @memberOf module:zrender/core/util */ function defaults(target, source, overlay) { for (var key in source) { if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null) ) { target[key] = source[key]; } } return target; } function createCanvas() { return document.createElement('canvas'); } // FIXME var _ctx; function getContext() { if (!_ctx) { // Use util.createCanvas instead of createCanvas // because createCanvas may be overwritten in different environment _ctx = util.createCanvas().getContext('2d'); } return _ctx; } /** * 查询数组中元素的index * @memberOf module:zrender/core/util */ function indexOf(array, value) { if (array) { if (array.indexOf) { return array.indexOf(value); } for (var i = 0, len = array.length; i < len; i++) { if (array[i] === value) { return i; } } } return -1; } /** * 构造类继承关系 * * @memberOf module:zrender/core/util * @param {Function} clazz 源类 * @param {Function} baseClazz 基类 */ function inherits(clazz, baseClazz) { var clazzPrototype = clazz.prototype; function F() {} F.prototype = baseClazz.prototype; clazz.prototype = new F(); for (var prop in clazzPrototype) { clazz.prototype[prop] = clazzPrototype[prop]; } clazz.prototype.constructor = clazz; clazz.superClass = baseClazz; } /** * @memberOf module:zrender/core/util * @param {Object|Function} target * @param {Object|Function} sorce * @param {boolean} overlay */ function mixin(target, source, overlay) { target = 'prototype' in target ? target.prototype : target; source = 'prototype' in source ? source.prototype : source; defaults(target, source, overlay); } /** * Consider typed array. * @param {Array|TypedArray} data */ function isArrayLike(data) { if (! data) { return; } if (typeof data == 'string') { return false; } return typeof data.length == 'number'; } /** * 数组或对象遍历 * @memberOf module:zrender/core/util * @param {Object|Array} obj * @param {Function} cb * @param {*} [context] */ function each(obj, cb, context) { if (!(obj && cb)) { return; } if (obj.forEach && obj.forEach === nativeForEach) { obj.forEach(cb, context); } else if (obj.length === +obj.length) { for (var i = 0, len = obj.length; i < len; i++) { cb.call(context, obj[i], i, obj); } } else { for (var key in obj) { if (obj.hasOwnProperty(key)) { cb.call(context, obj[key], key, obj); } } } } /** * 数组映射 * @memberOf module:zrender/core/util * @param {Array} obj * @param {Function} cb * @param {*} [context] * @return {Array} */ function map(obj, cb, context) { if (!(obj && cb)) { return; } if (obj.map && obj.map === nativeMap) { return obj.map(cb, context); } else { var result = []; for (var i = 0, len = obj.length; i < len; i++) { result.push(cb.call(context, obj[i], i, obj)); } return result; } } /** * @memberOf module:zrender/core/util * @param {Array} obj * @param {Function} cb * @param {Object} [memo] * @param {*} [context] * @return {Array} */ function reduce(obj, cb, memo, context) { if (!(obj && cb)) { return; } if (obj.reduce && obj.reduce === nativeReduce) { return obj.reduce(cb, memo, context); } else { for (var i = 0, len = obj.length; i < len; i++) { memo = cb.call(context, memo, obj[i], i, obj); } return memo; } } /** * 数组过滤 * @memberOf module:zrender/core/util * @param {Array} obj * @param {Function} cb * @param {*} [context] * @return {Array} */ function filter(obj, cb, context) { if (!(obj && cb)) { return; } if (obj.filter && obj.filter === nativeFilter) { return obj.filter(cb, context); } else { var result = []; for (var i = 0, len = obj.length; i < len; i++) { if (cb.call(context, obj[i], i, obj)) { result.push(obj[i]); } } return result; } } /** * 数组项查找 * @memberOf module:zrender/core/util * @param {Array} obj * @param {Function} cb * @param {*} [context] * @return {Array} */ function find(obj, cb, context) { if (!(obj && cb)) { return; } for (var i = 0, len = obj.length; i < len; i++) { if (cb.call(context, obj[i], i, obj)) { return obj[i]; } } } /** * @memberOf module:zrender/core/util * @param {Function} func * @param {*} context * @return {Function} */ function bind(func, context) { var args = nativeSlice.call(arguments, 2); return function () { return func.apply(context, args.concat(nativeSlice.call(arguments))); }; } /** * @memberOf module:zrender/core/util * @param {Function} func * @return {Function} */ function curry(func) { var args = nativeSlice.call(arguments, 1); return function () { return func.apply(this, args.concat(nativeSlice.call(arguments))); }; } /** * @memberOf module:zrender/core/util * @param {*} value * @return {boolean} */ function isArray(value) { return objToString.call(value) === '[object Array]'; } /** * @memberOf module:zrender/core/util * @param {*} value * @return {boolean} */ function isFunction(value) { return typeof value === 'function'; } /** * @memberOf module:zrender/core/util * @param {*} value * @return {boolean} */ function isString(value) { return objToString.call(value) === '[object String]'; } /** * @memberOf module:zrender/core/util * @param {*} value * @return {boolean} */ function isObject(value) { // Avoid a V8 JIT bug in Chrome 19-20. // See https://code.google.com/p/v8/issues/detail?id=2291 for more details. var type = typeof value; return type === 'function' || (!!value && type == 'object'); } /** * @memberOf module:zrender/core/util * @param {*} value * @return {boolean} */ function isBuiltInObject(value) { return !!BUILTIN_OBJECT[objToString.call(value)]; } /** * @memberOf module:zrender/core/util * @param {*} value * @return {boolean} */ function isDom(value) { return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object'; } /** * Whether is exactly NaN. Notice isNaN('a') returns true. * @param {*} value * @return {boolean} */ function eqNaN(value) { return value !== value; } /** * If value1 is not null, then return value1, otherwise judget rest of values. * Low performance. * @memberOf module:zrender/core/util * @return {*} Final value */ function retrieve(values) { for (var i = 0, len = arguments.length; i < len; i++) { if (arguments[i] != null) { return arguments[i]; } } } function retrieve2(value0, value1) { return value0 != null ? value0 : value1; } function retrieve3(value0, value1, value2) { return value0 != null ? value0 : value1 != null ? value1 : value2; } /** * @memberOf module:zrender/core/util * @param {Array} arr * @param {number} startIndex * @param {number} endIndex * @return {Array} */ function slice() { return Function.call.apply(nativeSlice, arguments); } /** * Normalize css liked array configuration * e.g. * 3 => [3, 3, 3, 3] * [4, 2] => [4, 2, 4, 2] * [4, 3, 2] => [4, 3, 2, 3] * @param {number|Array.} val * @return {Array.} */ function normalizeCssArray(val) { if (typeof (val) === 'number') { return [val, val, val, val]; } var len = val.length; if (len === 2) { // vertical | horizontal return [val[0], val[1], val[0], val[1]]; } else if (len === 3) { // top | horizontal | bottom return [val[0], val[1], val[2], val[1]]; } return val; } /** * @memberOf module:zrender/core/util * @param {boolean} condition * @param {string} message */ function assert(condition, message) { if (!condition) { throw new Error(message); } } var primitiveKey = '__ec_primitive__'; /** * Set an object as primitive to be ignored traversing children in clone or merge */ function setAsPrimitive(obj) { obj[primitiveKey] = true; } function isPrimitive(obj) { return obj[primitiveKey]; } /** * @constructor * @param {Object} obj Only apply `ownProperty`. */ function HashMap(obj) { obj && each(obj, function (value, key) { this.set(key, value); }, this); } // Add prefix to avoid conflict with Object.prototype. var HASH_MAP_PREFIX = '_ec_'; var HASH_MAP_PREFIX_LENGTH = 4; HashMap.prototype = { constructor: HashMap, // Do not provide `has` method to avoid defining what is `has`. // (We usually treat `null` and `undefined` as the same, different // from ES6 Map). get: function (key) { return this[HASH_MAP_PREFIX + key]; }, set: function (key, value) { this[HASH_MAP_PREFIX + key] = value; // Comparing with invocation chaining, `return value` is more commonly // used in this case: `var someVal = map.set('a', genVal());` return value; }, // Although util.each can be performed on this hashMap directly, user // should not use the exposed keys, who are prefixed. each: function (cb, context) { context !== void 0 && (cb = bind(cb, context)); for (var prefixedKey in this) { this.hasOwnProperty(prefixedKey) && cb(this[prefixedKey], prefixedKey.slice(HASH_MAP_PREFIX_LENGTH)); } }, // Do not use this method if performance sensitive. removeKey: function (key) { delete this[HASH_MAP_PREFIX + key]; } }; function createHashMap(obj) { return new HashMap(obj); } var util = { inherits: inherits, mixin: mixin, clone: clone, merge: merge, mergeAll: mergeAll, extend: extend, defaults: defaults, getContext: getContext, createCanvas: createCanvas, indexOf: indexOf, slice: slice, find: find, isArrayLike: isArrayLike, each: each, map: map, reduce: reduce, filter: filter, bind: bind, curry: curry, isArray: isArray, isString: isString, isObject: isObject, isFunction: isFunction, isBuiltInObject: isBuiltInObject, isDom: isDom, eqNaN: eqNaN, retrieve: retrieve, retrieve2: retrieve2, retrieve3: retrieve3, assert: assert, setAsPrimitive: setAsPrimitive, createHashMap: createHashMap, normalizeCssArray: normalizeCssArray, noop: function () {} }; module.exports = util; /***/ }), /* 5 */ /***/ (function(module, exports, __webpack_require__) { var formatUtil = __webpack_require__(6); var nubmerUtil = __webpack_require__(7); var Model = __webpack_require__(14); var zrUtil = __webpack_require__(4); var each = zrUtil.each; var isObject = zrUtil.isObject; var modelUtil = {}; /** * If value is not array, then translate it to array. * @param {*} value * @return {Array} [value] or value */ modelUtil.normalizeToArray = function (value) { return value instanceof Array ? value : value == null ? [] : [value]; }; /** * Sync default option between normal and emphasis like `position` and `show` * In case some one will write code like * label: { * normal: { * show: false, * position: 'outside', * fontSize: 18 * }, * emphasis: { * show: true * } * } * @param {Object} opt * @param {Array.} subOpts */ modelUtil.defaultEmphasis = function (opt, subOpts) { if (opt) { var emphasisOpt = opt.emphasis = opt.emphasis || {}; var normalOpt = opt.normal = opt.normal || {}; // Default emphasis option from normal for (var i = 0, len = subOpts.length; i < len; i++) { var subOptName = subOpts[i]; if (!emphasisOpt.hasOwnProperty(subOptName) && normalOpt.hasOwnProperty(subOptName) ) { emphasisOpt[subOptName] = normalOpt[subOptName]; } } } }; modelUtil.TEXT_STYLE_OPTIONS = [ 'fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding' ]; // modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([ // 'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter', // 'fontStyle', 'fontWeight', 'fontSize', 'fontFamily', // // FIXME: deprecated, check and remove it. // 'textStyle' // ]); /** * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}] * This helper method retieves value from data. * @param {string|number|Date|Array|Object} dataItem * @return {number|string|Date|Array.} */ modelUtil.getDataItemValue = function (dataItem) { // Performance sensitive. return dataItem && (dataItem.value == null ? dataItem : dataItem.value); }; /** * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}] * This helper method determine if dataItem has extra option besides value * @param {string|number|Date|Array|Object} dataItem */ modelUtil.isDataItemOption = function (dataItem) { return isObject(dataItem) && !(dataItem instanceof Array); // // markLine data can be array // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array)); }; /** * This helper method convert value in data. * @param {string|number|Date} value * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'. */ modelUtil.converDataValue = function (value, dimInfo) { // Performance sensitive. var dimType = dimInfo && dimInfo.type; if (dimType === 'ordinal') { return value; } if (dimType === 'time' // spead up when using timestamp && typeof value !== 'number' && value != null && value !== '-' ) { value = +nubmerUtil.parseDate(value); } // dimType defaults 'number'. // If dimType is not ordinal and value is null or undefined or NaN or '-', // parse to NaN. return (value == null || value === '') ? NaN : +value; // If string (like '-'), using '+' parse to NaN }; /** * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data. * @param {module:echarts/data/List} data * @param {Object} opt * @param {string} [opt.seriesIndex] * @param {Object} [opt.name] * @param {Object} [opt.mainType] * @param {Object} [opt.subType] */ modelUtil.createDataFormatModel = function (data, opt) { var model = new Model(); zrUtil.mixin(model, modelUtil.dataFormatMixin); model.seriesIndex = opt.seriesIndex; model.name = opt.name || ''; model.mainType = opt.mainType; model.subType = opt.subType; model.getData = function () { return data; }; return model; }; // PENDING A little ugly modelUtil.dataFormatMixin = { /** * Get params for formatter * @param {number} dataIndex * @param {string} [dataType] * @return {Object} */ getDataParams: function (dataIndex, dataType) { var data = this.getData(dataType); var rawValue = this.getRawValue(dataIndex, dataType); var rawDataIndex = data.getRawIndex(dataIndex); var name = data.getName(dataIndex, true); var itemOpt = data.getRawDataItem(dataIndex); var color = data.getItemVisual(dataIndex, 'color'); return { componentType: this.mainType, componentSubType: this.subType, seriesType: this.mainType === 'series' ? this.subType : null, seriesIndex: this.seriesIndex, seriesId: this.id, seriesName: this.name, name: name, dataIndex: rawDataIndex, data: itemOpt, dataType: dataType, value: rawValue, color: color, marker: formatUtil.getTooltipMarker(color), // Param name list for mapping `a`, `b`, `c`, `d`, `e` $vars: ['seriesName', 'name', 'value'] }; }, /** * Format label * @param {number} dataIndex * @param {string} [status='normal'] 'normal' or 'emphasis' * @param {string} [dataType] * @param {number} [dimIndex] * @param {string} [labelProp='label'] * @return {string} */ getFormattedLabel: function (dataIndex, status, dataType, dimIndex, labelProp) { status = status || 'normal'; var data = this.getData(dataType); var itemModel = data.getItemModel(dataIndex); var params = this.getDataParams(dataIndex, dataType); if (dimIndex != null && (params.value instanceof Array)) { params.value = params.value[dimIndex]; } var formatter = itemModel.get([labelProp || 'label', status, 'formatter']); if (typeof formatter === 'function') { params.status = status; return formatter(params); } else if (typeof formatter === 'string') { return formatUtil.formatTpl(formatter, params); } }, /** * Get raw value in option * @param {number} idx * @param {string} [dataType] * @return {Object} */ getRawValue: function (idx, dataType) { var data = this.getData(dataType); var dataItem = data.getRawDataItem(idx); if (dataItem != null) { return (isObject(dataItem) && !(dataItem instanceof Array)) ? dataItem.value : dataItem; } }, /** * Should be implemented. * @param {number} dataIndex * @param {boolean} [multipleSeries=false] * @param {number} [dataType] * @return {string} tooltip string */ formatTooltip: zrUtil.noop }; /** * Mapping to exists for merge. * * @public * @param {Array.|Array.} exists * @param {Object|Array.} newCptOptions * @return {Array.} Result, like [{exist: ..., option: ...}, {}], * index of which is the same as exists. */ modelUtil.mappingToExists = function (exists, newCptOptions) { // Mapping by the order by original option (but not order of // new option) in merge mode. Because we should ensure // some specified index (like xAxisIndex) is consistent with // original option, which is easy to understand, espatially in // media query. And in most case, merge option is used to // update partial option but not be expected to change order. newCptOptions = (newCptOptions || []).slice(); var result = zrUtil.map(exists || [], function (obj, index) { return {exist: obj}; }); // Mapping by id or name if specified. each(newCptOptions, function (cptOption, index) { if (!isObject(cptOption)) { return; } // id has highest priority. for (var i = 0; i < result.length; i++) { if (!result[i].option // Consider name: two map to one. && cptOption.id != null && result[i].exist.id === cptOption.id + '' ) { result[i].option = cptOption; newCptOptions[index] = null; return; } } for (var i = 0; i < result.length; i++) { var exist = result[i].exist; if (!result[i].option // Consider name: two map to one. // Can not match when both ids exist but different. && (exist.id == null || cptOption.id == null) && cptOption.name != null && !modelUtil.isIdInner(cptOption) && !modelUtil.isIdInner(exist) && exist.name === cptOption.name + '' ) { result[i].option = cptOption; newCptOptions[index] = null; return; } } }); // Otherwise mapping by index. each(newCptOptions, function (cptOption, index) { if (!isObject(cptOption)) { return; } var i = 0; for (; i < result.length; i++) { var exist = result[i].exist; if (!result[i].option // Existing model that already has id should be able to // mapped to (because after mapping performed model may // be assigned with a id, whish should not affect next // mapping), except those has inner id. && !modelUtil.isIdInner(exist) // Caution: // Do not overwrite id. But name can be overwritten, // because axis use name as 'show label text'. // 'exist' always has id and name and we dont // need to check it. && cptOption.id == null ) { result[i].option = cptOption; break; } } if (i >= result.length) { result.push({option: cptOption}); } }); return result; }; /** * Make id and name for mapping result (result of mappingToExists) * into `keyInfo` field. * * @public * @param {Array.} Result, like [{exist: ..., option: ...}, {}], * which order is the same as exists. * @return {Array.} The input. */ modelUtil.makeIdAndName = function (mapResult) { // We use this id to hash component models and view instances // in echarts. id can be specified by user, or auto generated. // The id generation rule ensures new view instance are able // to mapped to old instance when setOption are called in // no-merge mode. So we generate model id by name and plus // type in view id. // name can be duplicated among components, which is convenient // to specify multi components (like series) by one name. // Ensure that each id is distinct. var idMap = zrUtil.createHashMap(); each(mapResult, function (item, index) { var existCpt = item.exist; existCpt && idMap.set(existCpt.id, item); }); each(mapResult, function (item, index) { var opt = item.option; zrUtil.assert( !opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, 'id duplicates: ' + (opt && opt.id) ); opt && opt.id != null && idMap.set(opt.id, item); !item.keyInfo && (item.keyInfo = {}); }); // Make name and id. each(mapResult, function (item, index) { var existCpt = item.exist; var opt = item.option; var keyInfo = item.keyInfo; if (!isObject(opt)) { return; } // name can be overwitten. Consider case: axis.name = '20km'. // But id generated by name will not be changed, which affect // only in that case: setOption with 'not merge mode' and view // instance will be recreated, which can be accepted. keyInfo.name = opt.name != null ? opt.name + '' : existCpt ? existCpt.name : '\\0-'; // name may be displayed on screen, so use '-'. if (existCpt) { keyInfo.id = existCpt.id; } else if (opt.id != null) { keyInfo.id = opt.id + ''; } else { // Consider this situatoin: // optionA: [{name: 'a'}, {name: 'a'}, {..}] // optionB [{..}, {name: 'a'}, {name: 'a'}] // Series with the same name between optionA and optionB // should be mapped. var idNum = 0; do { keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++; } while (idMap.get(keyInfo.id)); } idMap.set(keyInfo.id, item); }); }; /** * @public * @param {Object} cptOption * @return {boolean} */ modelUtil.isIdInner = function (cptOption) { return isObject(cptOption) && cptOption.id && (cptOption.id + '').indexOf('\\0_ec_\\0') === 0; }; /** * A helper for removing duplicate items between batchA and batchB, * and in themselves, and categorize by series. * * @param {Array.} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...] * @param {Array.} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...] * @return {Array.} result: [resultBatchA, resultBatchB] */ modelUtil.compressBatches = function (batchA, batchB) { var mapA = {}; var mapB = {}; makeMap(batchA || [], mapA); makeMap(batchB || [], mapB, mapA); return [mapToArray(mapA), mapToArray(mapB)]; function makeMap(sourceBatch, map, otherMap) { for (var i = 0, len = sourceBatch.length; i < len; i++) { var seriesId = sourceBatch[i].seriesId; var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex); var otherDataIndices = otherMap && otherMap[seriesId]; for (var j = 0, lenj = dataIndices.length; j < lenj; j++) { var dataIndex = dataIndices[j]; if (otherDataIndices && otherDataIndices[dataIndex]) { otherDataIndices[dataIndex] = null; } else { (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1; } } } } function mapToArray(map, isData) { var result = []; for (var i in map) { if (map.hasOwnProperty(i) && map[i] != null) { if (isData) { result.push(+i); } else { var dataIndices = mapToArray(map[i], true); dataIndices.length && result.push({seriesId: i, dataIndex: dataIndices}); } } } return result; } }; /** * @param {module:echarts/data/List} data * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name * each of which can be Array or primary type. * @return {number|Array.} dataIndex If not found, return undefined/null. */ modelUtil.queryDataIndex = function (data, payload) { if (payload.dataIndexInside != null) { return payload.dataIndexInside; } else if (payload.dataIndex != null) { return zrUtil.isArray(payload.dataIndex) ? zrUtil.map(payload.dataIndex, function (value) { return data.indexOfRawIndex(value); }) : data.indexOfRawIndex(payload.dataIndex); } else if (payload.name != null) { return zrUtil.isArray(payload.name) ? zrUtil.map(payload.name, function (value) { return data.indexOfName(value); }) : data.indexOfName(payload.name); } }; /** * Enable property storage to any host object. * Notice: Serialization is not supported. * * For example: * var get = modelUitl.makeGetter(); * * function some(hostObj) { * get(hostObj)._someProperty = 1212; * ... * } * * @return {Function} */ modelUtil.makeGetter = (function () { var index = 0; return function () { var key = '\\0__ec_prop_getter_' + index++; return function (hostObj) { return hostObj[key] || (hostObj[key] = {}); }; }; })(); /** * @param {module:echarts/model/Global} ecModel * @param {string|Object} finder * If string, e.g., 'geo', means {geoIndex: 0}. * If Object, could contain some of these properties below: * { * seriesIndex, seriesId, seriesName, * geoIndex, geoId, geoName, * bmapIndex, bmapId, bmapName, * xAxisIndex, xAxisId, xAxisName, * yAxisIndex, yAxisId, yAxisName, * gridIndex, gridId, gridName, * ... (can be extended) * } * Each properties can be number|string|Array.|Array. * For example, a finder could be * { * seriesIndex: 3, * geoId: ['aa', 'cc'], * gridName: ['xx', 'rr'] * } * xxxIndex can be set as 'all' (means all xxx) or 'none' (means not specify) * If nothing or null/undefined specified, return nothing. * @param {Object} [opt] * @param {string} [opt.defaultMainType] * @param {Array.} [opt.includeMainTypes] * @return {Object} result like: * { * seriesModels: [seriesModel1, seriesModel2], * seriesModel: seriesModel1, // The first model * geoModels: [geoModel1, geoModel2], * geoModel: geoModel1, // The first model * ... * } */ modelUtil.parseFinder = function (ecModel, finder, opt) { if (zrUtil.isString(finder)) { var obj = {}; obj[finder + 'Index'] = 0; finder = obj; } var defaultMainType = opt && opt.defaultMainType; if (defaultMainType && !has(finder, defaultMainType + 'Index') && !has(finder, defaultMainType + 'Id') && !has(finder, defaultMainType + 'Name') ) { finder[defaultMainType + 'Index'] = 0; } var result = {}; each(finder, function (value, key) { var value = finder[key]; // Exclude 'dataIndex' and other illgal keys. if (key === 'dataIndex' || key === 'dataIndexInside') { result[key] = value; return; } var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || []; var mainType = parsedKey[1]; var queryType = (parsedKey[2] || '').toLowerCase(); if (!mainType || !queryType || value == null || (queryType === 'index' && value === 'none') || (opt && opt.includeMainTypes && zrUtil.indexOf(opt.includeMainTypes, mainType) < 0) ) { return; } var queryParam = {mainType: mainType}; if (queryType !== 'index' || value !== 'all') { queryParam[queryType] = value; } var models = ecModel.queryComponents(queryParam); result[mainType + 'Models'] = models; result[mainType + 'Model'] = models[0]; }); return result; }; /** * @see {module:echarts/data/helper/completeDimensions} * @param {module:echarts/data/List} data * @param {string|number} dataDim * @return {string} */ modelUtil.dataDimToCoordDim = function (data, dataDim) { var dimensions = data.dimensions; dataDim = data.getDimension(dataDim); for (var i = 0; i < dimensions.length; i++) { var dimItem = data.getDimensionInfo(dimensions[i]); if (dimItem.name === dataDim) { return dimItem.coordDim; } } }; /** * @see {module:echarts/data/helper/completeDimensions} * @param {module:echarts/data/List} data * @param {string} coordDim * @return {Array.} data dimensions on the coordDim. */ modelUtil.coordDimToDataDim = function (data, coordDim) { var dataDim = []; each(data.dimensions, function (dimName) { var dimItem = data.getDimensionInfo(dimName); if (dimItem.coordDim === coordDim) { dataDim[dimItem.coordDimIndex] = dimItem.name; } }); return dataDim; }; /** * @see {module:echarts/data/helper/completeDimensions} * @param {module:echarts/data/List} data * @param {string} otherDim Can be `otherDims` * like 'label' or 'tooltip'. * @return {Array.} data dimensions on the otherDim. */ modelUtil.otherDimToDataDim = function (data, otherDim) { var dataDim = []; each(data.dimensions, function (dimName) { var dimItem = data.getDimensionInfo(dimName); var otherDims = dimItem.otherDims; var dimIndex = otherDims[otherDim]; if (dimIndex != null && dimIndex !== false) { dataDim[dimIndex] = dimItem.name; } }); return dataDim; }; function has(obj, prop) { return obj && obj.hasOwnProperty(prop); } module.exports = modelUtil; /***/ }), /* 6 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); var numberUtil = __webpack_require__(7); var textContain = __webpack_require__(8); var formatUtil = {}; /** * 每三位默认加,格式化 * @param {string|number} x * @return {string} */ formatUtil.addCommas = function (x) { if (isNaN(x)) { return '-'; } x = (x + '').split('.'); return x[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g,'$1,') + (x.length > 1 ? ('.' + x[1]) : ''); }; /** * @param {string} str * @param {boolean} [upperCaseFirst=false] * @return {string} str */ formatUtil.toCamelCase = function (str, upperCaseFirst) { str = (str || '').toLowerCase().replace(/-(.)/g, function(match, group1) { return group1.toUpperCase(); }); if (upperCaseFirst && str) { str = str.charAt(0).toUpperCase() + str.slice(1); } return str; }; formatUtil.normalizeCssArray = zrUtil.normalizeCssArray; var encodeHTML = formatUtil.encodeHTML = function (source) { return String(source) .replace(/&/g, '&amp;') .replace(//g, '&gt;') .replace(/\"/g, '&quot;') .replace(/'/g, '&#39;'); }; var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g']; var wrapVar = function (varName, seriesIdx) { return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}'; }; /** * Template formatter * @param {string} tpl * @param {Array.|Object} paramsList * @param {boolean} [encode=false] * @return {string} */ formatUtil.formatTpl = function (tpl, paramsList, encode) { if (!zrUtil.isArray(paramsList)) { paramsList = [paramsList]; } var seriesLen = paramsList.length; if (!seriesLen) { return ''; } var $vars = paramsList[0].$vars || []; for (var i = 0; i < $vars.length; i++) { var alias = TPL_VAR_ALIAS[i]; var val = wrapVar(alias, 0); tpl = tpl.replace(wrapVar(alias), encode ? encodeHTML(val) : val); } for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) { for (var k = 0; k < $vars.length; k++) { var val = paramsList[seriesIdx][$vars[k]]; tpl = tpl.replace( wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode ? encodeHTML(val) : val ); } } return tpl; }; /** * simple Template formatter * * @param {string} tpl * @param {Object} param * @param {boolean} [encode=false] * @return {string} */ formatUtil.formatTplSimple = function (tpl, param, encode) { zrUtil.each(param, function (value, key) { tpl = tpl.replace( '{' + key + '}', encode ? encodeHTML(value) : value ); }); return tpl; }; /** * @param {string} color * @param {string} [extraCssText] * @return {string} */ formatUtil.getTooltipMarker = function (color, extraCssText) { return color ? '' : ''; }; /** * @param {string} str * @return {string} * @inner */ var s2d = function (str) { return str < 10 ? ('0' + str) : str; }; /** * ISO Date format * @param {string} tpl * @param {number} value * @param {boolean} [isUTC=false] Default in local time. * see `module:echarts/scale/Time` * and `module:echarts/util/number#parseDate`. * @inner */ formatUtil.formatTime = function (tpl, value, isUTC) { if (tpl === 'week' || tpl === 'month' || tpl === 'quarter' || tpl === 'half-year' || tpl === 'year' ) { tpl = 'MM-dd\\nyyyy'; } var date = numberUtil.parseDate(value); var utc = isUTC ? 'UTC' : ''; var y = date['get' + utc + 'FullYear'](); var M = date['get' + utc + 'Month']() + 1; var d = date['get' + utc + 'Date'](); var h = date['get' + utc + 'Hours'](); var m = date['get' + utc + 'Minutes'](); var s = date['get' + utc + 'Seconds'](); tpl = tpl.replace('MM', s2d(M)) .replace('M', M) .replace('yyyy', y) .replace('yy', y % 100) .replace('dd', s2d(d)) .replace('d', d) .replace('hh', s2d(h)) .replace('h', h) .replace('mm', s2d(m)) .replace('m', m) .replace('ss', s2d(s)) .replace('s', s); return tpl; }; /** * Capital first * @param {string} str * @return {string} */ formatUtil.capitalFirst = function (str) { return str ? str.charAt(0).toUpperCase() + str.substr(1) : str; }; formatUtil.truncateText = textContain.truncateText; formatUtil.getTextRect = textContain.getBoundingRect; module.exports = formatUtil; /***/ }), /* 7 */ /***/ (function(module, exports, __webpack_require__) { /** * 数值处理模块 * @module echarts/util/number */ var zrUtil = __webpack_require__(4); var number = {}; var RADIAN_EPSILON = 1e-4; function _trim(str) { return str.replace(/^\\s+/, '').replace(/\\s+$/, ''); } /** * Linear mapping a value from domain to range * @memberOf module:echarts/util/number * @param {(number|Array.)} val * @param {Array.} domain Domain extent domain[0] can be bigger than domain[1] * @param {Array.} range Range extent range[0] can be bigger than range[1] * @param {boolean} clamp * @return {(number|Array.} */ number.linearMap = function (val, domain, range, clamp) { var subDomain = domain[1] - domain[0]; var subRange = range[1] - range[0]; if (subDomain === 0) { return subRange === 0 ? range[0] : (range[0] + range[1]) / 2; } // Avoid accuracy problem in edge, such as // 146.39 - 62.83 === 83.55999999999999. // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError // It is a little verbose for efficiency considering this method // is a hotspot. if (clamp) { if (subDomain > 0) { if (val = domain[1]) { return range[1]; } } else { if (val >= domain[0]) { return range[0]; } else if (val 0) { var precision = +str.slice(eIndex + 1); return precision < 0 ? -precision : 0; } else { var dotIndex = str.indexOf('.'); return dotIndex < 0 ? 0 : str.length - 1 - dotIndex; } }; /** * Minimal dicernible data precisioin according to a single pixel. * * @param {Array.} dataExtent * @param {Array.} pixelExtent * @return {number} precision */ number.getPixelPrecision = function (dataExtent, pixelExtent) { var log = Math.log; var LN10 = Math.LN10; var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10); var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10); // toFixed() digits argument must be between 0 and 20. var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20); return !isFinite(precision) ? 20 : precision; }; /** * Get a data of given precision, assuring the sum of percentages * in valueList is 1. * The largest remainer method is used. * https://en.wikipedia.org/wiki/Largest_remainder_method * * @param {Array.} valueList a list of all data * @param {number} idx index of the data to be processed in valueList * @param {number} precision integer number showing digits of precision * @return {number} percent ranging from 0 to 100 */ number.getPercentWithPrecision = function (valueList, idx, precision) { if (!valueList[idx]) { return 0; } var sum = zrUtil.reduce(valueList, function (acc, val) { return acc + (isNaN(val) ? 0 : val); }, 0); if (sum === 0) { return 0; } var digits = Math.pow(10, precision); var votesPerQuota = zrUtil.map(valueList, function (val) { return (isNaN(val) ? 0 : val) / sum * digits * 100; }); var targetSeats = digits * 100; var seats = zrUtil.map(votesPerQuota, function (votes) { // Assign automatic seats. return Math.floor(votes); }); var currentSum = zrUtil.reduce(seats, function (acc, val) { return acc + val; }, 0); var remainder = zrUtil.map(votesPerQuota, function (votes, idx) { return votes - seats[idx]; }); // Has remainding votes. while (currentSum < targetSeats) { // Find next largest remainder. var max = Number.NEGATIVE_INFINITY; var maxId = null; for (var i = 0, len = remainder.length; i < len; ++i) { if (remainder[i] > max) { max = remainder[i]; maxId = i; } } // Add a vote to max remainder. ++seats[maxId]; remainder[maxId] = 0; ++currentSum; } return seats[idx] / digits; }; // Number.MAX_SAFE_INTEGER, ie do not support. number.MAX_SAFE_INTEGER = 9007199254740991; /** * To 0 - 2 * PI, considering negative radian. * @param {number} radian * @return {number} */ number.remRadian = function (radian) { var pi2 = Math.PI * 2; return (radian % pi2 + pi2) % pi2; }; /** * @param {type} radian * @return {boolean} */ number.isRadianAroundZero = function (val) { return val > -RADIAN_EPSILON && val < RADIAN_EPSILON; }; var TIME_REG = /^(?:(\\d{4})(?:[-\\/](\\d{1,2})(?:[-\\/](\\d{1,2})(?:[T ](\\d{1,2})(?::(\\d\\d)(?::(\\d\\d)(?:[.,](\\d+))?)?)?(Z|[\\+\\-]\\d\\d:?\\d\\d)?)?)?)?)?$/; // jshint ignore:line /** * Consider DST, it is incorrect to provide a method `getTimezoneOffset` * without time specified. So this method is removed. * * @return {number} in minutes */ // number.getTimezoneOffset = function () { // return (new Date()).getTimezoneOffset(); // }; /** * @param {string|Date|number} value These values can be accepted: * + An instance of Date, represent a time in its own time zone. * + Or string in a subset of ISO 8601, only including: * + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06', * + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123', * + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00', * all of which will be treated as local time if time zone is not specified * (see ). * + Or other string format, including (all of which will be treated as loacal time): * '2012', '2012-3-1', '2012/3/1', '2012/03/01', * '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123' * + a timestamp, which represent a time in UTC. * @return {Date} date */ number.parseDate = function (value) { if (value instanceof Date) { return value; } else if (typeof value === 'string') { // Different browsers parse date in different way, so we parse it manually. // Some other issues: // new Date('1970-01-01') is UTC, // new Date('1970/01/01') and new Date('1970-1-01') is local. // See issue #3623 var match = TIME_REG.exec(value); if (!match) { // return Invalid Date. return new Date(NaN); } // Use local time when no timezone offset specifed. if (!match[8]) { // match[n] can only be string or undefined. // But take care of '12' + 1 => '121'. return new Date( +match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, +match[7] || 0 ); } // Timezoneoffset of Javascript Date has considered DST (Daylight Saving Time, // https://tc39.github.io/ecma262/#sec-daylight-saving-time-adjustment). // For example, system timezone is set as \"Time Zone: America/Toronto\", // then these code will get different result: // `new Date(1478411999999).getTimezoneOffset(); // get 240` // `new Date(1478412000000).getTimezoneOffset(); // get 300` // So we should not use `new Date`, but use `Date.UTC`. else { var hour = +match[4] || 0; if (match[8].toUpperCase() !== 'Z') { hour -= match[8].slice(0, 3); } return new Date(Date.UTC( +match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, +match[7] || 0 )); } } else if (value == null) { return new Date(NaN); } return new Date(Math.round(value)); }; /** * Quantity of a number. e.g. 0.1, 1, 10, 100 * * @param {number} val * @return {number} */ number.quantity = function (val) { return Math.pow(10, quantityExponent(val)); }; function quantityExponent(val) { return Math.floor(Math.log(val) / Math.LN10); } /** * find a “nice” number approximately equal to x. Round the number if round = true, * take ceiling if round = false. The primary observation is that the “nicest” * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers. * * See \"Nice Numbers for Graph Labels\" of Graphic Gems. * * @param {number} val Non-negative value. * @param {boolean} round * @return {number} */ number.nice = function (val, round) { var exponent = quantityExponent(val); var exp10 = Math.pow(10, exponent); var f = val / exp10; // 1 = ascCharWidth; i++) { contentWidth -= ascCharWidth; } var ellipsisWidth = getTextWidth(ellipsis); if (ellipsisWidth > contentWidth) { ellipsis = ''; ellipsisWidth = 0; } contentWidth = containerWidth - ellipsisWidth; options.ellipsis = ellipsis; options.ellipsisWidth = ellipsisWidth; options.contentWidth = contentWidth; options.containerWidth = containerWidth; return options; } function truncateSingleLine(textLine, options) { var containerWidth = options.containerWidth; var font = options.font; var contentWidth = options.contentWidth; if (!containerWidth) { return ''; } var lineWidth = getTextWidth(textLine, font); if (lineWidth 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0; textLine = textLine.substr(0, subLength); lineWidth = getTextWidth(textLine, font); } if (textLine === '') { textLine = options.placeholder; } return textLine; } function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) { var width = 0; var i = 0; for (var len = text.length; i < len && width < contentWidth; i++) { var charCode = text.charCodeAt(i); width += (0 lastIndex) { pushTokens(contentBlock, text.substring(lastIndex, matchedIndex)); } pushTokens(contentBlock, result[2], result[1]); lastIndex = STYLE_REG.lastIndex; } if (lastIndex < text.length) { pushTokens(contentBlock, text.substring(lastIndex, text.length)); } var lines = contentBlock.lines; var contentHeight = 0; var contentWidth = 0; // For `textWidth: 100%` var pendingList = []; var stlPadding = style.textPadding; var truncate = style.truncate; var truncateWidth = truncate && truncate.outerWidth; var truncateHeight = truncate && truncate.outerHeight; if (stlPadding) { truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]); truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]); } // Calculate layout info of tokens. for (var i = 0; i < lines.length; i++) { var line = lines[i]; var lineHeight = 0; var lineWidth = 0; for (var j = 0; j < line.tokens.length; j++) { var token = line.tokens[j]; var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style. var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`. var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token. var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified // as box height of the block. tokenStyle.textHeight, textContain.getLineHeight(font) ); textPadding && (tokenHeight += textPadding[0] + textPadding[2]); token.height = tokenHeight; token.lineHeight = retrieve3( tokenStyle.textLineHeight, style.textLineHeight, tokenHeight ); token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign; token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle'; if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) { return {lines: [], width: 0, height: 0}; } token.textWidth = textContain.getWidth(token.text, font); var tokenWidth = tokenStyle.textWidth; var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate // line when box width is needed to be auto. if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') { token.percentWidth = tokenWidth; pendingList.push(token); tokenWidth = 0; // Do not truncate in this case, because there is no user case // and it is too complicated. } else { if (tokenWidthNotSpecified) { tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling // `getBoundingRect()` will not get correct result. var textBackgroundColor = tokenStyle.textBackgroundColor; var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases: // (1) If image is not loaded, it will be loaded at render phase and call // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded // image, and then the right size will be calculated here at the next tick. // See `graphic/helper/text.js`. // (2) If image loaded, and `textBackgroundColor.image` is image src string, // use `imageHelper.findExistImage` to find cached image. // `imageHelper.findExistImage` will always be called here before // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText` // which ensures that image will not be rendered before correct size calcualted. if (bgImg) { bgImg = imageHelper.findExistImage(bgImg); if (imageHelper.isImageReady(bgImg)) { tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height); } } } var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0; tokenWidth += paddingW; var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null; if (remianTruncWidth != null && remianTruncWidth < tokenWidth) { if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) { token.text = ''; token.textWidth = tokenWidth = 0; } else { token.text = truncateText( token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {minChar: truncate.minChar} ); token.textWidth = textContain.getWidth(token.text, font); tokenWidth = token.textWidth + paddingW; } } } lineWidth += (token.width = tokenWidth); tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight)); } line.width = lineWidth; line.lineHeight = lineHeight; contentHeight += lineHeight; contentWidth = Math.max(contentWidth, lineWidth); } contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth); contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight); if (stlPadding) { contentBlock.outerWidth += stlPadding[1] + stlPadding[3]; contentBlock.outerHeight += stlPadding[0] + stlPadding[2]; } for (var i = 0; i < pendingList.length; i++) { var token = pendingList[i]; var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding. token.width = parseInt(percentWidth, 10) / 100 * contentWidth; } return contentBlock; } function pushTokens(block, str, styleName) { var isEmptyStr = str === ''; var strs = str.split('\\n'); var lines = block.lines; for (var i = 0; i < strs.length; i++) { var text = strs[i]; var token = { styleName: styleName, text: text, isLineHolder: !text && !isEmptyStr }; // The first token should be appended to the last line. if (!i) { var tokens = (lines[lines.length - 1] || (lines[0] = {tokens: []})).tokens; // Consider cases: // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item // (which is a placeholder) should be replaced by new token. // (2) A image backage, where token likes {a|}. // (3) A redundant '' will affect textAlign in line. // (4) tokens with the same tplName should not be merged, because // they should be displayed in different box (with border and padding). var tokensLen = tokens.length; (tokensLen === 1 && tokens[0].isLineHolder) ? (tokens[0] = token) // Consider text is '', only insert when it is the \"lineHolder\" or // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line. : ((text || !tokensLen || isEmptyStr) && tokens.push(token)); } // Other tokens always start a new line. else { // If there is '', insert it as a placeholder. lines.push({tokens: [token]}); } } } function makeFont(style) { // FIXME in node-canvas fontWeight is before fontStyle // Use `fontSize` `fontFamily` to check whether font properties are defined. return (style.fontSize || style.fontFamily) && [ style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored. style.fontFamily || 'sans-serif' ].join(' ') || style.textFont || style.font; } var textContain = { getWidth: getTextWidth, getBoundingRect: getTextRect, adjustTextPositionOnRect: adjustTextPositionOnRect, truncateText: truncateText, measureText: measureText, getLineHeight: getLineHeight, parsePlainText: parsePlainText, parseRichText: parseRichText, adjustTextX: adjustTextX, adjustTextY: adjustTextY, makeFont: makeFont, DEFAULT_FONT: DEFAULT_FONT }; module.exports = textContain; /***/ }), /* 9 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; /** * @module echarts/core/BoundingRect */ var vec2 = __webpack_require__(10); var matrix = __webpack_require__(11); var v2ApplyTransform = vec2.applyTransform; var mathMin = Math.min; var mathMax = Math.max; /** * @alias module:echarts/core/BoundingRect */ function BoundingRect(x, y, width, height) { if (width < 0) { x = x + width; width = -width; } if (height < 0) { y = y + height; height = -height; } /** * @type {number} */ this.x = x; /** * @type {number} */ this.y = y; /** * @type {number} */ this.width = width; /** * @type {number} */ this.height = height; } BoundingRect.prototype = { constructor: BoundingRect, /** * @param {module:echarts/core/BoundingRect} other */ union: function (other) { var x = mathMin(other.x, this.x); var y = mathMin(other.y, this.y); this.width = mathMax( other.x + other.width, this.x + this.width ) - x; this.height = mathMax( other.y + other.height, this.y + this.height ) - y; this.x = x; this.y = y; }, /** * @param {Array.} m * @methods */ applyTransform: (function () { var lt = []; var rb = []; var lb = []; var rt = []; return function (m) { // In case usage like this // el.getBoundingRect().applyTransform(el.transform) // And element has no transform if (!m) { return; } lt[0] = lb[0] = this.x; lt[1] = rt[1] = this.y; rb[0] = rt[0] = this.x + this.width; rb[1] = lb[1] = this.y + this.height; v2ApplyTransform(lt, lt, m); v2ApplyTransform(rb, rb, m); v2ApplyTransform(lb, lb, m); v2ApplyTransform(rt, rt, m); this.x = mathMin(lt[0], rb[0], lb[0], rt[0]); this.y = mathMin(lt[1], rb[1], lb[1], rt[1]); var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]); var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]); this.width = maxX - this.x; this.height = maxY - this.y; }; })(), /** * Calculate matrix of transforming from self to target rect * @param {module:zrender/core/BoundingRect} b * @return {Array.} */ calculateTransform: function (b) { var a = this; var sx = b.width / a.width; var sy = b.height / a.height; var m = matrix.create(); // 矩阵右乘 matrix.translate(m, m, [-a.x, -a.y]); matrix.scale(m, m, [sx, sy]); matrix.translate(m, m, [b.x, b.y]); return m; }, /** * @param {(module:echarts/core/BoundingRect|Object)} b * @return {boolean} */ intersect: function (b) { if (!b) { return false; } if (!(b instanceof BoundingRect)) { // Normalize negative width/height. b = BoundingRect.create(b); } var a = this; var ax0 = a.x; var ax1 = a.x + a.width; var ay0 = a.y; var ay1 = a.y + a.height; var bx0 = b.x; var bx1 = b.x + b.width; var by0 = b.y; var by1 = b.y + b.height; return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0); }, contain: function (x, y) { var rect = this; return x >= rect.x && x = rect.y && y = this._maxSize && len > 0) { // Remove the least recently used var leastUsedEntry = list.head; list.remove(leastUsedEntry); delete map[leastUsedEntry.key]; removed = leastUsedEntry.value; this._lastRemovedEntry = leastUsedEntry; } if (entry) { entry.value = value; } else { entry = new Entry(value); } entry.key = key; list.insertEntry(entry); map[key] = entry; } return removed; }; /** * @param {string} key * @return {} */ LRUProto.get = function (key) { var entry = this._map[key]; var list = this._list; if (entry != null) { // Put the latest used entry in the tail if (entry !== list.tail) { list.remove(entry); list.insertEntry(entry); } return entry.value; } }; /** * Clear the cache */ LRUProto.clear = function () { this._list.clear(); this._map = {}; }; module.exports = LRU; /***/ }), /* 14 */ /***/ (function(module, exports, __webpack_require__) { /** * @module echarts/model/Model */ var zrUtil = __webpack_require__(4); var clazzUtil = __webpack_require__(15); var env = __webpack_require__(2); /** * @alias module:echarts/model/Model * @constructor * @param {Object} option * @param {module:echarts/model/Model} [parentModel] * @param {module:echarts/model/Global} [ecModel] */ function Model(option, parentModel, ecModel) { /** * @type {module:echarts/model/Model} * @readOnly */ this.parentModel = parentModel; /** * @type {module:echarts/model/Global} * @readOnly */ this.ecModel = ecModel; /** * @type {Object} * @protected */ this.option = option; // Simple optimization // if (this.init) { // if (arguments.length = 0) || (includes && zrUtil.indexOf(includes, propName) < 0) ) { continue; } var val = this.getShallow(propName); if (val != null) { style[properties[i][0]] = val; } } return style; }; }; /***/ }), /* 18 */ /***/ (function(module, exports, __webpack_require__) { module.exports = { getAreaStyle: __webpack_require__(17)( [ ['fill', 'color'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['opacity'], ['shadowColor'] ] ) }; /***/ }), /* 19 */ /***/ (function(module, exports, __webpack_require__) { var textContain = __webpack_require__(8); var graphicUtil = __webpack_require__(20); var PATH_COLOR = ['textStyle', 'color']; module.exports = { /** * Get color property or get color from option.textStyle.color * @param {boolean} [isEmphasis] * @return {string} */ getTextColor: function (isEmphasis) { var ecModel = this.ecModel; return this.getShallow('color') || ( (!isEmphasis && ecModel) ? ecModel.get(PATH_COLOR) : null ); }, /** * Create font string from fontStyle, fontWeight, fontSize, fontFamily * @return {string} */ getFont: function () { return graphicUtil.getFont({ fontStyle: this.getShallow('fontStyle'), fontWeight: this.getShallow('fontWeight'), fontSize: this.getShallow('fontSize'), fontFamily: this.getShallow('fontFamily') }, this.ecModel); }, getTextRect: function (text) { return textContain.getBoundingRect( text, this.getFont(), this.getShallow('align'), this.getShallow('verticalAlign') || this.getShallow('baseline'), this.getShallow('padding'), this.getShallow('rich'), this.getShallow('truncateText') ); } }; /***/ }), /* 20 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var zrUtil = __webpack_require__(4); var pathTool = __webpack_require__(21); var Path = __webpack_require__(22); var colorTool = __webpack_require__(33); var matrix = __webpack_require__(11); var vector = __webpack_require__(10); var Transformable = __webpack_require__(28); var BoundingRect = __webpack_require__(9); var round = Math.round; var mathMax = Math.max; var mathMin = Math.min; var EMPTY_OBJ = {}; var graphic = {}; graphic.Group = __webpack_require__(51); graphic.Image = __webpack_require__(52); graphic.Text = __webpack_require__(53); graphic.Circle = __webpack_require__(54); graphic.Sector = __webpack_require__(55); graphic.Ring = __webpack_require__(57); graphic.Polygon = __webpack_require__(58); graphic.Polyline = __webpack_require__(62); graphic.Rect = __webpack_require__(63); graphic.Line = __webpack_require__(64); graphic.BezierCurve = __webpack_require__(65); graphic.Arc = __webpack_require__(66); graphic.CompoundPath = __webpack_require__(67); graphic.LinearGradient = __webpack_require__(68); graphic.RadialGradient = __webpack_require__(70); graphic.BoundingRect = BoundingRect; /** * Extend shape with parameters */ graphic.extendShape = function (opts) { return Path.extend(opts); }; /** * Extend path */ graphic.extendPath = function (pathData, opts) { return pathTool.extendFromString(pathData, opts); }; /** * Create a path element from path data string * @param {string} pathData * @param {Object} opts * @param {module:zrender/core/BoundingRect} rect * @param {string} [layout=cover] 'center' or 'cover' */ graphic.makePath = function (pathData, opts, rect, layout) { var path = pathTool.createFromString(pathData, opts); var boundingRect = path.getBoundingRect(); if (rect) { var aspect = boundingRect.width / boundingRect.height; if (layout === 'center') { // Set rect to center, keep width / height ratio. var width = rect.height * aspect; var height; if (width 1e-10) { rectWithStroke.width += w / lineScale; rectWithStroke.height += w / lineScale; rectWithStroke.x -= w / lineScale / 2; rectWithStroke.y -= w / lineScale / 2; } } // Return rect with stroke return rectWithStroke; } return rect; }, contain: function (x, y) { var localPos = this.transformCoordToLocal(x, y); var rect = this.getBoundingRect(); var style = this.style; x = localPos[0]; y = localPos[1]; if (rect.contain(x, y)) { var pathData = this.path.data; if (style.hasStroke()) { var lineWidth = style.lineWidth; var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0; if (lineScale > 1e-10) { // Only add extra hover lineWidth when there are no fill if (!style.hasFill()) { lineWidth = Math.max(lineWidth, this.strokeContainThreshold); } if (pathContain.containStroke( pathData, lineWidth / lineScale, x, y )) { return true; } } } if (style.hasFill()) { return pathContain.contain(pathData, x, y); } } return false; }, /** * @param {boolean} dirtyPath */ dirty: function (dirtyPath) { if (dirtyPath == null) { dirtyPath = true; } // Only mark dirty, not mark clean if (dirtyPath) { this.__dirtyPath = dirtyPath; this._rect = null; } this.__dirty = true; this.__zr && this.__zr.refresh(); // Used as a clipping path if (this.__clipTarget) { this.__clipTarget.dirty(); } }, /** * Alias for animate('shape') * @param {boolean} loop */ animateShape: function (loop) { return this.animate('shape', loop); }, // Overwrite attrKV attrKV: function (key, value) { // FIXME if (key === 'shape') { this.setShape(value); this.__dirtyPath = true; this._rect = null; } else { Displayable.prototype.attrKV.call(this, key, value); } }, /** * @param {Object|string} key * @param {*} value */ setShape: function (key, value) { var shape = this.shape; // Path from string may not have shape if (shape) { if (zrUtil.isObject(key)) { for (var name in key) { if (key.hasOwnProperty(name)) { shape[name] = key[name]; } } } else { shape[key] = value; } this.dirty(true); } return this; }, getLineScale: function () { var m = this.transform; // Get the line scale. // Determinant of `m` means how much the area is enlarged by the // transformation. So its square root can be used as a scale factor // for width. return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1; } }; /** * 扩展一个 Path element, 比如星形，圆等。 * Extend a path element * @param {Object} props * @param {string} props.type Path type * @param {Function} props.init Initialize * @param {Function} props.buildPath Overwrite buildPath method * @param {Object} [props.style] Extended default style config * @param {Object} [props.shape] Extended default shape config */ Path.extend = function (defaults) { var Sub = function (opts) { Path.call(this, opts); if (defaults.style) { // Extend default style this.style.extendFrom(defaults.style, false); } // Extend default shape var defaultShape = defaults.shape; if (defaultShape) { this.shape = this.shape || {}; var thisShape = this.shape; for (var name in defaultShape) { if ( ! thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name) ) { thisShape[name] = defaultShape[name]; } } } defaults.init && defaults.init.call(this, opts); }; zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象 for (var name in defaults) { // Extending prototype values and methods if (name !== 'style' && name !== 'shape') { Sub.prototype[name] = defaults[name]; } } return Sub; }; zrUtil.inherits(Path, Displayable); module.exports = Path; /***/ }), /* 23 */ /***/ (function(module, exports, __webpack_require__) { /** * 可绘制的图形基类 * Base class of all displayable graphic objects * @module zrender/graphic/Displayable */ var zrUtil = __webpack_require__(4); var Style = __webpack_require__(24); var Element = __webpack_require__(25); var RectText = __webpack_require__(36); // var Stateful = require('./mixin/Stateful'); /** * @alias module:zrender/graphic/Displayable * @extends module:zrender/Element * @extends module:zrender/graphic/mixin/RectText */ function Displayable(opts) { opts = opts || {}; Element.call(this, opts); // Extend properties for (var name in opts) { if ( opts.hasOwnProperty(name) && name !== 'style' ) { this[name] = opts[name]; } } /** * @type {module:zrender/graphic/Style} */ this.style = new Style(opts.style, this); this._rect = null; // Shapes for cascade clipping. this.__clipPaths = []; // FIXME Stateful must be mixined after style is setted // Stateful.call(this, opts); } Displayable.prototype = { constructor: Displayable, type: 'displayable', /** * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制 * Dirty flag. From which painter will determine if this displayable object needs brush * @name module:zrender/graphic/Displayable#__dirty * @type {boolean} */ __dirty: true, /** * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件 * If ignore drawing of the displayable object. Mouse event will still be triggered * @name module:/zrender/graphic/Displayable#invisible * @type {boolean} * @default false */ invisible: false, /** * @name module:/zrender/graphic/Displayable#z * @type {number} * @default 0 */ z: 0, /** * @name module:/zrender/graphic/Displayable#z * @type {number} * @default 0 */ z2: 0, /** * z层level，决定绘画在哪层canvas中 * @name module:/zrender/graphic/Displayable#zlevel * @type {number} * @default 0 */ zlevel: 0, /** * 是否可拖拽 * @name module:/zrender/graphic/Displayable#draggable * @type {boolean} * @default false */ draggable: false, /** * 是否正在拖拽 * @name module:/zrender/graphic/Displayable#draggable * @type {boolean} * @default false */ dragging: false, /** * 是否相应鼠标事件 * @name module:/zrender/graphic/Displayable#silent * @type {boolean} * @default false */ silent: false, /** * If enable culling * @type {boolean} * @default false */ culling: false, /** * Mouse cursor when hovered * @name module:/zrender/graphic/Displayable#cursor * @type {string} */ cursor: 'pointer', /** * If hover area is bounding rect * @name module:/zrender/graphic/Displayable#rectHover * @type {string} */ rectHover: false, /** * Render the element progressively when the value >= 0, * usefull for large data. * @type {number} */ progressive: -1, beforeBrush: function (ctx) {}, afterBrush: function (ctx) {}, /** * 图形绘制方法 * @param {CanvasRenderingContext2D} ctx */ // Interface brush: function (ctx, prevEl) {}, /** * 获取最小包围盒 * @return {module:zrender/core/BoundingRect} */ // Interface getBoundingRect: function () {}, /** * 判断坐标 x, y 是否在图形上 * If displayable element contain coord x, y * @param {number} x * @param {number} y * @return {boolean} */ contain: function (x, y) { return this.rectContain(x, y); }, /** * @param {Function} cb * @param {} context */ traverse: function (cb, context) { cb.call(context, this); }, /** * 判断坐标 x, y 是否在图形的包围盒上 * If bounding rect of element contain coord x, y * @param {number} x * @param {number} y * @return {boolean} */ rectContain: function (x, y) { var coord = this.transformCoordToLocal(x, y); var rect = this.getBoundingRect(); return rect.contain(coord[0], coord[1]); }, /** * 标记图形元素为脏，并且在下一帧重绘 * Mark displayable element dirty and refresh next frame */ dirty: function () { this.__dirty = true; this._rect = null; this.__zr && this.__zr.refresh(); }, /** * 图形是否会触发事件 * If displayable object binded any event * @return {boolean} */ // TODO, 通过 bind 绑定的事件 // isSilent: function () { // return !( // this.hoverable || this.draggable // || this.onmousemove || this.onmouseover || this.onmouseout // || this.onmousedown || this.onmouseup || this.onclick // || this.ondragenter || this.ondragover || this.ondragleave // || this.ondrop // ); // }, /** * Alias for animate('style') * @param {boolean} loop */ animateStyle: function (loop) { return this.animate('style', loop); }, attrKV: function (key, value) { if (key !== 'style') { Element.prototype.attrKV.call(this, key, value); } else { this.style.set(value); } }, /** * @param {Object|string} key * @param {*} value */ setStyle: function (key, value) { this.style.set(key, value); this.dirty(false); return this; }, /** * Use given style object * @param {Object} obj */ useStyle: function (obj) { this.style = new Style(obj, this); this.dirty(false); return this; } }; zrUtil.inherits(Displayable, Element); zrUtil.mixin(Displayable, RectText); // zrUtil.mixin(Displayable, Stateful); module.exports = Displayable; /***/ }), /* 24 */ /***/ (function(module, exports) { /** * @module zrender/graphic/Style */ var STYLE_COMMON_PROPS = [ ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10] ]; // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4); // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4); var Style = function (opts, host) { this.extendFrom(opts, false); this.host = host; }; function createLinearGradient(ctx, obj, rect) { var x = obj.x == null ? 0 : obj.x; var x2 = obj.x2 == null ? 1 : obj.x2; var y = obj.y == null ? 0 : obj.y; var y2 = obj.y2 == null ? 0 : obj.y2; if (!obj.global) { x = x * rect.width + rect.x; x2 = x2 * rect.width + rect.x; y = y * rect.height + rect.y; y2 = y2 * rect.height + rect.y; } var canvasGradient = ctx.createLinearGradient(x, y, x2, y2); return canvasGradient; } function createRadialGradient(ctx, obj, rect) { var width = rect.width; var height = rect.height; var min = Math.min(width, height); var x = obj.x == null ? 0.5 : obj.x; var y = obj.y == null ? 0.5 : obj.y; var r = obj.r == null ? 0.5 : obj.r; if (!obj.global) { x = x * width + rect.x; y = y * height + rect.y; r = r * min; } var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r); return canvasGradient; } Style.prototype = { constructor: Style, /** * @type {module:zrender/graphic/Displayable} */ host: null, /** * @type {string} */ fill: '#000', /** * @type {string} */ stroke: null, /** * @type {number} */ opacity: 1, /** * @type {Array.} */ lineDash: null, /** * @type {number} */ lineDashOffset: 0, /** * @type {number} */ shadowBlur: 0, /** * @type {number} */ shadowOffsetX: 0, /** * @type {number} */ shadowOffsetY: 0, /** * @type {number} */ lineWidth: 1, /** * If stroke ignore scale * @type {Boolean} */ strokeNoScale: false, // Bounding rect text configuration // Not affected by element transform /** * @type {string} */ text: null, /** * If `fontSize` or `fontFamily` exists, `font` will be reset by * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`. * So do not visit it directly in upper application (like echarts), * but use `contain/text#makeFont` instead. * @type {string} */ font: null, /** * The same as font. Use font please. * @deprecated * @type {string} */ textFont: null, /** * It helps merging respectively, rather than parsing an entire font string. * @type {string} */ fontStyle: null, /** * It helps merging respectively, rather than parsing an entire font string. * @type {string} */ fontWeight: null, /** * It helps merging respectively, rather than parsing an entire font string. * Should be 12 but not '12px'. * @type {number} */ fontSize: null, /** * It helps merging respectively, rather than parsing an entire font string. * @type {string} */ fontFamily: null, /** * Reserved for special functinality, like 'hr'. * @type {string} */ textTag: null, /** * @type {string} */ textFill: '#000', /** * @type {string} */ textStroke: null, /** * @type {number} */ textWidth: null, /** * Only for textBackground. * @type {number} */ textHeight: null, /** * textStroke may be set as some color as a default * value in upper applicaion, where the default value * of textStrokeWidth should be 0 to make sure that * user can choose to do not use text stroke. * @type {number} */ textStrokeWidth: 0, /** * @type {number} */ textLineHeight: null, /** * 'inside', 'left', 'right', 'top', 'bottom' * [x, y] * Based on x, y of rect. * @type {string|Array.} * @default 'inside' */ textPosition: 'inside', /** * If not specified, use the boundingRect of a `displayable`. * @type {Object} */ textRect: null, /** * [x, y] * @type {Array.} */ textOffset: null, /** * @type {string} */ textAlign: null, /** * @type {string} */ textVerticalAlign: null, /** * @type {number} */ textDistance: 5, /** * @type {string} */ textShadowColor: 'transparent', /** * @type {number} */ textShadowBlur: 0, /** * @type {number} */ textShadowOffsetX: 0, /** * @type {number} */ textShadowOffsetY: 0, /** * @type {string} */ textBoxShadowColor: 'transparent', /** * @type {number} */ textBoxShadowBlur: 0, /** * @type {number} */ textBoxShadowOffsetX: 0, /** * @type {number} */ textBoxShadowOffsetY: 0, /** * Whether transform text. * Only useful in Path and Image element * @type {boolean} */ transformText: false, /** * Text rotate around position of Path or Image * Only useful in Path and Image element and transformText is false. */ textRotation: 0, /** * Text origin of text rotation, like [10, 40]. * Based on x, y of rect. * Useful in label rotation of circular symbol. * By default, this origin is textPosition. * Can be 'center'. * @type {string|Array.} */ textOrigin: null, /** * @type {string} */ textBackgroundColor: null, /** * @type {string} */ textBorderColor: null, /** * @type {number} */ textBorderWidth: 0, /** * @type {number} */ textBorderRadius: 0, /** * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]` * @type {number|Array.} */ textPadding: null, /** * Text styles for rich text. * @type {Object} */ rich: null, /** * {outerWidth, outerHeight, ellipsis, placeholder} * @type {Object} */ truncate: null, /** * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation * @type {string} */ blend: null, /** * @param {CanvasRenderingContext2D} ctx */ bind: function (ctx, el, prevEl) { var style = this; var prevStyle = prevEl && prevEl.style; var firstDraw = !prevStyle; for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) { var prop = STYLE_COMMON_PROPS[i]; var styleName = prop[0]; if (firstDraw || style[styleName] !== prevStyle[styleName]) { // FIXME Invalid property value will cause style leak from previous element. ctx[styleName] = style[styleName] || prop[1]; } } if ((firstDraw || style.fill !== prevStyle.fill)) { ctx.fillStyle = style.fill; } if ((firstDraw || style.stroke !== prevStyle.stroke)) { ctx.strokeStyle = style.stroke; } if ((firstDraw || style.opacity !== prevStyle.opacity)) { ctx.globalAlpha = style.opacity == null ? 1 : style.opacity; } if ((firstDraw || style.blend !== prevStyle.blend)) { ctx.globalCompositeOperation = style.blend || 'source-over'; } if (this.hasStroke()) { var lineWidth = style.lineWidth; ctx.lineWidth = lineWidth / ( (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1 ); } }, hasFill: function () { var fill = this.fill; return fill != null && fill !== 'none'; }, hasStroke: function () { var stroke = this.stroke; return stroke != null && stroke !== 'none' && this.lineWidth > 0; }, /** * Extend from other style * @param {zrender/graphic/Style} otherStyle * @param {boolean} overwrite true: overwrirte any way. * false: overwrite only when !target.hasOwnProperty * others: overwrite when property is not null/undefined. */ extendFrom: function (otherStyle, overwrite) { if (otherStyle) { for (var name in otherStyle) { if (otherStyle.hasOwnProperty(name) && (overwrite === true || ( overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null ) ) ) { this[name] = otherStyle[name]; } } } }, /** * Batch setting style with a given object * @param {Object|string} obj * @param {*} [obj] */ set: function (obj, value) { if (typeof obj === 'string') { this[obj] = value; } else { this.extendFrom(obj, true); } }, /** * Clone * @return {zrender/graphic/Style} [description] */ clone: function () { var newStyle = new this.constructor(); newStyle.extendFrom(this, true); return newStyle; }, getGradient: function (ctx, obj, rect) { var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient; var canvasGradient = method(ctx, obj, rect); var colorStops = obj.colorStops; for (var i = 0; i < colorStops.length; i++) { canvasGradient.addColorStop( colorStops[i].offset, colorStops[i].color ); } return canvasGradient; } }; var styleProto = Style.prototype; for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) { var prop = STYLE_COMMON_PROPS[i]; if (!(prop[0] in styleProto)) { styleProto[prop[0]] = prop[1]; } } // Provide for others Style.getGradient = styleProto.getGradient; module.exports = Style; /***/ }), /* 25 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; /** * @module zrender/Element */ var guid = __webpack_require__(26); var Eventful = __webpack_require__(27); var Transformable = __webpack_require__(28); var Animatable = __webpack_require__(29); var zrUtil = __webpack_require__(4); /** * @alias module:zrender/Element * @constructor * @extends {module:zrender/mixin/Animatable} * @extends {module:zrender/mixin/Transformable} * @extends {module:zrender/mixin/Eventful} */ var Element = function (opts) { Transformable.call(this, opts); Eventful.call(this, opts); Animatable.call(this, opts); /** * 画布元素ID * @type {string} */ this.id = opts.id || guid(); }; Element.prototype = { /** * 元素类型 * Element type * @type {string} */ type: 'element', /** * 元素名字 * Element name * @type {string} */ name: '', /** * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值 * ZRender instance will be assigned when element is associated with zrender * @name module:/zrender/Element#__zr * @type {module:zrender/ZRender} */ __zr: null, /** * 图形是否忽略，为true时忽略图形的绘制以及事件触发 * If ignore drawing and events of the element object * @name module:/zrender/Element#ignore * @type {boolean} * @default false */ ignore: false, /** * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪 * 该路径会继承被裁减对象的变换 * @type {module:zrender/graphic/Path} * @see http://www.w3.org/TR/2dcontext/#clipping-region * @readOnly */ clipPath: null, /** * Drift element * @param {number} dx dx on the global space * @param {number} dy dy on the global space */ drift: function (dx, dy) { switch (this.draggable) { case 'horizontal': dy = 0; break; case 'vertical': dx = 0; break; } var m = this.transform; if (!m) { m = this.transform = [1, 0, 0, 1, 0, 0]; } m[4] += dx; m[5] += dy; this.decomposeTransform(); this.dirty(false); }, /** * Hook before update */ beforeUpdate: function () {}, /** * Hook after update */ afterUpdate: function () {}, /** * Update each frame */ update: function () { this.updateTransform(); }, /** * @param {Function} cb * @param {} context */ traverse: function (cb, context) {}, /** * @protected */ attrKV: function (key, value) { if (key === 'position' || key === 'scale' || key === 'origin') { // Copy the array if (value) { var target = this[key]; if (!target) { target = this[key] = []; } target[0] = value[0]; target[1] = value[1]; } } else { this[key] = value; } }, /** * Hide the element */ hide: function () { this.ignore = true; this.__zr && this.__zr.refresh(); }, /** * Show the element */ show: function () { this.ignore = false; this.__zr && this.__zr.refresh(); }, /** * @param {string|Object} key * @param {*} value */ attr: function (key, value) { if (typeof key === 'string') { this.attrKV(key, value); } else if (zrUtil.isObject(key)) { for (var name in key) { if (key.hasOwnProperty(name)) { this.attrKV(name, key[name]); } } } this.dirty(false); return this; }, /** * @param {module:zrender/graphic/Path} clipPath */ setClipPath: function (clipPath) { var zr = this.__zr; if (zr) { clipPath.addSelfToZr(zr); } // Remove previous clip path if (this.clipPath && this.clipPath !== clipPath) { this.removeClipPath(); } this.clipPath = clipPath; clipPath.__zr = zr; clipPath.__clipTarget = this; this.dirty(false); }, /** */ removeClipPath: function () { var clipPath = this.clipPath; if (clipPath) { if (clipPath.__zr) { clipPath.removeSelfFromZr(clipPath.__zr); } clipPath.__zr = null; clipPath.__clipTarget = null; this.clipPath = null; this.dirty(false); } }, /** * Add self from zrender instance. * Not recursively because it will be invoked when element added to storage. * @param {module:zrender/ZRender} zr */ addSelfToZr: function (zr) { this.__zr = zr; // 添加动画 var animators = this.animators; if (animators) { for (var i = 0; i < animators.length; i++) { zr.animation.addAnimator(animators[i]); } } if (this.clipPath) { this.clipPath.addSelfToZr(zr); } }, /** * Remove self from zrender instance. * Not recursively because it will be invoked when element added to storage. * @param {module:zrender/ZRender} zr */ removeSelfFromZr: function (zr) { this.__zr = null; // 移除动画 var animators = this.animators; if (animators) { for (var i = 0; i < animators.length; i++) { zr.animation.removeAnimator(animators[i]); } } if (this.clipPath) { this.clipPath.removeSelfFromZr(zr); } } }; zrUtil.mixin(Element, Animatable); zrUtil.mixin(Element, Transformable); zrUtil.mixin(Element, Eventful); module.exports = Element; /***/ }), /* 26 */ /***/ (function(module, exports) { /** * zrender: 生成唯一id * * @author errorrik (errorrik@gmail.com) */ var idStart = 0x0907; module.exports = function () { return idStart++; }; /***/ }), /* 27 */ /***/ (function(module, exports) { /** * 事件扩展 * @module zrender/mixin/Eventful * @author Kener (@Kener-林峰, kener.linfeng@gmail.com) * pissang (https://www.github.com/pissang) */ var arrySlice = Array.prototype.slice; /** * 事件分发器 * @alias module:zrender/mixin/Eventful * @constructor */ var Eventful = function () { this._$handlers = {}; }; Eventful.prototype = { constructor: Eventful, /** * 单次触发绑定，trigger后销毁 * * @param {string} event 事件名 * @param {Function} handler 响应函数 * @param {Object} context */ one: function (event, handler, context) { var _h = this._$handlers; if (!handler || !event) { return this; } if (!_h[event]) { _h[event] = []; } for (var i = 0; i < _h[event].length; i++) { if (_h[event][i].h === handler) { return this; } } _h[event].push({ h: handler, one: true, ctx: context || this }); return this; }, /** * 绑定事件 * @param {string} event 事件名 * @param {Function} handler 事件处理函数 * @param {Object} [context] */ on: function (event, handler, context) { var _h = this._$handlers; if (!handler || !event) { return this; } if (!_h[event]) { _h[event] = []; } for (var i = 0; i < _h[event].length; i++) { if (_h[event][i].h === handler) { return this; } } _h[event].push({ h: handler, one: false, ctx: context || this }); return this; }, /** * 是否绑定了事件 * @param {string} event * @return {boolean} */ isSilent: function (event) { var _h = this._$handlers; return _h[event] && _h[event].length; }, /** * 解绑事件 * @param {string} event 事件名 * @param {Function} [handler] 事件处理函数 */ off: function (event, handler) { var _h = this._$handlers; if (!event) { this._$handlers = {}; return this; } if (handler) { if (_h[event]) { var newList = []; for (var i = 0, l = _h[event].length; i < l; i++) { if (_h[event][i]['h'] != handler) { newList.push(_h[event][i]); } } _h[event] = newList; } if (_h[event] && _h[event].length === 0) { delete _h[event]; } } else { delete _h[event]; } return this; }, /** * 事件分发 * * @param {string} type 事件类型 */ trigger: function (type) { if (this._$handlers[type]) { var args = arguments; var argLen = args.length; if (argLen > 3) { args = arrySlice.call(args, 1); } var _h = this._$handlers[type]; var len = _h.length; for (var i = 0; i < len;) { // Optimize advise from backbone switch (argLen) { case 1: _h[i]['h'].call(_h[i]['ctx']); break; case 2: _h[i]['h'].call(_h[i]['ctx'], args[1]); break; case 3: _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]); break; default: // have more than 2 given arguments _h[i]['h'].apply(_h[i]['ctx'], args); break; } if (_h[i]['one']) { _h.splice(i, 1); len--; } else { i++; } } } return this; }, /** * 带有context的事件分发, 最后一个参数是事件回调的context * @param {string} type 事件类型 */ triggerWithContext: function (type) { if (this._$handlers[type]) { var args = arguments; var argLen = args.length; if (argLen > 4) { args = arrySlice.call(args, 1, args.length - 1); } var ctx = args[args.length - 1]; var _h = this._$handlers[type]; var len = _h.length; for (var i = 0; i < len;) { // Optimize advise from backbone switch (argLen) { case 1: _h[i]['h'].call(ctx); break; case 2: _h[i]['h'].call(ctx, args[1]); break; case 3: _h[i]['h'].call(ctx, args[1], args[2]); break; default: // have more than 2 given arguments _h[i]['h'].apply(ctx, args); break; } if (_h[i]['one']) { _h.splice(i, 1); len--; } else { i++; } } } return this; } }; // 对象可以通过 onxxxx 绑定事件 /** * @event module:zrender/mixin/Eventful#onclick * @type {Function} * @default null */ /** * @event module:zrender/mixin/Eventful#onmouseover * @type {Function} * @default null */ /** * @event module:zrender/mixin/Eventful#onmouseout * @type {Function} * @default null */ /** * @event module:zrender/mixin/Eventful#onmousemove * @type {Function} * @default null */ /** * @event module:zrender/mixin/Eventful#onmousewheel * @type {Function} * @default null */ /** * @event module:zrender/mixin/Eventful#onmousedown * @type {Function} * @default null */ /** * @event module:zrender/mixin/Eventful#onmouseup * @type {Function} * @default null */ /** * @event module:zrender/mixin/Eventful#ondrag * @type {Function} * @default null */ /** * @event module:zrender/mixin/Eventful#ondragstart * @type {Function} * @default null */ /** * @event module:zrender/mixin/Eventful#ondragend * @type {Function} * @default null */ /** * @event module:zrender/mixin/Eventful#ondragenter * @type {Function} * @default null */ /** * @event module:zrender/mixin/Eventful#ondragleave * @type {Function} * @default null */ /** * @event module:zrender/mixin/Eventful#ondragover * @type {Function} * @default null */ /** * @event module:zrender/mixin/Eventful#ondrop * @type {Function} * @default null */ module.exports = Eventful; /***/ }), /* 28 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; /** * 提供变换扩展 * @module zrender/mixin/Transformable * @author pissang (https://www.github.com/pissang) */ var matrix = __webpack_require__(11); var vector = __webpack_require__(10); var mIdentity = matrix.identity; var EPSILON = 5e-5; function isNotAroundZero(val) { return val > EPSILON || val < -EPSILON; } /** * @alias module:zrender/mixin/Transformable * @constructor */ var Transformable = function (opts) { opts = opts || {}; // If there are no given position, rotation, scale if (!opts.position) { /** * 平移 * @type {Array.} * @default [0, 0] */ this.position = [0, 0]; } if (opts.rotation == null) { /** * 旋转 * @type {Array.} * @default 0 */ this.rotation = 0; } if (!opts.scale) { /** * 缩放 * @type {Array.} * @default [1, 1] */ this.scale = [1, 1]; } /** * 旋转和缩放的原点 * @type {Array.} * @default null */ this.origin = this.origin || null; }; var transformableProto = Transformable.prototype; transformableProto.transform = null; /** * 判断是否需要有坐标变换 * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵 */ transformableProto.needLocalTransform = function () { return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1); }; transformableProto.updateTransform = function () { var parent = this.parent; var parentHasTransform = parent && parent.transform; var needLocalTransform = this.needLocalTransform(); var m = this.transform; if (!(needLocalTransform || parentHasTransform)) { m && mIdentity(m); return; } m = m || matrix.create(); if (needLocalTransform) { this.getLocalTransform(m); } else { mIdentity(m); } // 应用父节点变换 if (parentHasTransform) { if (needLocalTransform) { matrix.mul(m, parent.transform, m); } else { matrix.copy(m, parent.transform); } } // 保存这个变换矩阵 this.transform = m; this.invTransform = this.invTransform || matrix.create(); matrix.invert(this.invTransform, m); }; transformableProto.getLocalTransform = function (m) { return Transformable.getLocalTransform(this, m); }; /** * 将自己的transform应用到context上 * @param {CanvasRenderingContext2D} ctx */ transformableProto.setTransform = function (ctx) { var m = this.transform; var dpr = ctx.dpr || 1; if (m) { ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]); } else { ctx.setTransform(dpr, 0, 0, dpr, 0, 0); } }; transformableProto.restoreTransform = function (ctx) { var dpr = ctx.dpr || 1; ctx.setTransform(dpr, 0, 0, dpr, 0, 0); }; var tmpTransform = []; /** * 分解`transform`矩阵到`position`, `rotation`, `scale` */ transformableProto.decomposeTransform = function () { if (!this.transform) { return; } var parent = this.parent; var m = this.transform; if (parent && parent.transform) { // Get local transform and decompose them to position, scale, rotation matrix.mul(tmpTransform, parent.invTransform, m); m = tmpTransform; } var sx = m[0] * m[0] + m[1] * m[1]; var sy = m[2] * m[2] + m[3] * m[3]; var position = this.position; var scale = this.scale; if (isNotAroundZero(sx - 1)) { sx = Math.sqrt(sx); } if (isNotAroundZero(sy - 1)) { sy = Math.sqrt(sy); } if (m[0] < 0) { sx = -sx; } if (m[3] < 0) { sy = -sy; } position[0] = m[4]; position[1] = m[5]; scale[0] = sx; scale[1] = sy; this.rotation = Math.atan2(-m[1] / sy, m[0] / sx); }; /** * Get global scale * @return {Array.} */ transformableProto.getGlobalScale = function () { var m = this.transform; if (!m) { return [1, 1]; } var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]); var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]); if (m[0] < 0) { sx = -sx; } if (m[3] < 0) { sy = -sy; } return [sx, sy]; }; /** * 变换坐标位置到 shape 的局部坐标空间 * @method * @param {number} x * @param {number} y * @return {Array.} */ transformableProto.transformCoordToLocal = function (x, y) { var v2 = [x, y]; var invTransform = this.invTransform; if (invTransform) { vector.applyTransform(v2, v2, invTransform); } return v2; }; /** * 变换局部坐标位置到全局坐标空间 * @method * @param {number} x * @param {number} y * @return {Array.} */ transformableProto.transformCoordToGlobal = function (x, y) { var v2 = [x, y]; var transform = this.transform; if (transform) { vector.applyTransform(v2, v2, transform); } return v2; }; /** * @static * @param {Object} target * @param {Array.} target.origin * @param {number} target.rotation * @param {Array.} target.position * @param {Array.} [m] */ Transformable.getLocalTransform = function (target, m) { m = m || []; mIdentity(m); var origin = target.origin; var scale = target.scale || [1, 1]; var rotation = target.rotation || 0; var position = target.position || [0, 0]; if (origin) { // Translate to origin m[4] -= origin[0]; m[5] -= origin[1]; } matrix.scale(m, m, scale); if (rotation) { matrix.rotate(m, m, rotation); } if (origin) { // Translate back from origin m[4] += origin[0]; m[5] += origin[1]; } m[4] += position[0]; m[5] += position[1]; return m; }; module.exports = Transformable; /***/ }), /* 29 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; /** * @module zrender/mixin/Animatable */ var Animator = __webpack_require__(30); var util = __webpack_require__(4); var isString = util.isString; var isFunction = util.isFunction; var isObject = util.isObject; var log = __webpack_require__(34); /** * @alias modue:zrender/mixin/Animatable * @constructor */ var Animatable = function () { /** * @type {Array.} * @readOnly */ this.animators = []; }; Animatable.prototype = { constructor: Animatable, /** * 动画 * * @param {string} path The path to fetch value from object, like 'a.b.c'. * @param {boolean} [loop] Whether to loop animation. * @return {module:zrender/animation/Animator} * @example: * el.animate('style', false) * .when(1000, {x: 10} ) * .done(function(){ // Animation done }) * .start() */ animate: function (path, loop) { var target; var animatingShape = false; var el = this; var zr = this.__zr; if (path) { var pathSplitted = path.split('.'); var prop = el; // If animating shape animatingShape = pathSplitted[0] === 'shape'; for (var i = 0, l = pathSplitted.length; i < l; i++) { if (!prop) { continue; } prop = prop[pathSplitted[i]]; } if (prop) { target = prop; } } else { target = el; } if (!target) { log( 'Property \"' + path + '\" is not existed in element ' + el.id ); return; } var animators = el.animators; var animator = new Animator(target, loop); animator.during(function (target) { el.dirty(animatingShape); }) .done(function () { // FIXME Animator will not be removed if use `Animator#stop` to stop animation animators.splice(util.indexOf(animators, animator), 1); }); animators.push(animator); // If animate after added to the zrender if (zr) { zr.animation.addAnimator(animator); } return animator; }, /** * 停止动画 * @param {boolean} forwardToLast If move to last frame before stop */ stopAnimation: function (forwardToLast) { var animators = this.animators; var len = animators.length; for (var i = 0; i < len; i++) { animators[i].stop(forwardToLast); } animators.length = 0; return this; }, /** * Caution: this method will stop previous animation. * So do not use this method to one element twice before * animation starts, unless you know what you are doing. * @param {Object} target * @param {number} [time=500] Time in ms * @param {string} [easing='linear'] * @param {number} [delay=0] * @param {Function} [callback] * @param {Function} [forceAnimate] Prevent stop animation and callback * immediently when target values are the same as current values. * * @example * // Animate position * el.animateTo({ * position: [10, 10] * }, function () { // done }) * * // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing * el.animateTo({ * shape: { * width: 500 * }, * style: { * fill: 'red' * } * position: [10, 10] * }, 100, 100, 'cubicOut', function () { // done }) */ // TODO Return animation key animateTo: function (target, time, delay, easing, callback, forceAnimate) { // animateTo(target, time, easing, callback); if (isString(delay)) { callback = easing; easing = delay; delay = 0; } // animateTo(target, time, delay, callback); else if (isFunction(easing)) { callback = easing; easing = 'linear'; delay = 0; } // animateTo(target, time, callback); else if (isFunction(delay)) { callback = delay; delay = 0; } // animateTo(target, callback) else if (isFunction(time)) { callback = time; time = 500; } // animateTo(target) else if (!time) { time = 500; } // Stop all previous animations this.stopAnimation(); this._animateToShallow('', this, target, time, delay, easing, callback); // Animators may be removed immediately after start // if there is nothing to animate var animators = this.animators.slice(); var count = animators.length; function done() { count--; if (!count) { callback && callback(); } } // No animators. This should be checked before animators[i].start(), // because 'done' may be executed immediately if no need to animate. if (!count) { callback && callback(); } // Start after all animators created // Incase any animator is done immediately when all animation properties are not changed for (var i = 0; i < animators.length; i++) { animators[i] .done(done) .start(easing, forceAnimate); } }, /** * @private * @param {string} path='' * @param {Object} source=this * @param {Object} target * @param {number} [time=500] * @param {number} [delay=0] * * @example * // Animate position * el._animateToShallow({ * position: [10, 10] * }) * * // Animate shape, style and position in 100ms, delayed 100ms * el._animateToShallow({ * shape: { * width: 500 * }, * style: { * fill: 'red' * } * position: [10, 10] * }, 100, 100) */ _animateToShallow: function (path, source, target, time, delay) { var objShallow = {}; var propertyCount = 0; for (var name in target) { if (!target.hasOwnProperty(name)) { continue; } if (source[name] != null) { if (isObject(target[name]) && !util.isArrayLike(target[name])) { this._animateToShallow( path ? path + '.' + name : name, source[name], target[name], time, delay ); } else { objShallow[name] = target[name]; propertyCount++; } } else if (target[name] != null) { // Attr directly if not has property // FIXME, if some property not needed for element ? if (!path) { this.attr(name, target[name]); } else { // Shape or style var props = {}; props[path] = {}; props[path][name] = target[name]; this.attr(props); } } } if (propertyCount > 0) { this.animate(path, false) .when(time == null ? 500 : time, objShallow) .delay(delay || 0); } return this; } }; module.exports = Animatable; /***/ }), /* 30 */ /***/ (function(module, exports, __webpack_require__) { /** * @module echarts/animation/Animator */ var Clip = __webpack_require__(31); var color = __webpack_require__(33); var util = __webpack_require__(4); var isArrayLike = util.isArrayLike; var arraySlice = Array.prototype.slice; function defaultGetter(target, key) { return target[key]; } function defaultSetter(target, key, value) { target[key] = value; } /** * @param {number} p0 * @param {number} p1 * @param {number} percent * @return {number} */ function interpolateNumber(p0, p1, percent) { return (p1 - p0) * percent + p0; } /** * @param {string} p0 * @param {string} p1 * @param {number} percent * @return {string} */ function interpolateString(p0, p1, percent) { return percent > 0.5 ? p1 : p0; } /** * @param {Array} p0 * @param {Array} p1 * @param {number} percent * @param {Array} out * @param {number} arrDim */ function interpolateArray(p0, p1, percent, out, arrDim) { var len = p0.length; if (arrDim == 1) { for (var i = 0; i < len; i++) { out[i] = interpolateNumber(p0[i], p1[i], percent); } } else { var len2 = len && p0[0].length; for (var i = 0; i < len; i++) { for (var j = 0; j < len2; j++) { out[i][j] = interpolateNumber( p0[i][j], p1[i][j], percent ); } } } } // arr0 is source array, arr1 is target array. // Do some preprocess to avoid error happened when interpolating from arr0 to arr1 function fillArr(arr0, arr1, arrDim) { var arr0Len = arr0.length; var arr1Len = arr1.length; if (arr0Len !== arr1Len) { // FIXME Not work for TypedArray var isPreviousLarger = arr0Len > arr1Len; if (isPreviousLarger) { // Cut the previous arr0.length = arr1Len; } else { // Fill the previous for (var i = arr0Len; i < arr1Len; i++) { arr0.push( arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]) ); } } } // Handling NaN value var len2 = arr0[0] && arr0[0].length; for (var i = 0; i < arr0.length; i++) { if (arrDim === 1) { if (isNaN(arr0[i])) { arr0[i] = arr1[i]; } } else { for (var j = 0; j < len2; j++) { if (isNaN(arr0[i][j])) { arr0[i][j] = arr1[i][j]; } } } } } /** * @param {Array} arr0 * @param {Array} arr1 * @param {number} arrDim * @return {boolean} */ function isArraySame(arr0, arr1, arrDim) { if (arr0 === arr1) { return true; } var len = arr0.length; if (len !== arr1.length) { return false; } if (arrDim === 1) { for (var i = 0; i < len; i++) { if (arr0[i] !== arr1[i]) { return false; } } } else { var len2 = arr0[0].length; for (var i = 0; i < len; i++) { for (var j = 0; j < len2; j++) { if (arr0[i][j] !== arr1[i][j]) { return false; } } } } return true; } /** * Catmull Rom interpolate array * @param {Array} p0 * @param {Array} p1 * @param {Array} p2 * @param {Array} p3 * @param {number} t * @param {number} t2 * @param {number} t3 * @param {Array} out * @param {number} arrDim */ function catmullRomInterpolateArray( p0, p1, p2, p3, t, t2, t3, out, arrDim ) { var len = p0.length; if (arrDim == 1) { for (var i = 0; i < len; i++) { out[i] = catmullRomInterpolate( p0[i], p1[i], p2[i], p3[i], t, t2, t3 ); } } else { var len2 = p0[0].length; for (var i = 0; i < len; i++) { for (var j = 0; j < len2; j++) { out[i][j] = catmullRomInterpolate( p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3 ); } } } } /** * Catmull Rom interpolate number * @param {number} p0 * @param {number} p1 * @param {number} p2 * @param {number} p3 * @param {number} t * @param {number} t2 * @param {number} t3 * @return {number} */ function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) { var v0 = (p2 - p0) * 0.5; var v1 = (p3 - p1) * 0.5; return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1; } function cloneValue(value) { if (isArrayLike(value)) { var len = value.length; if (isArrayLike(value[0])) { var ret = []; for (var i = 0; i < len; i++) { ret.push(arraySlice.call(value[i])); } return ret; } return arraySlice.call(value); } return value; } function rgba2String(rgba) { rgba[0] = Math.floor(rgba[0]); rgba[1] = Math.floor(rgba[1]); rgba[2] = Math.floor(rgba[2]); return 'rgba(' + rgba.join(',') + ')'; } function getArrayDim(keyframes) { var lastValue = keyframes[keyframes.length - 1].value; return isArrayLike(lastValue && lastValue[0]) ? 2 : 1; } function createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) { var getter = animator._getter; var setter = animator._setter; var useSpline = easing === 'spline'; var trackLen = keyframes.length; if (!trackLen) { return; } // Guess data type var firstVal = keyframes[0].value; var isValueArray = isArrayLike(firstVal); var isValueColor = false; var isValueString = false; // For vertices morphing var arrDim = isValueArray ? getArrayDim(keyframes) : 0; var trackMaxTime; // Sort keyframe as ascending keyframes.sort(function(a, b) { return a.time - b.time; }); trackMaxTime = keyframes[trackLen - 1].time; // Percents of each keyframe var kfPercents = []; // Value of each keyframe var kfValues = []; var prevValue = keyframes[0].value; var isAllValueEqual = true; for (var i = 0; i < trackLen; i++) { kfPercents.push(keyframes[i].time / trackMaxTime); // Assume value is a color when it is a string var value = keyframes[i].value; // Check if value is equal, deep check if value is array if (!((isValueArray && isArraySame(value, prevValue, arrDim)) || (!isValueArray && value === prevValue))) { isAllValueEqual = false; } prevValue = value; // Try converting a string to a color array if (typeof value == 'string') { var colorArray = color.parse(value); if (colorArray) { value = colorArray; isValueColor = true; } else { isValueString = true; } } kfValues.push(value); } if (!forceAnimate && isAllValueEqual) { return; } var lastValue = kfValues[trackLen - 1]; // Polyfill array and NaN value for (var i = 0; i < trackLen - 1; i++) { if (isValueArray) { fillArr(kfValues[i], lastValue, arrDim); } else { if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) { kfValues[i] = lastValue; } } } isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim); // Cache the key of last frame to speed up when // animation playback is sequency var lastFrame = 0; var lastFramePercent = 0; var start; var w; var p0; var p1; var p2; var p3; if (isValueColor) { var rgba = [0, 0, 0, 0]; } var onframe = function (target, percent) { // Find the range keyframes // kf1-----kf2---------current--------kf3 // find kf2 and kf3 and do interpolation var frame; // In the easing function like elasticOut, percent may less than 0 if (percent < 0) { frame = 0; } else if (percent < lastFramePercent) { // Start from next key // PENDING start from lastFrame ? start = Math.min(lastFrame + 1, trackLen - 1); for (frame = start; frame >= 0; frame--) { if (kfPercents[frame] trackLen - 2 ? trackLen - 1 : frame + 1]; p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2]; if (isValueArray) { catmullRomInterpolateArray( p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim ); } else { var value; if (isValueColor) { value = catmullRomInterpolateArray( p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1 ); value = rgba2String(rgba); } else if (isValueString) { // String is step(0.5) return interpolateString(p1, p2, w); } else { value = catmullRomInterpolate( p0, p1, p2, p3, w, w * w, w * w * w ); } setter( target, propName, value ); } } else { if (isValueArray) { interpolateArray( kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim ); } else { var value; if (isValueColor) { interpolateArray( kfValues[frame], kfValues[frame + 1], w, rgba, 1 ); value = rgba2String(rgba); } else if (isValueString) { // String is step(0.5) return interpolateString(kfValues[frame], kfValues[frame + 1], w); } else { value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w); } setter( target, propName, value ); } } }; var clip = new Clip({ target: animator._target, life: trackMaxTime, loop: animator._loop, delay: animator._delay, onframe: onframe, ondestroy: oneTrackDone }); if (easing && easing !== 'spline') { clip.easing = easing; } return clip; } /** * @alias module:zrender/animation/Animator * @constructor * @param {Object} target * @param {boolean} loop * @param {Function} getter * @param {Function} setter */ var Animator = function(target, loop, getter, setter) { this._tracks = {}; this._target = target; this._loop = loop || false; this._getter = getter || defaultGetter; this._setter = setter || defaultSetter; this._clipCount = 0; this._delay = 0; this._doneList = []; this._onframeList = []; this._clipList = []; }; Animator.prototype = { /** * 设置动画关键帧 * @param {number} time 关键帧时间，单位是ms * @param {Object} props 关键帧的属性值，key-value表示 * @return {module:zrender/animation/Animator} */ when: function(time /* ms */, props) { var tracks = this._tracks; for (var propName in props) { if (!props.hasOwnProperty(propName)) { continue; } if (!tracks[propName]) { tracks[propName] = []; // Invalid value var value = this._getter(this._target, propName); if (value == null) { // zrLog('Invalid property ' + propName); continue; } // If time is 0 // Then props is given initialize value // Else // Initialize value from current prop value if (time !== 0) { tracks[propName].push({ time: 0, value: cloneValue(value) }); } } tracks[propName].push({ time: time, value: props[propName] }); } return this; }, /** * 添加动画每一帧的回调函数 * @param {Function} callback * @return {module:zrender/animation/Animator} */ during: function (callback) { this._onframeList.push(callback); return this; }, pause: function () { for (var i = 0; i < this._clipList.length; i++) { this._clipList[i].pause(); } this._paused = true; }, resume: function () { for (var i = 0; i < this._clipList.length; i++) { this._clipList[i].resume(); } this._paused = false; }, isPaused: function () { return !!this._paused; }, _doneCallback: function () { // Clear all tracks this._tracks = {}; // Clear all clips this._clipList.length = 0; var doneList = this._doneList; var len = doneList.length; for (var i = 0; i < len; i++) { doneList[i].call(this); } }, /** * 开始执行动画 * @param {string|Function} [easing] * 动画缓动函数，详见{@link module:zrender/animation/easing} * @param {boolean} forceAnimate * @return {module:zrender/animation/Animator} */ start: function (easing, forceAnimate) { var self = this; var clipCount = 0; var oneTrackDone = function() { clipCount--; if (!clipCount) { self._doneCallback(); } }; var lastClip; for (var propName in this._tracks) { if (!this._tracks.hasOwnProperty(propName)) { continue; } var clip = createTrackClip( this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate ); if (clip) { this._clipList.push(clip); clipCount++; // If start after added to animation if (this.animation) { this.animation.addClip(clip); } lastClip = clip; } } // Add during callback on the last clip if (lastClip) { var oldOnFrame = lastClip.onframe; lastClip.onframe = function (target, percent) { oldOnFrame(target, percent); for (var i = 0; i < self._onframeList.length; i++) { self._onframeList[i](target, percent); } }; } // This optimization will help the case that in the upper application // the view may be refreshed frequently, where animation will be // called repeatly but nothing changed. if (!clipCount) { this._doneCallback(); } return this; }, /** * 停止动画 * @param {boolean} forwardToLast If move to last frame before stop */ stop: function (forwardToLast) { var clipList = this._clipList; var animation = this.animation; for (var i = 0; i < clipList.length; i++) { var clip = clipList[i]; if (forwardToLast) { // Move to last frame before stop clip.onframe(this._target, 1); } animation && animation.removeClip(clip); } clipList.length = 0; }, /** * 设置动画延迟开始的时间 * @param {number} time 单位ms * @return {module:zrender/animation/Animator} */ delay: function (time) { this._delay = time; return this; }, /** * 添加动画结束的回调 * @param {Function} cb * @return {module:zrender/animation/Animator} */ done: function(cb) { if (cb) { this._doneList.push(cb); } return this; }, /** * @return {Array.} */ getClips: function () { return this._clipList; } }; module.exports = Animator; /***/ }), /* 31 */ /***/ (function(module, exports, __webpack_require__) { /** * 动画主控制器 * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件 * @config life(1000) 动画时长 * @config delay(0) 动画延迟时间 * @config loop(true) * @config gap(0) 循环的间隔时间 * @config onframe * @config easing(optional) * @config ondestroy(optional) * @config onrestart(optional) * * TODO pause */ var easingFuncs = __webpack_require__(32); function Clip(options) { this._target = options.target; // 生命周期 this._life = options.life || 1000; // 延时 this._delay = options.delay || 0; // 开始时间 // this._startTime = new Date().getTime() + this._delay;// 单位毫秒 this._initialized = false; // 是否循环 this.loop = options.loop == null ? false : options.loop; this.gap = options.gap || 0; this.easing = options.easing || 'Linear'; this.onframe = options.onframe; this.ondestroy = options.ondestroy; this.onrestart = options.onrestart; this._pausedTime = 0; this._paused = false; } Clip.prototype = { constructor: Clip, step: function (globalTime, deltaTime) { // Set startTime on first step, or _startTime may has milleseconds different between clips // PENDING if (!this._initialized) { this._startTime = globalTime + this._delay; this._initialized = true; } if (this._paused) { this._pausedTime += deltaTime; return; } var percent = (globalTime - this._startTime - this._pausedTime) / this._life; // 还没开始 if (percent < 0) { return; } percent = Math.min(percent, 1); var easing = this.easing; var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing; var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent; this.fire('frame', schedule); // 结束 if (percent == 1) { if (this.loop) { this.restart (globalTime); // 重新开始周期 // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件 return 'restart'; } // 动画完成将这个控制器标识为待删除 // 在Animation.update中进行批量删除 this._needsRemove = true; return 'destroy'; } return null; }, restart: function (globalTime) { var remainder = (globalTime - this._startTime - this._pausedTime) % this._life; this._startTime = globalTime - remainder + this.gap; this._pausedTime = 0; this._needsRemove = false; }, fire: function (eventType, arg) { eventType = 'on' + eventType; if (this[eventType]) { this[eventType](this._target, arg); } }, pause: function () { this._paused = true; }, resume: function () { this._paused = false; } }; module.exports = Clip; /***/ }), /* 32 */ /***/ (function(module, exports) { /** * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js * @see http://sole.github.io/tween.js/examples/03_graphs.html * @exports zrender/animation/easing */ var easing = { /** * @param {number} k * @return {number} */ linear: function (k) { return k; }, /** * @param {number} k * @return {number} */ quadraticIn: function (k) { return k * k; }, /** * @param {number} k * @return {number} */ quadraticOut: function (k) { return k * (2 - k); }, /** * @param {number} k * @return {number} */ quadraticInOut: function (k) { if ((k *= 2) < 1) { return 0.5 * k * k; } return -0.5 * (--k * (k - 2) - 1); }, // 三次方的缓动（t^3） /** * @param {number} k * @return {number} */ cubicIn: function (k) { return k * k * k; }, /** * @param {number} k * @return {number} */ cubicOut: function (k) { return --k * k * k + 1; }, /** * @param {number} k * @return {number} */ cubicInOut: function (k) { if ((k *= 2) < 1) { return 0.5 * k * k * k; } return 0.5 * ((k -= 2) * k * k + 2); }, // 四次方的缓动（t^4） /** * @param {number} k * @return {number} */ quarticIn: function (k) { return k * k * k * k; }, /** * @param {number} k * @return {number} */ quarticOut: function (k) { return 1 - (--k * k * k * k); }, /** * @param {number} k * @return {number} */ quarticInOut: function (k) { if ((k *= 2) < 1) { return 0.5 * k * k * k * k; } return -0.5 * ((k -= 2) * k * k * k - 2); }, // 五次方的缓动（t^5） /** * @param {number} k * @return {number} */ quinticIn: function (k) { return k * k * k * k * k; }, /** * @param {number} k * @return {number} */ quinticOut: function (k) { return --k * k * k * k * k + 1; }, /** * @param {number} k * @return {number} */ quinticInOut: function (k) { if ((k *= 2) < 1) { return 0.5 * k * k * k * k * k; } return 0.5 * ((k -= 2) * k * k * k * k + 2); }, // 正弦曲线的缓动（sin(t)） /** * @param {number} k * @return {number} */ sinusoidalIn: function (k) { return 1 - Math.cos(k * Math.PI / 2); }, /** * @param {number} k * @return {number} */ sinusoidalOut: function (k) { return Math.sin(k * Math.PI / 2); }, /** * @param {number} k * @return {number} */ sinusoidalInOut: function (k) { return 0.5 * (1 - Math.cos(Math.PI * k)); }, // 指数曲线的缓动（2^t） /** * @param {number} k * @return {number} */ exponentialIn: function (k) { return k === 0 ? 0 : Math.pow(1024, k - 1); }, /** * @param {number} k * @return {number} */ exponentialOut: function (k) { return k === 1 ? 1 : 1 - Math.pow(2, -10 * k); }, /** * @param {number} k * @return {number} */ exponentialInOut: function (k) { if (k === 0) { return 0; } if (k === 1) { return 1; } if ((k *= 2) < 1) { return 0.5 * Math.pow(1024, k - 1); } return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2); }, // 圆形曲线的缓动（sqrt(1-t^2)） /** * @param {number} k * @return {number} */ circularIn: function (k) { return 1 - Math.sqrt(1 - k * k); }, /** * @param {number} k * @return {number} */ circularOut: function (k) { return Math.sqrt(1 - (--k * k)); }, /** * @param {number} k * @return {number} */ circularInOut: function (k) { if ((k *= 2) < 1) { return -0.5 * (Math.sqrt(1 - k * k) - 1); } return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1); }, // 创建类似于弹簧在停止前来回振荡的动画 /** * @param {number} k * @return {number} */ elasticIn: function (k) { var s; var a = 0.1; var p = 0.4; if (k === 0) { return 0; } if (k === 1) { return 1; } if (!a || a < 1) { a = 1; s = p / 4; } else { s = p * Math.asin(1 / a) / (2 * Math.PI); } return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p)); }, /** * @param {number} k * @return {number} */ elasticOut: function (k) { var s; var a = 0.1; var p = 0.4; if (k === 0) { return 0; } if (k === 1) { return 1; } if (!a || a < 1) { a = 1; s = p / 4; } else { s = p * Math.asin(1 / a) / (2 * Math.PI); } return (a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1); }, /** * @param {number} k * @return {number} */ elasticInOut: function (k) { var s; var a = 0.1; var p = 0.4; if (k === 0) { return 0; } if (k === 1) { return 1; } if (!a || a < 1) { a = 1; s = p / 4; } else { s = p * Math.asin(1 / a) / (2 * Math.PI); } if ((k *= 2) < 1) { return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p)); } return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1; }, // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动 /** * @param {number} k * @return {number} */ backIn: function (k) { var s = 1.70158; return k * k * ((s + 1) * k - s); }, /** * @param {number} k * @return {number} */ backOut: function (k) { var s = 1.70158; return --k * k * ((s + 1) * k + s) + 1; }, /** * @param {number} k * @return {number} */ backInOut: function (k) { var s = 1.70158 * 1.525; if ((k *= 2) < 1) { return 0.5 * (k * k * ((s + 1) * k - s)); } return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2); }, // 创建弹跳效果 /** * @param {number} k * @return {number} */ bounceIn: function (k) { return 1 - easing.bounceOut(1 - k); }, /** * @param {number} k * @return {number} */ bounceOut: function (k) { if (k < (1 / 2.75)) { return 7.5625 * k * k; } else if (k < (2 / 2.75)) { return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75; } else if (k < (2.5 / 2.75)) { return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375; } else { return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375; } }, /** * @param {number} k * @return {number} */ bounceInOut: function (k) { if (k < 0.5) { return easing.bounceIn(k * 2) * 0.5; } return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5; } }; module.exports = easing; /***/ }), /* 33 */ /***/ (function(module, exports, __webpack_require__) { /** * @module zrender/tool/color */ var LRU = __webpack_require__(13); var kCSSColorTable = { 'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1], 'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1], 'aquamarine': [127,255,212,1], 'azure': [240,255,255,1], 'beige': [245,245,220,1], 'bisque': [255,228,196,1], 'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1], 'blue': [0,0,255,1], 'blueviolet': [138,43,226,1], 'brown': [165,42,42,1], 'burlywood': [222,184,135,1], 'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1], 'chocolate': [210,105,30,1], 'coral': [255,127,80,1], 'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1], 'crimson': [220,20,60,1], 'cyan': [0,255,255,1], 'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1], 'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1], 'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1], 'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1], 'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1], 'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1], 'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1], 'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1], 'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1], 'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1], 'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1], 'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1], 'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1], 'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1], 'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1], 'gold': [255,215,0,1], 'goldenrod': [218,165,32,1], 'gray': [128,128,128,1], 'green': [0,128,0,1], 'greenyellow': [173,255,47,1], 'grey': [128,128,128,1], 'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1], 'indianred': [205,92,92,1], 'indigo': [75,0,130,1], 'ivory': [255,255,240,1], 'khaki': [240,230,140,1], 'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1], 'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1], 'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1], 'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1], 'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1], 'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1], 'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1], 'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1], 'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1], 'lightyellow': [255,255,224,1], 'lime': [0,255,0,1], 'limegreen': [50,205,50,1], 'linen': [250,240,230,1], 'magenta': [255,0,255,1], 'maroon': [128,0,0,1], 'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1], 'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1], 'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1], 'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1], 'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1], 'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1], 'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1], 'navy': [0,0,128,1], 'oldlace': [253,245,230,1], 'olive': [128,128,0,1], 'olivedrab': [107,142,35,1], 'orange': [255,165,0,1], 'orangered': [255,69,0,1], 'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1], 'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1], 'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1], 'peachpuff': [255,218,185,1], 'peru': [205,133,63,1], 'pink': [255,192,203,1], 'plum': [221,160,221,1], 'powderblue': [176,224,230,1], 'purple': [128,0,128,1], 'red': [255,0,0,1], 'rosybrown': [188,143,143,1], 'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1], 'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1], 'seagreen': [46,139,87,1], 'seashell': [255,245,238,1], 'sienna': [160,82,45,1], 'silver': [192,192,192,1], 'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1], 'slategray': [112,128,144,1], 'slategrey': [112,128,144,1], 'snow': [255,250,250,1], 'springgreen': [0,255,127,1], 'steelblue': [70,130,180,1], 'tan': [210,180,140,1], 'teal': [0,128,128,1], 'thistle': [216,191,216,1], 'tomato': [255,99,71,1], 'turquoise': [64,224,208,1], 'violet': [238,130,238,1], 'wheat': [245,222,179,1], 'white': [255,255,255,1], 'whitesmoke': [245,245,245,1], 'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1] }; function clampCssByte(i) { // Clamp to integer 0 .. 255. i = Math.round(i); // Seems to be what Chrome does (vs truncation). return i < 0 ? 0 : i > 255 ? 255 : i; } function clampCssAngle(i) { // Clamp to integer 0 .. 360. i = Math.round(i); // Seems to be what Chrome does (vs truncation). return i < 0 ? 0 : i > 360 ? 360 : i; } function clampCssFloat(f) { // Clamp to float 0.0 .. 1.0. return f < 0 ? 0 : f > 1 ? 1 : f; } function parseCssInt(str) { // int or percentage. if (str.length && str.charAt(str.length - 1) === '%') { return clampCssByte(parseFloat(str) / 100 * 255); } return clampCssByte(parseInt(str, 10)); } function parseCssFloat(str) { // float or percentage. if (str.length && str.charAt(str.length - 1) === '%') { return clampCssFloat(parseFloat(str) / 100); } return clampCssFloat(parseFloat(str)); } function cssHueToRgb(m1, m2, h) { if (h < 0) { h += 1; } else if (h > 1) { h -= 1; } if (h * 6 < 1) { return m1 + (m2 - m1) * h * 6; } if (h * 2 < 1) { return m2; } if (h * 3 < 2) { return m1 + (m2 - m1) * (2/3 - h) * 6; } return m1; } function lerpNumber(a, b, p) { return a + (b - a) * p; } function setRgba(out, r, g, b, a) { out[0] = r; out[1] = g; out[2] = b; out[3] = a; return out; } function copyRgba(out, a) { out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3]; return out; } var colorCache = new LRU(20); var lastRemovedArr = null; function putToCache(colorStr, rgbaArr) { // Reuse removed array if (lastRemovedArr) { copyRgba(lastRemovedArr, rgbaArr); } lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || (rgbaArr.slice())); } /** * @param {string} colorStr * @param {Array.} out * @return {Array.} * @memberOf module:zrender/util/color */ function parse(colorStr, rgbaArr) { if (!colorStr) { return; } rgbaArr = rgbaArr || []; var cached = colorCache.get(colorStr); if (cached) { return copyRgba(rgbaArr, cached); } // colorStr may be not string colorStr = colorStr + ''; // Remove all whitespace, not compliant, but should just be more accepting. var str = colorStr.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup. if (str in kCSSColorTable) { copyRgba(rgbaArr, kCSSColorTable[str]); putToCache(colorStr, rgbaArr); return rgbaArr; } // #abc and #abc123 syntax. if (str.charAt(0) === '#') { if (str.length === 4) { var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing. if (!(iv >= 0 && iv > 4) | ((iv & 0xf00) >> 8), (iv & 0xf0) | ((iv & 0xf0) >> 4), (iv & 0xf) | ((iv & 0xf) = 0 && iv > 16, (iv & 0xff00) >> 8, iv & 0xff, 1 ); putToCache(colorStr, rgbaArr); return rgbaArr; } return; } var op = str.indexOf('('), ep = str.indexOf(')'); if (op !== -1 && ep + 1 === str.length) { var fname = str.substr(0, op); var params = str.substr(op + 1, ep - (op + 1)).split(','); var alpha = 1; // To allow case fallthrough. switch (fname) { case 'rgba': if (params.length !== 4) { setRgba(rgbaArr, 0, 0, 0, 1); return; } alpha = parseCssFloat(params.pop()); // jshint ignore:line // Fall through. case 'rgb': if (params.length !== 3) { setRgba(rgbaArr, 0, 0, 0, 1); return; } setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha ); putToCache(colorStr, rgbaArr); return rgbaArr; case 'hsla': if (params.length !== 4) { setRgba(rgbaArr, 0, 0, 0, 1); return; } params[3] = parseCssFloat(params[3]); hsla2rgba(params, rgbaArr); putToCache(colorStr, rgbaArr); return rgbaArr; case 'hsl': if (params.length !== 3) { setRgba(rgbaArr, 0, 0, 0, 1); return; } hsla2rgba(params, rgbaArr); putToCache(colorStr, rgbaArr); return rgbaArr; default: return; } } setRgba(rgbaArr, 0, 0, 0, 1); return; } /** * @param {Array.} hsla * @param {Array.} rgba * @return {Array.} rgba */ function hsla2rgba(hsla, rgba) { var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360; // 0 .. 1 // NOTE(deanm): According to the CSS spec s/l should only be // percentages, but we don't bother and let float or percentage. var s = parseCssFloat(hsla[1]); var l = parseCssFloat(hsla[2]); var m2 = l 1) { H -= 1; } } var hsla = [H * 360, S, L]; if (rgba[3] != null) { hsla.push(rgba[3]); } return hsla; } /** * @param {string} color * @param {number} level * @return {string} * @memberOf module:zrender/util/color */ function lift(color, level) { var colorArr = parse(color); if (colorArr) { for (var i = 0; i < 3; i++) { if (level < 0) { colorArr[i] = colorArr[i] * (1 - level) | 0; } else { colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0; } } return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb'); } } /** * @param {string} color * @return {string} * @memberOf module:zrender/util/color */ function toHex(color, level) { var colorArr = parse(color); if (colorArr) { return ((1 = 0 && (token = tokens[rightIndex], token.textAlign === 'right') ) { placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right'); usedWidth -= token.width; lineXRight -= token.width; rightIndex--; } // The other tokens are placed as textAlign 'center' if there is enough space. lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2; while (leftIndex width) { total = r1 + r2; r1 *= width / total; r2 *= width / total; } if (r3 + r4 > width) { total = r3 + r4; r3 *= width / total; r4 *= width / total; } if (r2 + r3 > height) { total = r2 + r3; r2 *= height / total; r3 *= height / total; } if (r1 + r4 > height) { total = r1 + r4; r1 *= height / total; r4 *= height / total; } ctx.moveTo(x + r1, y); ctx.lineTo(x + width - r2, y); r2 !== 0 && ctx.quadraticCurveTo( x + width, y, x + width, y + r2 ); ctx.lineTo(x + width, y + height - r3); r3 !== 0 && ctx.quadraticCurveTo( x + width, y + height, x + width - r3, y + height ); ctx.lineTo(x + r4, y + height); r4 !== 0 && ctx.quadraticCurveTo( x, y + height, x, y + height - r4 ); ctx.lineTo(x, y + r1); r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y); } }; /***/ }), /* 39 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; /** * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中 * 可以用于 isInsidePath 判断以及获取boundingRect * * @module zrender/core/PathProxy * @author Yi Shen (http://www.github.com/pissang) */ // TODO getTotalLength, getPointAtLength var curve = __webpack_require__(40); var vec2 = __webpack_require__(10); var bbox = __webpack_require__(41); var BoundingRect = __webpack_require__(9); var dpr = __webpack_require__(35).devicePixelRatio; var CMD = { M: 1, L: 2, C: 3, Q: 4, A: 5, Z: 6, // Rect R: 7 }; // var CMD_MEM_SIZE = { // M: 3, // L: 3, // C: 7, // Q: 5, // A: 9, // R: 5, // Z: 1 // }; var min = []; var max = []; var min2 = []; var max2 = []; var mathMin = Math.min; var mathMax = Math.max; var mathCos = Math.cos; var mathSin = Math.sin; var mathSqrt = Math.sqrt; var mathAbs = Math.abs; var hasTypedArray = typeof Float32Array != 'undefined'; /** * @alias module:zrender/core/PathProxy * @constructor */ var PathProxy = function (notSaveData) { this._saveData = !(notSaveData || false); if (this._saveData) { /** * Path data. Stored as flat array * @type {Array.} */ this.data = []; } this._ctx = null; }; /** * 快速计算Path包围盒（并不是最小包围盒） * @return {Object} */ PathProxy.prototype = { constructor: PathProxy, _xi: 0, _yi: 0, _x0: 0, _y0: 0, // Unit x, Unit y. Provide for avoiding drawing that too short line segment _ux: 0, _uy: 0, _len: 0, _lineDash: null, _dashOffset: 0, _dashIdx: 0, _dashSum: 0, /** * @readOnly */ setScale: function (sx, sy) { this._ux = mathAbs(1 / dpr / sx) || 0; this._uy = mathAbs(1 / dpr / sy) || 0; }, getContext: function () { return this._ctx; }, /** * @param {CanvasRenderingContext2D} ctx * @return {module:zrender/core/PathProxy} */ beginPath: function (ctx) { this._ctx = ctx; ctx && ctx.beginPath(); ctx && (this.dpr = ctx.dpr); // Reset if (this._saveData) { this._len = 0; } if (this._lineDash) { this._lineDash = null; this._dashOffset = 0; } return this; }, /** * @param {number} x * @param {number} y * @return {module:zrender/core/PathProxy} */ moveTo: function (x, y) { this.addData(CMD.M, x, y); this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用 // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。 // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要 // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持 this._x0 = x; this._y0 = y; this._xi = x; this._yi = y; return this; }, /** * @param {number} x * @param {number} y * @return {module:zrender/core/PathProxy} */ lineTo: function (x, y) { var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment || this._len < 5; this.addData(CMD.L, x, y); if (this._ctx && exceedUnit) { this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y); } if (exceedUnit) { this._xi = x; this._yi = y; } return this; }, /** * @param {number} x1 * @param {number} y1 * @param {number} x2 * @param {number} y2 * @param {number} x3 * @param {number} y3 * @return {module:zrender/core/PathProxy} */ bezierCurveTo: function (x1, y1, x2, y2, x3, y3) { this.addData(CMD.C, x1, y1, x2, y2, x3, y3); if (this._ctx) { this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3); } this._xi = x3; this._yi = y3; return this; }, /** * @param {number} x1 * @param {number} y1 * @param {number} x2 * @param {number} y2 * @return {module:zrender/core/PathProxy} */ quadraticCurveTo: function (x1, y1, x2, y2) { this.addData(CMD.Q, x1, y1, x2, y2); if (this._ctx) { this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2); } this._xi = x2; this._yi = y2; return this; }, /** * @param {number} cx * @param {number} cy * @param {number} r * @param {number} startAngle * @param {number} endAngle * @param {boolean} anticlockwise * @return {module:zrender/core/PathProxy} */ arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) { this.addData( CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1 ); this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise); this._xi = mathCos(endAngle) * r + cx; this._yi = mathSin(endAngle) * r + cx; return this; }, // TODO arcTo: function (x1, y1, x2, y2, radius) { if (this._ctx) { this._ctx.arcTo(x1, y1, x2, y2, radius); } return this; }, // TODO rect: function (x, y, w, h) { this._ctx && this._ctx.rect(x, y, w, h); this.addData(CMD.R, x, y, w, h); return this; }, /** * @return {module:zrender/core/PathProxy} */ closePath: function () { this.addData(CMD.Z); var ctx = this._ctx; var x0 = this._x0; var y0 = this._y0; if (ctx) { this._needsDash() && this._dashedLineTo(x0, y0); ctx.closePath(); } this._xi = x0; this._yi = y0; return this; }, /** * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。 * stroke 同样 * @param {CanvasRenderingContext2D} ctx * @return {module:zrender/core/PathProxy} */ fill: function (ctx) { ctx && ctx.fill(); this.toStatic(); }, /** * @param {CanvasRenderingContext2D} ctx * @return {module:zrender/core/PathProxy} */ stroke: function (ctx) { ctx && ctx.stroke(); this.toStatic(); }, /** * 必须在其它绘制命令前调用 * Must be invoked before all other path drawing methods * @return {module:zrender/core/PathProxy} */ setLineDash: function (lineDash) { if (lineDash instanceof Array) { this._lineDash = lineDash; this._dashIdx = 0; var lineDashSum = 0; for (var i = 0; i < lineDash.length; i++) { lineDashSum += lineDash[i]; } this._dashSum = lineDashSum; } return this; }, /** * 必须在其它绘制命令前调用 * Must be invoked before all other path drawing methods * @return {module:zrender/core/PathProxy} */ setLineDashOffset: function (offset) { this._dashOffset = offset; return this; }, /** * * @return {boolean} */ len: function () { return this._len; }, /** * 直接设置 Path 数据 */ setData: function (data) { var len = data.length; if (! (this.data && this.data.length == len) && hasTypedArray) { this.data = new Float32Array(len); } for (var i = 0; i < len; i++) { this.data[i] = data[i]; } this._len = len; }, /** * 添加子路径 * @param {module:zrender/core/PathProxy|Array.} path */ appendPath: function (path) { if (!(path instanceof Array)) { path = [path]; } var len = path.length; var appendSize = 0; var offset = this._len; for (var i = 0; i < len; i++) { appendSize += path[i].len(); } if (hasTypedArray && (this.data instanceof Float32Array)) { this.data = new Float32Array(offset + appendSize); } for (var i = 0; i < len; i++) { var appendPathData = path[i].data; for (var k = 0; k < appendPathData.length; k++) { this.data[offset++] = appendPathData[k]; } } this._len = offset; }, /** * 填充 Path 数据。 * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。 */ addData: function (cmd) { if (!this._saveData) { return; } var data = this.data; if (this._len + arguments.length > data.length) { // 因为之前的数组已经转换成静态的 Float32Array // 所以不够用时需要扩展一个新的动态数组 this._expandData(); data = this.data; } for (var i = 0; i < arguments.length; i++) { data[this._len++] = arguments[i]; } this._prevCmd = cmd; }, _expandData: function () { // Only if data is Float32Array if (!(this.data instanceof Array)) { var newData = []; for (var i = 0; i < this._len; i++) { newData[i] = this.data[i]; } this.data = newData; } }, /** * If needs js implemented dashed line * @return {boolean} * @private */ _needsDash: function () { return this._lineDash; }, _dashedLineTo: function (x1, y1) { var dashSum = this._dashSum; var offset = this._dashOffset; var lineDash = this._lineDash; var ctx = this._ctx; var x0 = this._xi; var y0 = this._yi; var dx = x1 - x0; var dy = y1 - y0; var dist = mathSqrt(dx * dx + dy * dy); var x = x0; var y = y0; var dash; var nDash = lineDash.length; var idx; dx /= dist; dy /= dist; if (offset < 0) { // Convert to positive offset offset = dashSum + offset; } offset %= dashSum; x -= offset * dx; y -= offset * dy; while ((dx > 0 && x 0 && y 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) { continue; } ctx[idx % 2 ? 'moveTo' : 'lineTo']( dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1) ); } // Offset for next lineTo dx = x - x1; dy = y - y1; this._dashOffset = -mathSqrt(dx * dx + dy * dy); }, // Not accurate dashed line to _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) { var dashSum = this._dashSum; var offset = this._dashOffset; var lineDash = this._lineDash; var ctx = this._ctx; var x0 = this._xi; var y0 = this._yi; var t; var dx; var dy; var cubicAt = curve.cubicAt; var bezierLen = 0; var idx = this._dashIdx; var nDash = lineDash.length; var x; var y; var tmpLen = 0; if (offset < 0) { // Convert to positive offset offset = dashSum + offset; } offset %= dashSum; // Bezier approx length for (t = 0; t < 1; t += 0.1) { dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t); dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t); bezierLen += mathSqrt(dx * dx + dy * dy); } // Find idx after add offset for (; idx < nDash; idx++) { tmpLen += lineDash[idx]; if (tmpLen > offset) { break; } } t = (tmpLen - offset) / bezierLen; while (t uy || i === len - 1) { ctx.lineTo(x, y); xi = x; yi = y; } break; case CMD.C: ctx.bezierCurveTo( d[i++], d[i++], d[i++], d[i++], d[i++], d[i++] ); xi = d[i - 2]; yi = d[i - 1]; break; case CMD.Q: ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]); xi = d[i - 2]; yi = d[i - 1]; break; case CMD.A: var cx = d[i++]; var cy = d[i++]; var rx = d[i++]; var ry = d[i++]; var theta = d[i++]; var dTheta = d[i++]; var psi = d[i++]; var fs = d[i++]; var r = (rx > ry) ? rx : ry; var scaleX = (rx > ry) ? 1 : rx / ry; var scaleY = (rx > ry) ? ry / rx : 1; var isEllipse = Math.abs(rx - ry) > 1e-3; var endAngle = theta + dTheta; if (isEllipse) { ctx.translate(cx, cy); ctx.rotate(psi); ctx.scale(scaleX, scaleY); ctx.arc(0, 0, r, theta, endAngle, 1 - fs); ctx.scale(1 / scaleX, 1 / scaleY); ctx.rotate(-psi); ctx.translate(-cx, -cy); } else { ctx.arc(cx, cy, r, theta, endAngle, 1 - fs); } if (i == 1) { // 直接使用 arc 命令 // 第一个命令起点还未定义 x0 = mathCos(theta) * rx + cx; y0 = mathSin(theta) * ry + cy; } xi = mathCos(endAngle) * rx + cx; yi = mathSin(endAngle) * ry + cy; break; case CMD.R: x0 = xi = d[i]; y0 = yi = d[i + 1]; ctx.rect(d[i++], d[i++], d[i++], d[i++]); break; case CMD.Z: ctx.closePath(); xi = x0; yi = y0; } } } }; PathProxy.CMD = CMD; module.exports = PathProxy; /***/ }), /* 40 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; /** * 曲线辅助模块 * @module zrender/core/curve * @author pissang(https://www.github.com/pissang) */ var vec2 = __webpack_require__(10); var v2Create = vec2.create; var v2DistSquare = vec2.distSquare; var mathPow = Math.pow; var mathSqrt = Math.sqrt; var EPSILON = 1e-8; var EPSILON_NUMERIC = 1e-4; var THREE_SQRT = mathSqrt(3); var ONE_THIRD = 1 / 3; // 临时变量 var _v0 = v2Create(); var _v1 = v2Create(); var _v2 = v2Create(); // var _v3 = vec2.create(); function isAroundZero(val) { return val > -EPSILON && val < EPSILON; } function isNotAroundZero(val) { return val > EPSILON || val < -EPSILON; } /** * 计算三次贝塞尔值 * @memberOf module:zrender/core/curve * @param {number} p0 * @param {number} p1 * @param {number} p2 * @param {number} p3 * @param {number} t * @return {number} */ function cubicAt(p0, p1, p2, p3, t) { var onet = 1 - t; return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2); } /** * 计算三次贝塞尔导数值 * @memberOf module:zrender/core/curve * @param {number} p0 * @param {number} p1 * @param {number} p2 * @param {number} p3 * @param {number} t * @return {number} */ function cubicDerivativeAt(p0, p1, p2, p3, t) { var onet = 1 - t; return 3 * ( ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t ); } /** * 计算三次贝塞尔方程根，使用盛金公式 * @memberOf module:zrender/core/curve * @param {number} p0 * @param {number} p1 * @param {number} p2 * @param {number} p3 * @param {number} val * @param {Array.} roots * @return {number} 有效根数目 */ function cubicRootAt(p0, p1, p2, p3, val, roots) { // Evaluate roots of cubic functions var a = p3 + 3 * (p1 - p2) - p0; var b = 3 * (p2 - p1 * 2 + p0); var c = 3 * (p1 - p0); var d = p0 - val; var A = b * b - 3 * a * c; var B = b * c - 9 * a * d; var C = c * c - 3 * b * d; var n = 0; if (isAroundZero(A) && isAroundZero(B)) { if (isAroundZero(b)) { roots[0] = 0; } else { var t1 = -c / b; //t1, t2, t3, b is not zero if (t1 >= 0 && t1 = 0 && t1 = 0 && t2 0) { var discSqrt = mathSqrt(disc); var Y1 = A * b + 1.5 * a * (-B + discSqrt); var Y2 = A * b + 1.5 * a * (-B - discSqrt); if (Y1 < 0) { Y1 = -mathPow(-Y1, ONE_THIRD); } else { Y1 = mathPow(Y1, ONE_THIRD); } if (Y2 < 0) { Y2 = -mathPow(-Y2, ONE_THIRD); } else { Y2 = mathPow(Y2, ONE_THIRD); } var t1 = (-b - (Y1 + Y2)) / (3 * a); if (t1 >= 0 && t1 = 0 && t1 = 0 && t2 = 0 && t3 = 0 && t1 0) { var discSqrt = mathSqrt(disc); var t1 = (-b + discSqrt) / (2 * a); var t2 = (-b - discSqrt) / (2 * a); if (t1 >= 0 && t1 = 0 && t2 = 0 && d1 < d) { t = prev; d = d1; } else { // t + interval _v2[0] = cubicAt(x0, x1, x2, x3, next); _v2[1] = cubicAt(y0, y1, y2, y3, next); d2 = v2DistSquare(_v2, _v0); if (next = 0 && t1 = 0 && t2 = 0 && d1 < d) { t = prev; d = d1; } else { // t + interval _v2[0] = quadraticAt(x0, x1, x2, next); _v2[1] = quadraticAt(y0, y1, y2, next); var d2 = v2DistSquare(_v2, _v0); if (next endAngle && !anticlockwise) { endAngle += PI2; } else if (startAngle < endAngle && anticlockwise) { startAngle += PI2; } if (anticlockwise) { var tmp = endAngle; endAngle = startAngle; startAngle = tmp; } // var number = 0; // var step = (anticlockwise ? -Math.PI : Math.PI) / 2; for (var angle = 0; angle < endAngle; angle += Math.PI / 2) { if (angle > startAngle) { extremity[0] = mathCos(angle) * rx + x; extremity[1] = mathSin(angle) * ry + y; vec2Min(min, extremity, min); vec2Max(max, extremity, max); } } }; module.exports = bbox; /***/ }), /* 42 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var CMD = __webpack_require__(39).CMD; var line = __webpack_require__(43); var cubic = __webpack_require__(44); var quadratic = __webpack_require__(45); var arc = __webpack_require__(46); var normalizeRadian = __webpack_require__(47).normalizeRadian; var curve = __webpack_require__(40); var windingLine = __webpack_require__(48); var containStroke = line.containStroke; var PI2 = Math.PI * 2; var EPSILON = 1e-4; function isAroundEqual(a, b) { return Math.abs(a - b) < EPSILON; } // 临时数组 var roots = [-1, -1, -1]; var extrema = [-1, -1]; function swapExtrema() { var tmp = extrema[0]; extrema[0] = extrema[1]; extrema[1] = tmp; } function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) { // Quick reject if ( (y > y0 && y > y1 && y > y2 && y > y3) || (y < y0 && y < y1 && y < y2 && y < y3) ) { return 0; } var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots); if (nRoots === 0) { return 0; } else { var w = 0; var nExtrema = -1; var y0_, y1_; for (var i = 0; i < nRoots; i++) { var t = roots[i]; // Avoid winding error when intersection point is the connect point of two line of polygon var unit = (t === 0 || t === 1) ? 0.5 : 1; var x_ = curve.cubicAt(x0, x1, x2, x3, t); if (x_ < x) { // Quick reject continue; } if (nExtrema < 0) { nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema); if (extrema[1] < extrema[0] && nExtrema > 1) { swapExtrema(); } y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]); if (nExtrema > 1) { y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]); } } if (nExtrema == 2) { // 分成三段单调函数 if (t < extrema[0]) { w += y0_ < y0 ? unit : -unit; } else if (t < extrema[1]) { w += y1_ < y0_ ? unit : -unit; } else { w += y3 < y1_ ? unit : -unit; } } else { // 分成两段单调函数 if (t < extrema[0]) { w += y0_ < y0 ? unit : -unit; } else { w += y3 < y0_ ? unit : -unit; } } } return w; } } function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) { // Quick reject if ( (y > y0 && y > y1 && y > y2) || (y < y0 && y < y1 && y < y2) ) { return 0; } var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots); if (nRoots === 0) { return 0; } else { var t = curve.quadraticExtremum(y0, y1, y2); if (t >= 0 && t = roots[0] + cx && x endAngle) { endAngle += PI2; } var w = 0; for (var i = 0; i < 2; i++) { var x_ = roots[i]; if (x_ + cx > x) { var angle = Math.atan2(y, x_); var dir = anticlockwise ? 1 : -1; if (angle < 0) { angle = PI2 + angle; } if ( (angle >= startAngle && angle = startAngle && angle + PI2 Math.PI / 2 && angle < Math.PI * 1.5) { dir = -dir; } w += dir; } } } return w; } function containPath(data, lineWidth, isStroke, x, y) { var w = 0; var xi = 0; var yi = 0; var x0 = 0; var y0 = 0; for (var i = 0; i < data.length;) { var cmd = data[i++]; // Begin a new subpath if (cmd === CMD.M && i > 1) { // Close previous subpath if (!isStroke) { w += windingLine(xi, yi, x0, y0, x, y); } // 如果被任何一个 subpath 包含 // if (w !== 0) { // return true; // } } if (i == 1) { // 如果第一个命令是 L, C, Q // 则 previous point 同绘制命令的第一个 point // // 第一个命令为 Arc 的情况下会在后面特殊处理 xi = data[i]; yi = data[i + 1]; x0 = xi; y0 = yi; } switch (cmd) { case CMD.M: // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点 // 在 closePath 的时候使用 x0 = data[i++]; y0 = data[i++]; xi = x0; yi = y0; break; case CMD.L: if (isStroke) { if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) { return true; } } else { // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0; } xi = data[i++]; yi = data[i++]; break; case CMD.C: if (isStroke) { if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y )) { return true; } } else { w += windingCubic( xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y ) || 0; } xi = data[i++]; yi = data[i++]; break; case CMD.Q: if (isStroke) { if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y )) { return true; } } else { w += windingQuadratic( xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y ) || 0; } xi = data[i++]; yi = data[i++]; break; case CMD.A: // TODO Arc 判断的开销比较大 var cx = data[i++]; var cy = data[i++]; var rx = data[i++]; var ry = data[i++]; var theta = data[i++]; var dTheta = data[i++]; // TODO Arc 旋转 var psi = data[i++]; var anticlockwise = 1 - data[i++]; var x1 = Math.cos(theta) * rx + cx; var y1 = Math.sin(theta) * ry + cy; // 不是直接使用 arc 命令 if (i > 1) { w += windingLine(xi, yi, x1, y1, x, y); } else { // 第一个命令起点还未定义 x0 = x1; y0 = y1; } // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放 var _x = (x - cx) * ry / rx + cx; if (isStroke) { if (arc.containStroke( cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y )) { return true; } } else { w += windingArc( cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y ); } xi = Math.cos(theta + dTheta) * rx + cx; yi = Math.sin(theta + dTheta) * ry + cy; break; case CMD.R: x0 = xi = data[i++]; y0 = yi = data[i++]; var width = data[i++]; var height = data[i++]; var x1 = x0 + width; var y1 = y0 + height; if (isStroke) { if (containStroke(x0, y0, x1, y0, lineWidth, x, y) || containStroke(x1, y0, x1, y1, lineWidth, x, y) || containStroke(x1, y1, x0, y1, lineWidth, x, y) || containStroke(x0, y1, x0, y0, lineWidth, x, y) ) { return true; } } else { // FIXME Clockwise ? w += windingLine(x1, y0, x1, y1, x, y); w += windingLine(x0, y1, x0, y0, x, y); } break; case CMD.Z: if (isStroke) { if (containStroke( xi, yi, x0, y0, lineWidth, x, y )) { return true; } } else { // Close a subpath w += windingLine(xi, yi, x0, y0, x, y); // 如果被任何一个 subpath 包含 // FIXME subpaths may overlap // if (w !== 0) { // return true; // } } xi = x0; yi = y0; break; } } if (!isStroke && !isAroundEqual(yi, y0)) { w += windingLine(xi, yi, x0, y0, x, y) || 0; } return w !== 0; } module.exports = { contain: function (pathData, x, y) { return containPath(pathData, 0, false, x, y); }, containStroke: function (pathData, lineWidth, x, y) { return containPath(pathData, lineWidth, true, x, y); } }; /***/ }), /* 43 */ /***/ (function(module, exports) { module.exports = { /** * 线段包含判断 * @param {number} x0 * @param {number} y0 * @param {number} x1 * @param {number} y1 * @param {number} lineWidth * @param {number} x * @param {number} y * @return {boolean} */ containStroke: function (x0, y0, x1, y1, lineWidth, x, y) { if (lineWidth === 0) { return false; } var _l = lineWidth; var _a = 0; var _b = x0; // Quick reject if ( (y > y0 + _l && y > y1 + _l) || (y < y0 - _l && y < y1 - _l) || (x > x0 + _l && x > x1 + _l) || (x < x0 - _l && x < x1 - _l) ) { return false; } if (x0 !== x1) { _a = (y0 - y1) / (x0 - x1); _b = (x0 * y1 - x1 * y0) / (x0 - x1) ; } else { return Math.abs(x - x0) y1 + _l && y > y2 + _l && y > y3 + _l) || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l) || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l) || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) ) { return false; } var d = curve.cubicProjectPoint( x0, y0, x1, y1, x2, y2, x3, y3, x, y, null ); return d y0 + _l && y > y1 + _l && y > y2 + _l) || (y < y0 - _l && y < y1 - _l && y < y2 - _l) || (x > x0 + _l && x > x1 + _l && x > x2 + _l) || (x < x0 - _l && x < x1 - _l && x < x2 - _l) ) { return false; } var d = curve.quadraticProjectPoint( x0, y0, x1, y1, x2, y2, x, y, null ); return d r) || (d + _l < r)) { return false; } if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) { // Is a circle return true; } if (anticlockwise) { var tmp = startAngle; startAngle = normalizeRadian(endAngle); endAngle = normalizeRadian(tmp); } else { startAngle = normalizeRadian(startAngle); endAngle = normalizeRadian(endAngle); } if (startAngle > endAngle) { endAngle += PI2; } var angle = Math.atan2(y, x); if (angle < 0) { angle += PI2; } return (angle >= startAngle && angle = startAngle && angle + PI2 y1) || (y < y0 && y < y1)) { return 0; } // Ignore horizontal line if (y1 === y0) { return 0; } var dir = y1 < y0 ? 1 : -1; var t = (y - y0) / (y1 - y0); // Avoid winding error when intersection point is the connect point of two line of polygon if (t === 1 || t === 0) { dir = y1 < y0 ? 0.5 : -0.5; } var x_ = t * (x1 - x0) + x0; return x_ > x ? dir : 0; }; /***/ }), /* 49 */ /***/ (function(module, exports) { var Pattern = function (image, repeat) { // Should do nothing more in this constructor. Because gradient can be // declard by `color: {image: ...}`, where this constructor will not be called. this.image = image; this.repeat = repeat; // Can be cloned this.type = 'pattern'; }; Pattern.prototype.getCanvasPattern = function (ctx) { return ctx.createPattern(this.image, this.repeat || 'repeat'); }; module.exports = Pattern; /***/ }), /* 50 */ /***/ (function(module, exports, __webpack_require__) { var CMD = __webpack_require__(39).CMD; var vec2 = __webpack_require__(10); var v2ApplyTransform = vec2.applyTransform; var points = [[], [], []]; var mathSqrt = Math.sqrt; var mathAtan2 = Math.atan2; function transformPath(path, m) { var data = path.data; var cmd; var nPoint; var i; var j; var k; var p; var M = CMD.M; var C = CMD.C; var L = CMD.L; var R = CMD.R; var A = CMD.A; var Q = CMD.Q; for (i = 0, j = 0; i < data.length;) { cmd = data[i++]; j = i; nPoint = 0; switch (cmd) { case M: nPoint = 1; break; case L: nPoint = 1; break; case C: nPoint = 3; break; case Q: nPoint = 2; break; case A: var x = m[4]; var y = m[5]; var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]); var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]); var angle = mathAtan2(-m[1] / sy, m[0] / sx); // cx data[i] *= sx; data[i++] += x; // cy data[i] *= sy; data[i++] += y; // Scale rx and ry // FIXME Assume psi is 0 here data[i++] *= sx; data[i++] *= sy; // Start angle data[i++] += angle; // end angle data[i++] += angle; // FIXME psi i += 2; j = i; break; case R: // x0, y0 p[0] = data[i++]; p[1] = data[i++]; v2ApplyTransform(p, p, m); data[j++] = p[0]; data[j++] = p[1]; // x1, y1 p[0] += data[i++]; p[1] += data[i++]; v2ApplyTransform(p, p, m); data[j++] = p[0]; data[j++] = p[1]; } for (k = 0; k < nPoint; k++) { var p = points[k]; p[0] = data[i++]; p[1] = data[i++]; v2ApplyTransform(p, p, m); // Write back data[j++] = p[0]; data[j++] = p[1]; } } } module.exports = transformPath; /***/ }), /* 51 */ /***/ (function(module, exports, __webpack_require__) { /** * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上 * @module zrender/graphic/Group * @example * var Group = require('zrender/lib/container/Group'); * var Circle = require('zrender/lib/graphic/shape/Circle'); * var g = new Group(); * g.position[0] = 100; * g.position[1] = 100; * g.add(new Circle({ * style: { * x: 100, * y: 100, * r: 20, * } * })); * zr.add(g); */ var zrUtil = __webpack_require__(4); var Element = __webpack_require__(25); var BoundingRect = __webpack_require__(9); /** * @alias module:zrender/graphic/Group * @constructor * @extends module:zrender/mixin/Transformable * @extends module:zrender/mixin/Eventful */ var Group = function (opts) { opts = opts || {}; Element.call(this, opts); for (var key in opts) { if (opts.hasOwnProperty(key)) { this[key] = opts[key]; } } this._children = []; this.__storage = null; this.__dirty = true; }; Group.prototype = { constructor: Group, isGroup: true, /** * @type {string} */ type: 'group', /** * 所有子孙元素是否响应鼠标事件 * @name module:/zrender/container/Group#silent * @type {boolean} * @default false */ silent: false, /** * @return {Array.} */ children: function () { return this._children.slice(); }, /** * 获取指定 index 的儿子节点 * @param {number} idx * @return {module:zrender/Element} */ childAt: function (idx) { return this._children[idx]; }, /** * 获取指定名字的儿子节点 * @param {string} name * @return {module:zrender/Element} */ childOfName: function (name) { var children = this._children; for (var i = 0; i < children.length; i++) { if (children[i].name === name) { return children[i]; } } }, /** * @return {number} */ childCount: function () { return this._children.length; }, /** * 添加子节点到最后 * @param {module:zrender/Element} child */ add: function (child) { if (child && child !== this && child.parent !== this) { this._children.push(child); this._doAdd(child); } return this; }, /** * 添加子节点在 nextSibling 之前 * @param {module:zrender/Element} child * @param {module:zrender/Element} nextSibling */ addBefore: function (child, nextSibling) { if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) { var children = this._children; var idx = children.indexOf(nextSibling); if (idx >= 0) { children.splice(idx, 0, child); this._doAdd(child); } } return this; }, _doAdd: function (child) { if (child.parent) { child.parent.remove(child); } child.parent = this; var storage = this.__storage; var zr = this.__zr; if (storage && storage !== child.__storage) { storage.addToStorage(child); if (child instanceof Group) { child.addChildrenToStorage(storage); } } zr && zr.refresh(); }, /** * 移除子节点 * @param {module:zrender/Element} child */ remove: function (child) { var zr = this.__zr; var storage = this.__storage; var children = this._children; var idx = zrUtil.indexOf(children, child); if (idx < 0) { return this; } children.splice(idx, 1); child.parent = null; if (storage) { storage.delFromStorage(child); if (child instanceof Group) { child.delChildrenFromStorage(storage); } } zr && zr.refresh(); return this; }, /** * 移除所有子节点 */ removeAll: function () { var children = this._children; var storage = this.__storage; var child; var i; for (i = 0; i < children.length; i++) { child = children[i]; if (storage) { storage.delFromStorage(child); if (child instanceof Group) { child.delChildrenFromStorage(storage); } } child.parent = null; } children.length = 0; return this; }, /** * 遍历所有子节点 * @param {Function} cb * @param {} context */ eachChild: function (cb, context) { var children = this._children; for (var i = 0; i < children.length; i++) { var child = children[i]; cb.call(context, child, i); } return this; }, /** * 深度优先遍历所有子孙节点 * @param {Function} cb * @param {} context */ traverse: function (cb, context) { for (var i = 0; i < this._children.length; i++) { var child = this._children[i]; cb.call(context, child); if (child.type === 'group') { child.traverse(cb, context); } } return this; }, addChildrenToStorage: function (storage) { for (var i = 0; i < this._children.length; i++) { var child = this._children[i]; storage.addToStorage(child); if (child instanceof Group) { child.addChildrenToStorage(storage); } } }, delChildrenFromStorage: function (storage) { for (var i = 0; i < this._children.length; i++) { var child = this._children[i]; storage.delFromStorage(child); if (child instanceof Group) { child.delChildrenFromStorage(storage); } } }, dirty: function () { this.__dirty = true; this.__zr && this.__zr.refresh(); return this; }, /** * @return {module:zrender/core/BoundingRect} */ getBoundingRect: function (includeChildren) { // TODO Caching var rect = null; var tmpRect = new BoundingRect(0, 0, 0, 0); var children = includeChildren || this._children; var tmpMat = []; for (var i = 0; i < children.length; i++) { var child = children[i]; if (child.ignore || child.invisible) { continue; } var childRect = child.getBoundingRect(); var transform = child.getLocalTransform(tmpMat); // TODO // The boundingRect cacluated by transforming original // rect may be bigger than the actual bundingRect when rotation // is used. (Consider a circle rotated aginst its center, where // the actual boundingRect should be the same as that not be // rotated.) But we can not find better approach to calculate // actual boundingRect yet, considering performance. if (transform) { tmpRect.copy(childRect); tmpRect.applyTransform(transform); rect = rect || tmpRect.clone(); rect.union(tmpRect); } else { rect = rect || childRect.clone(); rect.union(childRect); } } return rect || tmpRect; } }; zrUtil.inherits(Group, Element); module.exports = Group; /***/ }), /* 52 */ /***/ (function(module, exports, __webpack_require__) { /** * Image element * @module zrender/graphic/Image */ var Displayable = __webpack_require__(23); var BoundingRect = __webpack_require__(9); var zrUtil = __webpack_require__(4); var imageHelper = __webpack_require__(12); /** * @alias zrender/graphic/Image * @extends module:zrender/graphic/Displayable * @constructor * @param {Object} opts */ function ZImage(opts) { Displayable.call(this, opts); } ZImage.prototype = { constructor: ZImage, type: 'image', brush: function (ctx, prevEl) { var style = this.style; var src = style.image; // Must bind each time style.bind(ctx, this, prevEl); var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this); if (!image || !imageHelper.isImageReady(image)) { return; } // 图片已经加载完成 // if (image.nodeName.toUpperCase() == 'IMG') { // if (!image.complete) { // return; // } // } // Else is canvas var x = style.x || 0; var y = style.y || 0; var width = style.width; var height = style.height; var aspect = image.width / image.height; if (width == null && height != null) { // Keep image/height ratio width = height * aspect; } else if (height == null && width != null) { height = width / aspect; } else if (width == null && height == null) { width = image.width; height = image.height; } // 设置transform this.setTransform(ctx); if (style.sWidth && style.sHeight) { var sx = style.sx || 0; var sy = style.sy || 0; ctx.drawImage( image, sx, sy, style.sWidth, style.sHeight, x, y, width, height ); } else if (style.sx && style.sy) { var sx = style.sx; var sy = style.sy; var sWidth = width - sx; var sHeight = height - sy; ctx.drawImage( image, sx, sy, sWidth, sHeight, x, y, width, height ); } else { ctx.drawImage(image, x, y, width, height); } this.restoreTransform(ctx); // Draw rect text if (style.text != null) { this.drawRectText(ctx, this.getBoundingRect()); } }, getBoundingRect: function () { var style = this.style; if (! this._rect) { this._rect = new BoundingRect( style.x || 0, style.y || 0, style.width || 0, style.height || 0 ); } return this._rect; } }; zrUtil.inherits(ZImage, Displayable); module.exports = ZImage; /***/ }), /* 53 */ /***/ (function(module, exports, __webpack_require__) { /** * Text element * @module zrender/graphic/Text * * TODO Wrapping * * Text not support gradient */ var Displayable = __webpack_require__(23); var zrUtil = __webpack_require__(4); var textContain = __webpack_require__(8); var textHelper = __webpack_require__(37); /** * @alias zrender/graphic/Text * @extends module:zrender/graphic/Displayable * @constructor * @param {Object} opts */ var Text = function (opts) { Displayable.call(this, opts); }; Text.prototype = { constructor: Text, type: 'text', brush: function (ctx, prevEl) { var style = this.style; // Optimize, avoid normalize every time. this.__dirty && textHelper.normalizeTextStyle(style, true); // Use props with prefix 'text'. style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null; var text = style.text; // Convert to string text != null && (text += ''); // Always bind style style.bind(ctx, this, prevEl); if (!textHelper.needDrawText(text, style)) { return; } this.setTransform(ctx); textHelper.renderText(this, ctx, text, style); this.restoreTransform(ctx); }, getBoundingRect: function () { var style = this.style; // Optimize, avoid normalize every time. this.__dirty && textHelper.normalizeTextStyle(style, true); if (!this._rect) { var text = style.text; text != null ? (text += '') : (text = ''); var rect = textContain.getBoundingRect( style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.rich ); rect.x += style.x || 0; rect.y += style.y || 0; if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) { var w = style.textStrokeWidth; rect.x -= w / 2; rect.y -= w / 2; rect.width += w; rect.height += w; } this._rect = rect; } return this._rect; } }; zrUtil.inherits(Text, Displayable); module.exports = Text; /***/ }), /* 54 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; /** * 圆形 * @module zrender/shape/Circle */ module.exports = __webpack_require__(22).extend({ type: 'circle', shape: { cx: 0, cy: 0, r: 0 }, buildPath : function (ctx, shape, inBundle) { // Better stroking in ShapeBundle // Always do it may have performence issue ( fill may be 2x more cost) if (inBundle) { ctx.moveTo(shape.cx + shape.r, shape.cy); } // else { // if (ctx.allocate && !ctx.data.length) { // ctx.allocate(ctx.CMD_MEM_SIZE.A); // } // } // Better stroking in ShapeBundle // ctx.moveTo(shape.cx + shape.r, shape.cy); ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true); } }); /***/ }), /* 55 */ /***/ (function(module, exports, __webpack_require__) { /** * 扇形 * @module zrender/graphic/shape/Sector */ var Path = __webpack_require__(22); var fixClipWithShadow = __webpack_require__(56); module.exports = Path.extend({ type: 'sector', shape: { cx: 0, cy: 0, r0: 0, r: 0, startAngle: 0, endAngle: Math.PI * 2, clockwise: true }, brush: fixClipWithShadow(Path.prototype.brush), buildPath: function (ctx, shape) { var x = shape.cx; var y = shape.cy; var r0 = Math.max(shape.r0 || 0, 0); var r = Math.max(shape.r, 0); var startAngle = shape.startAngle; var endAngle = shape.endAngle; var clockwise = shape.clockwise; var unitX = Math.cos(startAngle); var unitY = Math.sin(startAngle); ctx.moveTo(unitX * r0 + x, unitY * r0 + y); ctx.lineTo(unitX * r + x, unitY * r + y); ctx.arc(x, y, r, startAngle, endAngle, !clockwise); ctx.lineTo( Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y ); if (r0 !== 0) { ctx.arc(x, y, r0, endAngle, startAngle, clockwise); } ctx.closePath(); } }); /***/ }), /* 56 */ /***/ (function(module, exports, __webpack_require__) { var env = __webpack_require__(2); // Fix weird bug in some version of IE11 (like 11.0.9600.178**), // where exception \"unexpected call to method or property access\" // might be thrown when calling ctx.fill or ctx.stroke after a path // whose area size is zero is drawn and ctx.clip() is called and // shadowBlur is set. See #4572, #3112, #5777. // (e.g., // ctx.moveTo(10, 10); // ctx.lineTo(20, 10); // ctx.closePath(); // ctx.clip(); // ctx.shadowBlur = 10; // ... // ctx.fill(); // ) var shadowTemp = [ ['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0] ]; module.exports = function (orignalBrush) { // version string can be: '11.0' return (env.browser.ie && env.browser.version >= 11) ? function () { var clipPaths = this.__clipPaths; var style = this.style; var modified; if (clipPaths) { for (var i = 0; i < clipPaths.length; i++) { var clipPath = clipPaths[i]; var shape = clipPath && clipPath.shape; var type = clipPath && clipPath.type; if (shape && ( (type === 'sector' && shape.startAngle === shape.endAngle) || (type === 'rect' && (!shape.width || !shape.height)) )) { for (var j = 0; j < shadowTemp.length; j++) { // It is save to put shadowTemp static, because shadowTemp // will be all modified each item brush called. shadowTemp[j][2] = style[shadowTemp[j][0]]; style[shadowTemp[j][0]] = shadowTemp[j][1]; } modified = true; break; } } } orignalBrush.apply(this, arguments); if (modified) { for (var j = 0; j < shadowTemp.length; j++) { style[shadowTemp[j][0]] = shadowTemp[j][2]; } } } : orignalBrush; }; /***/ }), /* 57 */ /***/ (function(module, exports, __webpack_require__) { /** * 圆环 * @module zrender/graphic/shape/Ring */ module.exports = __webpack_require__(22).extend({ type: 'ring', shape: { cx: 0, cy: 0, r: 0, r0: 0 }, buildPath: function (ctx, shape) { var x = shape.cx; var y = shape.cy; var PI2 = Math.PI * 2; ctx.moveTo(x + shape.r, y); ctx.arc(x, y, shape.r, 0, PI2, false); ctx.moveTo(x + shape.r0, y); ctx.arc(x, y, shape.r0, 0, PI2, true); } }); /***/ }), /* 58 */ /***/ (function(module, exports, __webpack_require__) { /** * 多边形 * @module zrender/shape/Polygon */ var polyHelper = __webpack_require__(59); module.exports = __webpack_require__(22).extend({ type: 'polygon', shape: { points: null, smooth: false, smoothConstraint: null }, buildPath: function (ctx, shape) { polyHelper.buildPath(ctx, shape, true); } }); /***/ }), /* 59 */ /***/ (function(module, exports, __webpack_require__) { var smoothSpline = __webpack_require__(60); var smoothBezier = __webpack_require__(61); module.exports = { buildPath: function (ctx, shape, closePath) { var points = shape.points; var smooth = shape.smooth; if (points && points.length >= 2) { if (smooth && smooth !== 'spline') { var controlPoints = smoothBezier( points, smooth, closePath, shape.smoothConstraint ); ctx.moveTo(points[0][0], points[0][1]); var len = points.length; for (var i = 0; i < (closePath ? len : len - 1); i++) { var cp1 = controlPoints[i * 2]; var cp2 = controlPoints[i * 2 + 1]; var p = points[(i + 1) % len]; ctx.bezierCurveTo( cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1] ); } } else { if (smooth === 'spline') { points = smoothSpline(points, closePath); } ctx.moveTo(points[0][0], points[0][1]); for (var i = 1, l = points.length; i < l; i++) { ctx.lineTo(points[i][0], points[i][1]); } } closePath && ctx.closePath(); } } }; /***/ }), /* 60 */ /***/ (function(module, exports, __webpack_require__) { /** * Catmull-Rom spline 插值折线 * @module zrender/shape/util/smoothSpline * @author pissang (https://www.github.com/pissang) * Kener (@Kener-林峰, kener.linfeng@gmail.com) * errorrik (errorrik@gmail.com) */ var vec2 = __webpack_require__(10); /** * @inner */ function interpolate(p0, p1, p2, p3, t, t2, t3) { var v0 = (p2 - p0) * 0.5; var v1 = (p3 - p1) * 0.5; return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1; } /** * @alias module:zrender/shape/util/smoothSpline * @param {Array} points 线段顶点数组 * @param {boolean} isLoop * @return {Array} */ module.exports = function (points, isLoop) { var len = points.length; var ret = []; var distance = 0; for (var i = 1; i < len; i++) { distance += vec2.distance(points[i - 1], points[i]); } var segs = distance / 2; segs = segs < len ? len : segs; for (var i = 0; i < segs; i++) { var pos = i / (segs - 1) * (isLoop ? len : len - 1); var idx = Math.floor(pos); var w = pos - idx; var p0; var p1 = points[idx % len]; var p2; var p3; if (!isLoop) { p0 = points[idx === 0 ? idx : idx - 1]; p2 = points[idx > len - 2 ? len - 1 : idx + 1]; p3 = points[idx > len - 3 ? len - 1 : idx + 2]; } else { p0 = points[(idx - 1 + len) % len]; p2 = points[(idx + 1) % len]; p3 = points[(idx + 2) % len]; } var w2 = w * w; var w3 = w * w2; ret.push([ interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3) ]); } return ret; }; /***/ }), /* 61 */ /***/ (function(module, exports, __webpack_require__) { /** * 贝塞尔平滑曲线 * @module zrender/shape/util/smoothBezier * @author pissang (https://www.github.com/pissang) * Kener (@Kener-林峰, kener.linfeng@gmail.com) * errorrik (errorrik@gmail.com) */ var vec2 = __webpack_require__(10); var v2Min = vec2.min; var v2Max = vec2.max; var v2Scale = vec2.scale; var v2Distance = vec2.distance; var v2Add = vec2.add; /** * 贝塞尔平滑曲线 * @alias module:zrender/shape/util/smoothBezier * @param {Array} points 线段顶点数组 * @param {number} smooth 平滑等级, 0-1 * @param {boolean} isLoop * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内 * 比如 [[0, 0], [100, 100]], 这个包围盒会与 * 整个折线的包围盒做一个并集用来约束控制点。 * @param {Array} 计算出来的控制点数组 */ module.exports = function (points, smooth, isLoop, constraint) { var cps = []; var v = []; var v1 = []; var v2 = []; var prevPoint; var nextPoint; var min, max; if (constraint) { min = [Infinity, Infinity]; max = [-Infinity, -Infinity]; for (var i = 0, len = points.length; i < len; i++) { v2Min(min, min, points[i]); v2Max(max, max, points[i]); } // 与指定的包围盒做并集 v2Min(min, min, constraint[0]); v2Max(max, max, constraint[1]); } for (var i = 0, len = points.length; i < len; i++) { var point = points[i]; if (isLoop) { prevPoint = points[i ? i - 1 : len - 1]; nextPoint = points[(i + 1) % len]; } else { if (i === 0 || i === len - 1) { cps.push(vec2.clone(points[i])); continue; } else { prevPoint = points[i - 1]; nextPoint = points[i + 1]; } } vec2.sub(v, nextPoint, prevPoint); // use degree to scale the handle length v2Scale(v, v, smooth); var d0 = v2Distance(point, prevPoint); var d1 = v2Distance(point, nextPoint); var sum = d0 + d1; if (sum !== 0) { d0 /= sum; d1 /= sum; } v2Scale(v1, v, -d0); v2Scale(v2, v, d1); var cp0 = v2Add([], point, v1); var cp1 = v2Add([], point, v2); if (constraint) { v2Max(cp0, cp0, min); v2Min(cp0, cp0, max); v2Max(cp1, cp1, min); v2Min(cp1, cp1, max); } cps.push(cp0); cps.push(cp1); } if (isLoop) { cps.push(cps.shift()); } return cps; }; /***/ }), /* 62 */ /***/ (function(module, exports, __webpack_require__) { /** * @module zrender/graphic/shape/Polyline */ var polyHelper = __webpack_require__(59); module.exports = __webpack_require__(22).extend({ type: 'polyline', shape: { points: null, smooth: false, smoothConstraint: null }, style: { stroke: '#000', fill: null }, buildPath: function (ctx, shape) { polyHelper.buildPath(ctx, shape, false); } }); /***/ }), /* 63 */ /***/ (function(module, exports, __webpack_require__) { /** * 矩形 * @module zrender/graphic/shape/Rect */ var roundRectHelper = __webpack_require__(38); module.exports = __webpack_require__(22).extend({ type: 'rect', shape: { // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4 // r缩写为1 相当于 [1, 1, 1, 1] // r缩写为[1] 相当于 [1, 1, 1, 1] // r缩写为[1, 2] 相当于 [1, 2, 1, 2] // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2] r: 0, x: 0, y: 0, width: 0, height: 0 }, buildPath: function (ctx, shape) { var x = shape.x; var y = shape.y; var width = shape.width; var height = shape.height; if (!shape.r) { ctx.rect(x, y, width, height); } else { roundRectHelper.buildPath(ctx, shape); } ctx.closePath(); return; } }); /***/ }), /* 64 */ /***/ (function(module, exports, __webpack_require__) { /** * 直线 * @module zrender/graphic/shape/Line */ module.exports = __webpack_require__(22).extend({ type: 'line', shape: { // Start point x1: 0, y1: 0, // End point x2: 0, y2: 0, percent: 1 }, style: { stroke: '#000', fill: null }, buildPath: function (ctx, shape) { var x1 = shape.x1; var y1 = shape.y1; var x2 = shape.x2; var y2 = shape.y2; var percent = shape.percent; if (percent === 0) { return; } ctx.moveTo(x1, y1); if (percent < 1) { x2 = x1 * (1 - percent) + x2 * percent; y2 = y1 * (1 - percent) + y2 * percent; } ctx.lineTo(x2, y2); }, /** * Get point at percent * @param {number} percent * @return {Array.} */ pointAt: function (p) { var shape = this.shape; return [ shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p ]; } }); /***/ }), /* 65 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; /** * 贝塞尔曲线 * @module zrender/shape/BezierCurve */ var curveTool = __webpack_require__(40); var vec2 = __webpack_require__(10); var quadraticSubdivide = curveTool.quadraticSubdivide; var cubicSubdivide = curveTool.cubicSubdivide; var quadraticAt = curveTool.quadraticAt; var cubicAt = curveTool.cubicAt; var quadraticDerivativeAt = curveTool.quadraticDerivativeAt; var cubicDerivativeAt = curveTool.cubicDerivativeAt; var out = []; function someVectorAt(shape, t, isTangent) { var cpx2 = shape.cpx2; var cpy2 = shape.cpy2; if (cpx2 === null || cpy2 === null) { return [ (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t) ]; } else { return [ (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t) ]; } } module.exports = __webpack_require__(22).extend({ type: 'bezier-curve', shape: { x1: 0, y1: 0, x2: 0, y2: 0, cpx1: 0, cpy1: 0, // cpx2: 0, // cpy2: 0 // Curve show percent, for animating percent: 1 }, style: { stroke: '#000', fill: null }, buildPath: function (ctx, shape) { var x1 = shape.x1; var y1 = shape.y1; var x2 = shape.x2; var y2 = shape.y2; var cpx1 = shape.cpx1; var cpy1 = shape.cpy1; var cpx2 = shape.cpx2; var cpy2 = shape.cpy2; var percent = shape.percent; if (percent === 0) { return; } ctx.moveTo(x1, y1); if (cpx2 == null || cpy2 == null) { if (percent < 1) { quadraticSubdivide( x1, cpx1, x2, percent, out ); cpx1 = out[1]; x2 = out[2]; quadraticSubdivide( y1, cpy1, y2, percent, out ); cpy1 = out[1]; y2 = out[2]; } ctx.quadraticCurveTo( cpx1, cpy1, x2, y2 ); } else { if (percent < 1) { cubicSubdivide( x1, cpx1, cpx2, x2, percent, out ); cpx1 = out[1]; cpx2 = out[2]; x2 = out[3]; cubicSubdivide( y1, cpy1, cpy2, y2, percent, out ); cpy1 = out[1]; cpy2 = out[2]; y2 = out[3]; } ctx.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, x2, y2 ); } }, /** * Get point at percent * @param {number} t * @return {Array.} */ pointAt: function (t) { return someVectorAt(this.shape, t, false); }, /** * Get tangent at percent * @param {number} t * @return {Array.} */ tangentAt: function (t) { var p = someVectorAt(this.shape, t, true); return vec2.normalize(p, p); } }); /***/ }), /* 66 */ /***/ (function(module, exports, __webpack_require__) { /** * 圆弧 * @module zrender/graphic/shape/Arc */ module.exports = __webpack_require__(22).extend({ type: 'arc', shape: { cx: 0, cy: 0, r: 0, startAngle: 0, endAngle: Math.PI * 2, clockwise: true }, style: { stroke: '#000', fill: null }, buildPath: function (ctx, shape) { var x = shape.cx; var y = shape.cy; var r = Math.max(shape.r, 0); var startAngle = shape.startAngle; var endAngle = shape.endAngle; var clockwise = shape.clockwise; var unitX = Math.cos(startAngle); var unitY = Math.sin(startAngle); ctx.moveTo(unitX * r + x, unitY * r + y); ctx.arc(x, y, r, startAngle, endAngle, !clockwise); } }); /***/ }), /* 67 */ /***/ (function(module, exports, __webpack_require__) { // CompoundPath to improve performance var Path = __webpack_require__(22); module.exports = Path.extend({ type: 'compound', shape: { paths: null }, _updatePathDirty: function () { var dirtyPath = this.__dirtyPath; var paths = this.shape.paths; for (var i = 0; i < paths.length; i++) { // Mark as dirty if any subpath is dirty dirtyPath = dirtyPath || paths[i].__dirtyPath; } this.__dirtyPath = dirtyPath; this.__dirty = this.__dirty || dirtyPath; }, beforeBrush: function () { this._updatePathDirty(); var paths = this.shape.paths || []; var scale = this.getGlobalScale(); // Update path scale for (var i = 0; i < paths.length; i++) { if (!paths[i].path) { paths[i].createPathProxy(); } paths[i].path.setScale(scale[0], scale[1]); } }, buildPath: function (ctx, shape) { var paths = shape.paths || []; for (var i = 0; i < paths.length; i++) { paths[i].buildPath(ctx, paths[i].shape, true); } }, afterBrush: function () { var paths = this.shape.paths; for (var i = 0; i < paths.length; i++) { paths[i].__dirtyPath = false; } }, getBoundingRect: function () { this._updatePathDirty(); return Path.prototype.getBoundingRect.call(this); } }); /***/ }), /* 68 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var zrUtil = __webpack_require__(4); var Gradient = __webpack_require__(69); /** * x, y, x2, y2 are all percent from 0 to 1 * @param {number} [x=0] * @param {number} [y=0] * @param {number} [x2=1] * @param {number} [y2=0] * @param {Array.} colorStops * @param {boolean} [globalCoord=false] */ var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) { // Should do nothing more in this constructor. Because gradient can be // declard by `color: {type: 'linear', colorStops: ...}`, where // this constructor will not be called. this.x = x == null ? 0 : x; this.y = y == null ? 0 : y; this.x2 = x2 == null ? 1 : x2; this.y2 = y2 == null ? 0 : y2; // Can be cloned this.type = 'linear'; // If use global coord this.global = globalCoord || false; Gradient.call(this, colorStops); }; LinearGradient.prototype = { constructor: LinearGradient }; zrUtil.inherits(LinearGradient, Gradient); module.exports = LinearGradient; /***/ }), /* 69 */ /***/ (function(module, exports) { /** * @param {Array.} colorStops */ var Gradient = function (colorStops) { this.colorStops = colorStops || []; }; Gradient.prototype = { constructor: Gradient, addColorStop: function (offset, color) { this.colorStops.push({ offset: offset, color: color }); } }; module.exports = Gradient; /***/ }), /* 70 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var zrUtil = __webpack_require__(4); var Gradient = __webpack_require__(69); /** * x, y, r are all percent from 0 to 1 * @param {number} [x=0.5] * @param {number} [y=0.5] * @param {number} [r=0.5] * @param {Array.} [colorStops] * @param {boolean} [globalCoord=false] */ var RadialGradient = function (x, y, r, colorStops, globalCoord) { // Should do nothing more in this constructor. Because gradient can be // declard by `color: {type: 'radial', colorStops: ...}`, where // this constructor will not be called. this.x = x == null ? 0.5 : x; this.y = y == null ? 0.5 : y; this.r = r == null ? 0.5 : r; // Can be cloned this.type = 'radial'; // If use global coord this.global = globalCoord || false; Gradient.call(this, colorStops); }; RadialGradient.prototype = { constructor: RadialGradient }; zrUtil.inherits(RadialGradient, Gradient); module.exports = RadialGradient; /***/ }), /* 71 */ /***/ (function(module, exports, __webpack_require__) { var getItemStyle = __webpack_require__(17)( [ ['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'], ['textPosition'], ['textAlign'] ] ); module.exports = { getItemStyle: function (excludes, includes) { var style = getItemStyle.call(this, excludes, includes); var lineDash = this.getBorderLineDash(); lineDash && (style.lineDash = lineDash); return style; }, getBorderLineDash: function () { var lineType = this.get('borderType'); return (lineType === 'solid' || lineType == null) ? null : (lineType === 'dashed' ? [5, 5] : [1, 1]); } }; /***/ }), /* 72 */ /***/ (function(module, exports, __webpack_require__) { /** * Component model * * @module echarts/model/Component */ var Model = __webpack_require__(14); var zrUtil = __webpack_require__(4); var arrayPush = Array.prototype.push; var componentUtil = __webpack_require__(73); var clazzUtil = __webpack_require__(15); var layout = __webpack_require__(74); /** * @alias module:echarts/model/Component * @constructor * @param {Object} option * @param {module:echarts/model/Model} parentModel * @param {module:echarts/model/Model} ecModel */ var ComponentModel = Model.extend({ type: 'component', /** * @readOnly * @type {string} */ id: '', /** * @readOnly */ name: '', /** * @readOnly * @type {string} */ mainType: '', /** * @readOnly * @type {string} */ subType: '', /** * @readOnly * @type {number} */ componentIndex: 0, /** * @type {Object} * @protected */ defaultOption: null, /** * @type {module:echarts/model/Global} * @readOnly */ ecModel: null, /** * key: componentType * value: Component model list, can not be null. * @type {Object.} * @readOnly */ dependentModels: [], /** * @type {string} * @readOnly */ uid: null, /** * Support merge layout params. * Only support 'box' now (left/right/top/bottom/width/height). * @type {string|Object} Object can be {ignoreSize: true} * @readOnly */ layoutMode: null, $constructor: function (option, parentModel, ecModel, extraOpt) { Model.call(this, option, parentModel, ecModel, extraOpt); this.uid = componentUtil.getUID('componentModel'); }, init: function (option, parentModel, ecModel, extraOpt) { this.mergeDefaultAndTheme(option, ecModel); }, mergeDefaultAndTheme: function (option, ecModel) { var layoutMode = this.layoutMode; var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {}; var themeModel = ecModel.getTheme(); zrUtil.merge(option, themeModel.get(this.mainType)); zrUtil.merge(option, this.getDefaultOption()); if (layoutMode) { layout.mergeLayoutParam(option, inputPositionParams, layoutMode); } }, mergeOption: function (option, extraOpt) { zrUtil.merge(this.option, option, true); var layoutMode = this.layoutMode; if (layoutMode) { layout.mergeLayoutParam(this.option, option, layoutMode); } }, // Hooker after init or mergeOption optionUpdated: function (newCptOption, isInit) {}, getDefaultOption: function () { if (!clazzUtil.hasOwn(this, '__defaultOption')) { var optList = []; var Class = this.constructor; while (Class) { var opt = Class.prototype.defaultOption; opt && optList.push(opt); Class = Class.superClass; } var defaultOption = {}; for (var i = optList.length - 1; i >= 0; i--) { defaultOption = zrUtil.merge(defaultOption, optList[i], true); } clazzUtil.set(this, '__defaultOption', defaultOption); } return clazzUtil.get(this, '__defaultOption'); }, getReferringComponents: function (mainType) { return this.ecModel.queryComponents({ mainType: mainType, index: this.get(mainType + 'Index', true), id: this.get(mainType + 'Id', true) }); } }); // Reset ComponentModel.extend, add preConstruct. // clazzUtil.enableClassExtend( // ComponentModel, // function (option, parentModel, ecModel, extraOpt) { // // Set dependentModels, componentIndex, name, id, mainType, subType. // zrUtil.extend(this, extraOpt); // this.uid = componentUtil.getUID('componentModel'); // // this.setReadOnly([ // // 'type', 'id', 'uid', 'name', 'mainType', 'subType', // // 'dependentModels', 'componentIndex' // // ]); // } // ); // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on. clazzUtil.enableClassManagement( ComponentModel, {registerWhenExtend: true} ); componentUtil.enableSubTypeDefaulter(ComponentModel); // Add capability of ComponentModel.topologicalTravel. componentUtil.enableTopologicalTravel(ComponentModel, getDependencies); function getDependencies(componentType) { var deps = []; zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) { arrayPush.apply(deps, Clazz.prototype.dependencies || []); }); // Ensure main type return zrUtil.map(deps, function (type) { return clazzUtil.parseClassType(type).main; }); } zrUtil.mixin(ComponentModel, __webpack_require__(75)); module.exports = ComponentModel; /***/ }), /* 73 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); var clazz = __webpack_require__(15); var parseClassType = clazz.parseClassType; var base = 0; var componentUtil = {}; var DELIMITER = '_'; /** * @public * @param {string} type * @return {string} */ componentUtil.getUID = function (type) { // Considering the case of crossing js context, // use Math.random to make id as unique as possible. return [(type || ''), base++, Math.random()].join(DELIMITER); }; /** * @inner */ componentUtil.enableSubTypeDefaulter = function (entity) { var subTypeDefaulters = {}; entity.registerSubTypeDefaulter = function (componentType, defaulter) { componentType = parseClassType(componentType); subTypeDefaulters[componentType.main] = defaulter; }; entity.determineSubType = function (componentType, option) { var type = option.type; if (!type) { var componentTypeMain = parseClassType(componentType).main; if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) { type = subTypeDefaulters[componentTypeMain](option); } } return type; }; return entity; }; /** * Topological travel on Activity Network (Activity On Vertices). * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis']. * * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology. * * If there is circle dependencey, Error will be thrown. * */ componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) { /** * @public * @param {Array.} targetNameList Target Component type list. * Can be ['aa', 'bb', 'aa.xx'] * @param {Array.} fullNameList By which we can build dependency graph. * @param {Function} callback Params: componentType, dependencies. * @param {Object} context Scope of callback. */ entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) { if (!targetNameList.length) { return; } var result = makeDepndencyGraph(fullNameList); var graph = result.graph; var stack = result.noEntryList; var targetNameSet = {}; zrUtil.each(targetNameList, function (name) { targetNameSet[name] = true; }); while (stack.length) { var currComponentType = stack.pop(); var currVertex = graph[currComponentType]; var isInTargetNameSet = !!targetNameSet[currComponentType]; if (isInTargetNameSet) { callback.call(context, currComponentType, currVertex.originalDeps.slice()); delete targetNameSet[currComponentType]; } zrUtil.each( currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge ); } zrUtil.each(targetNameSet, function () { throw new Error('Circle dependency may exists'); }); function removeEdge(succComponentType) { graph[succComponentType].entryCount--; if (graph[succComponentType].entryCount === 0) { stack.push(succComponentType); } } // Consider this case: legend depends on series, and we call // chart.setOption({series: [...]}), where only series is in option. // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will // not be called, but only sereis.mergeOption is called. Thus legend // have no chance to update its local record about series (like which // name of series is available in legend). function removeEdgeAndAdd(succComponentType) { targetNameSet[succComponentType] = true; removeEdge(succComponentType); } }; /** * DepndencyGraph: {Object} * key: conponentType, * value: { * successor: [conponentTypes...], * originalDeps: [conponentTypes...], * entryCount: {number} * } */ function makeDepndencyGraph(fullNameList) { var graph = {}; var noEntryList = []; zrUtil.each(fullNameList, function (name) { var thisItem = createDependencyGraphItem(graph, name); var originalDeps = thisItem.originalDeps = dependencyGetter(name); var availableDeps = getAvailableDependencies(originalDeps, fullNameList); thisItem.entryCount = availableDeps.length; if (thisItem.entryCount === 0) { noEntryList.push(name); } zrUtil.each(availableDeps, function (dependentName) { if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) { thisItem.predecessor.push(dependentName); } var thatItem = createDependencyGraphItem(graph, dependentName); if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) { thatItem.successor.push(name); } }); }); return {graph: graph, noEntryList: noEntryList}; } function createDependencyGraphItem(graph, name) { if (!graph[name]) { graph[name] = {predecessor: [], successor: []}; } return graph[name]; } function getAvailableDependencies(originalDeps, fullNameList) { var availableDeps = []; zrUtil.each(originalDeps, function (dep) { zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep); }); return availableDeps; } }; module.exports = componentUtil; /***/ }), /* 74 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // Layout helpers for each component positioning var zrUtil = __webpack_require__(4); var BoundingRect = __webpack_require__(9); var numberUtil = __webpack_require__(7); var formatUtil = __webpack_require__(6); var parsePercent = numberUtil.parsePercent; var each = zrUtil.each; var layout = {}; /** * @public */ var LOCATION_PARAMS = layout.LOCATION_PARAMS = [ 'left', 'right', 'top', 'bottom', 'width', 'height' ]; /** * @public */ var HV_NAMES = layout.HV_NAMES = [ ['width', 'left', 'right'], ['height', 'top', 'bottom'] ]; function boxLayout(orient, group, gap, maxWidth, maxHeight) { var x = 0; var y = 0; if (maxWidth == null) { maxWidth = Infinity; } if (maxHeight == null) { maxHeight = Infinity; } var currentLineMaxSize = 0; group.eachChild(function (child, idx) { var position = child.position; var rect = child.getBoundingRect(); var nextChild = group.childAt(idx + 1); var nextChildRect = nextChild && nextChild.getBoundingRect(); var nextX; var nextY; if (orient === 'horizontal') { var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0); nextX = x + moveX; // Wrap when width exceeds maxWidth or meet a `newline` group // FIXME compare before adding gap? if (nextX > maxWidth || child.newline) { x = 0; nextX = moveX; y += currentLineMaxSize + gap; currentLineMaxSize = rect.height; } else { // FIXME: consider rect.y is not `0`? currentLineMaxSize = Math.max(currentLineMaxSize, rect.height); } } else { var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0); nextY = y + moveY; // Wrap when width exceeds maxHeight or meet a `newline` group if (nextY > maxHeight || child.newline) { x += currentLineMaxSize + gap; y = 0; nextY = moveY; currentLineMaxSize = rect.width; } else { currentLineMaxSize = Math.max(currentLineMaxSize, rect.width); } } if (child.newline) { return; } position[0] = x; position[1] = y; orient === 'horizontal' ? (x = nextX + gap) : (y = nextY + gap); }); } /** * VBox or HBox layouting * @param {string} orient * @param {module:zrender/container/Group} group * @param {number} gap * @param {number} [width=Infinity] * @param {number} [height=Infinity] */ layout.box = boxLayout; /** * VBox layouting * @param {module:zrender/container/Group} group * @param {number} gap * @param {number} [width=Infinity] * @param {number} [height=Infinity] */ layout.vbox = zrUtil.curry(boxLayout, 'vertical'); /** * HBox layouting * @param {module:zrender/container/Group} group * @param {number} gap * @param {number} [width=Infinity] * @param {number} [height=Infinity] */ layout.hbox = zrUtil.curry(boxLayout, 'horizontal'); /** * If x or x2 is not specified or 'center' 'left' 'right', * the width would be as long as possible. * If y or y2 is not specified or 'middle' 'top' 'bottom', * the height would be as long as possible. * * @param {Object} positionInfo * @param {number|string} [positionInfo.x] * @param {number|string} [positionInfo.y] * @param {number|string} [positionInfo.x2] * @param {number|string} [positionInfo.y2] * @param {Object} containerRect {width, height} * @param {string|number} margin * @return {Object} {width, height} */ layout.getAvailableSize = function (positionInfo, containerRect, margin) { var containerWidth = containerRect.width; var containerHeight = containerRect.height; var x = parsePercent(positionInfo.x, containerWidth); var y = parsePercent(positionInfo.y, containerHeight); var x2 = parsePercent(positionInfo.x2, containerWidth); var y2 = parsePercent(positionInfo.y2, containerHeight); (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0); (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth); (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0); (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight); margin = formatUtil.normalizeCssArray(margin || 0); return { width: Math.max(x2 - x - margin[1] - margin[3], 0), height: Math.max(y2 - y - margin[0] - margin[2], 0) }; }; /** * Parse position info. * * @param {Object} positionInfo * @param {number|string} [positionInfo.left] * @param {number|string} [positionInfo.top] * @param {number|string} [positionInfo.right] * @param {number|string} [positionInfo.bottom] * @param {number|string} [positionInfo.width] * @param {number|string} [positionInfo.height] * @param {number|string} [positionInfo.aspect] Aspect is width / height * @param {Object} containerRect * @param {string|number} [margin] * * @return {module:zrender/core/BoundingRect} */ layout.getLayoutRect = function ( positionInfo, containerRect, margin ) { margin = formatUtil.normalizeCssArray(margin || 0); var containerWidth = containerRect.width; var containerHeight = containerRect.height; var left = parsePercent(positionInfo.left, containerWidth); var top = parsePercent(positionInfo.top, containerHeight); var right = parsePercent(positionInfo.right, containerWidth); var bottom = parsePercent(positionInfo.bottom, containerHeight); var width = parsePercent(positionInfo.width, containerWidth); var height = parsePercent(positionInfo.height, containerHeight); var verticalMargin = margin[2] + margin[0]; var horizontalMargin = margin[1] + margin[3]; var aspect = positionInfo.aspect; // If width is not specified, calculate width from left and right if (isNaN(width)) { width = containerWidth - right - horizontalMargin - left; } if (isNaN(height)) { height = containerHeight - bottom - verticalMargin - top; } if (aspect != null) { // If width and height are not given // 1. Graph should not exceeds the container // 2. Aspect must be keeped // 3. Graph should take the space as more as possible // FIXME // Margin is not considered, because there is no case that both // using margin and aspect so far. if (isNaN(width) && isNaN(height)) { if (aspect > containerWidth / containerHeight) { width = containerWidth * 0.8; } else { height = containerHeight * 0.8; } } // Calculate width or height with given aspect if (isNaN(width)) { width = aspect * height; } if (isNaN(height)) { height = width / aspect; } } // If left is not specified, calculate left from right and width if (isNaN(left)) { left = containerWidth - right - width - horizontalMargin; } if (isNaN(top)) { top = containerHeight - bottom - height - verticalMargin; } // Align left and top switch (positionInfo.left || positionInfo.right) { case 'center': left = containerWidth / 2 - width / 2 - margin[3]; break; case 'right': left = containerWidth - width - horizontalMargin; break; } switch (positionInfo.top || positionInfo.bottom) { case 'middle': case 'center': top = containerHeight / 2 - height / 2 - margin[0]; break; case 'bottom': top = containerHeight - height - verticalMargin; break; } // If something is wrong and left, top, width, height are calculated as NaN left = left || 0; top = top || 0; if (isNaN(width)) { // Width may be NaN if only one value is given except width width = containerWidth - horizontalMargin - left - (right || 0); } if (isNaN(height)) { // Height may be NaN if only one value is given except height height = containerHeight - verticalMargin - top - (bottom || 0); } var rect = new BoundingRect(left + margin[3], top + margin[0], width, height); rect.margin = margin; return rect; }; /** * Position a zr element in viewport * Group position is specified by either * {left, top}, {right, bottom} * If all properties exists, right and bottom will be igonred. * * Logic: * 1. Scale (against origin point in parent coord) * 2. Rotate (against origin point in parent coord) * 3. Traslate (with el.position by this method) * So this method only fixes the last step 'Traslate', which does not affect * scaling and rotating. * * If be called repeatly with the same input el, the same result will be gotten. * * @param {module:zrender/Element} el Should have `getBoundingRect` method. * @param {Object} positionInfo * @param {number|string} [positionInfo.left] * @param {number|string} [positionInfo.top] * @param {number|string} [positionInfo.right] * @param {number|string} [positionInfo.bottom] * @param {number|string} [positionInfo.width] Only for opt.boundingModel: 'raw' * @param {number|string} [positionInfo.height] Only for opt.boundingModel: 'raw' * @param {Object} containerRect * @param {string|number} margin * @param {Object} [opt] * @param {Array.} [opt.hv=[1,1]] Only horizontal or only vertical. * @param {Array.} [opt.boundingMode='all'] * Specify how to calculate boundingRect when locating. * 'all': Position the boundingRect that is transformed and uioned * both itself and its descendants. * This mode simplies confine the elements in the bounding * of their container (e.g., using 'right: 0'). * 'raw': Position the boundingRect that is not transformed and only itself. * This mode is useful when you want a element can overflow its * container. (Consider a rotated circle needs to be located in a corner.) * In this mode positionInfo.width/height can only be number. */ layout.positionElement = function (el, positionInfo, containerRect, margin, opt) { var h = !opt || !opt.hv || opt.hv[0]; var v = !opt || !opt.hv || opt.hv[1]; var boundingMode = opt && opt.boundingMode || 'all'; if (!h && !v) { return; } var rect; if (boundingMode === 'raw') { rect = el.type === 'group' ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect(); } else { rect = el.getBoundingRect(); if (el.needLocalTransform()) { var transform = el.getLocalTransform(); // Notice: raw rect may be inner object of el, // which should not be modified. rect = rect.clone(); rect.applyTransform(transform); } } // The real width and height can not be specified but calculated by the given el. positionInfo = layout.getLayoutRect( zrUtil.defaults( {width: rect.width, height: rect.height}, positionInfo ), containerRect, margin ); // Because 'tranlate' is the last step in transform // (see zrender/core/Transformable#getLocalTransfrom), // we can just only modify el.position to get final result. var elPos = el.position; var dx = h ? positionInfo.x - rect.x : 0; var dy = v ? positionInfo.y - rect.y : 0; el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]); }; /** * @param {Object} option Contains some of the properties in HV_NAMES. * @param {number} hvIdx 0: horizontal; 1: vertical. */ layout.sizeCalculable = function (option, hvIdx) { return option[HV_NAMES[hvIdx][0]] != null || (option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null); }; /** * Consider Case: * When defulat option has {left: 0, width: 100}, and we set {right: 0} * through setOption or media query, using normal zrUtil.merge will cause * {right: 0} does not take effect. * * @example * ComponentModel.extend({ * init: function () { * ... * var inputPositionParams = layout.getLayoutParams(option); * this.mergeOption(inputPositionParams); * }, * mergeOption: function (newOption) { * newOption && zrUtil.merge(thisOption, newOption, true); * layout.mergeLayoutParam(thisOption, newOption); * } * }); * * @param {Object} targetOption * @param {Object} newOption * @param {Object|string} [opt] * @param {boolean|Array.} [opt.ignoreSize=false] Used for the components * that width (or height) should not be calculated by left and right (or top and bottom). */ layout.mergeLayoutParam = function (targetOption, newOption, opt) { !zrUtil.isObject(opt) && (opt = {}); var ignoreSize = opt.ignoreSize; !zrUtil.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]); var hResult = merge(HV_NAMES[0], 0); var vResult = merge(HV_NAMES[1], 1); copy(HV_NAMES[0], targetOption, hResult); copy(HV_NAMES[1], targetOption, vResult); function merge(names, hvIdx) { var newParams = {}; var newValueCount = 0; var merged = {}; var mergedValueCount = 0; var enoughParamNumber = 2; each(names, function (name) { merged[name] = targetOption[name]; }); each(names, function (name) { // Consider case: newOption.width is null, which is // set by user for removing width setting. hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]); hasValue(newParams, name) && newValueCount++; hasValue(merged, name) && mergedValueCount++; }); if (ignoreSize[hvIdx]) { // Only one of left/right is premitted to exist. if (hasValue(newOption, names[1])) { merged[names[2]] = null; } else if (hasValue(newOption, names[2])) { merged[names[1]] = null; } return merged; } // Case: newOption: {width: ..., right: ...}, // or targetOption: {right: ...} and newOption: {width: ...}, // There is no conflict when merged only has params count // little than enoughParamNumber. if (mergedValueCount === enoughParamNumber || !newValueCount) { return merged; } // Case: newOption: {width: ..., right: ...}, // Than we can make sure user only want those two, and ignore // all origin params in targetOption. else if (newValueCount >= enoughParamNumber) { return newParams; } else { // Chose another param from targetOption by priority. for (var i = 0; i < names.length; i++) { var name = names[i]; if (!hasProp(newParams, name) && hasProp(targetOption, name)) { newParams[name] = targetOption[name]; break; } } return newParams; } } function hasProp(obj, name) { return obj.hasOwnProperty(name); } function hasValue(obj, name) { return obj[name] != null && obj[name] !== 'auto'; } function copy(names, target, source) { each(names, function (name) { target[name] = source[name]; }); } }; /** * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object. * @param {Object} source * @return {Object} Result contains those props. */ layout.getLayoutParams = function (source) { return layout.copyLayoutParams({}, source); }; /** * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object. * @param {Object} source * @return {Object} Result contains those props. */ layout.copyLayoutParams = function (target, source) { source && target && each(LOCATION_PARAMS, function (name) { source.hasOwnProperty(name) && (target[name] = source[name]); }); return target; }; module.exports = layout; /***/ }), /* 75 */ /***/ (function(module, exports) { module.exports = { getBoxLayoutParams: function () { return { left: this.get('left'), top: this.get('top'), right: this.get('right'), bottom: this.get('bottom'), width: this.get('width'), height: this.get('height') }; } }; /***/ }), /* 76 */ /***/ (function(module, exports) { var platform = ''; // Navigator not exists in node if (typeof navigator !== 'undefined') { platform = navigator.platform || ''; } module.exports = { // 全图默认背景 // backgroundColor: 'rgba(0,0,0,0)', // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'], // 浅色 // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'], // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'], // 深色 color: ['#c23531','#2f4554', '#61a0a8', '#d48265', '#91c7ae','#749f83', '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3'], // 默认需要 Grid 配置项 // grid: {}, // 主题，主题 textStyle: { // color: '#000', // decoration: 'none', // PENDING fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif', // fontFamily: 'Arial, Verdana, sans-serif', fontSize: 12, fontStyle: 'normal', fontWeight: 'normal' }, // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/ // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation // Default is source-over blendMode: null, animation: 'auto', animationDuration: 1000, animationDurationUpdate: 300, animationEasing: 'exponentialOut', animationEasingUpdate: 'cubicOut', animationThreshold: 2000, // Configuration for progressive/incremental rendering progressiveThreshold: 3000, progressive: 400, // Threshold of if use single hover layer to optimize. // It is recommended that `hoverLayerThreshold` is equivalent to or less than // `progressiveThreshold`, otherwise hover will cause restart of progressive, // which is unexpected. // see example . hoverLayerThreshold: 3000, // See: module:echarts/scale/Time useUTC: false }; /***/ }), /* 77 */ /***/ (function(module, exports, __webpack_require__) { var classUtil = __webpack_require__(15); var set = classUtil.set; var get = classUtil.get; module.exports = { clearColorPalette: function () { set(this, 'colorIdx', 0); set(this, 'colorNameMap', {}); }, getColorFromPalette: function (name, scope) { scope = scope || this; var colorIdx = get(scope, 'colorIdx') || 0; var colorNameMap = get(scope, 'colorNameMap') || set(scope, 'colorNameMap', {}); // Use `hasOwnProperty` to avoid conflict with Object.prototype. if (colorNameMap.hasOwnProperty(name)) { return colorNameMap[name]; } var colorPalette = this.get('color', true) || []; if (!colorPalette.length) { return; } var color = colorPalette[colorIdx]; if (name) { colorNameMap[name] = color; } set(scope, 'colorIdx', (colorIdx + 1) % colorPalette.length); return color; } }; /***/ }), /* 78 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var zrUtil = __webpack_require__(4); var echartsAPIList = [ 'getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isDisposed', 'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption', 'getViewOfComponentModel', 'getViewOfSeriesModel' ]; // And `getCoordinateSystems` and `getComponentByElement` will be injected in echarts.js function ExtensionAPI(chartInstance) { zrUtil.each(echartsAPIList, function (name) { this[name] = zrUtil.bind(chartInstance[name], chartInstance); }, this); } module.exports = ExtensionAPI; /***/ }), /* 79 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var zrUtil = __webpack_require__(4); var coordinateSystemCreators = {}; function CoordinateSystemManager() { this._coordinateSystems = []; } CoordinateSystemManager.prototype = { constructor: CoordinateSystemManager, create: function (ecModel, api) { var coordinateSystems = []; zrUtil.each(coordinateSystemCreators, function (creater, type) { var list = creater.create(ecModel, api); coordinateSystems = coordinateSystems.concat(list || []); }); this._coordinateSystems = coordinateSystems; }, update: function (ecModel, api) { zrUtil.each(this._coordinateSystems, function (coordSys) { // FIXME MUST have coordSys.update && coordSys.update(ecModel, api); }); }, getCoordinateSystems: function () { return this._coordinateSystems.slice(); } }; CoordinateSystemManager.register = function (type, coordinateSystemCreator) { coordinateSystemCreators[type] = coordinateSystemCreator; }; CoordinateSystemManager.get = function (type) { return coordinateSystemCreators[type]; }; module.exports = CoordinateSystemManager; /***/ }), /* 80 */ /***/ (function(module, exports, __webpack_require__) { /** * ECharts option manager * * @module {echarts/model/OptionManager} */ var zrUtil = __webpack_require__(4); var modelUtil = __webpack_require__(5); var ComponentModel = __webpack_require__(72); var each = zrUtil.each; var clone = zrUtil.clone; var map = zrUtil.map; var merge = zrUtil.merge; var QUERY_REG = /^(min|max)?(.+)$/; /** * TERM EXPLANATIONS: * * [option]: * * An object that contains definitions of components. For example: * var option = { * title: {...}, * legend: {...}, * visualMap: {...}, * series: [ * {data: [...]}, * {data: [...]}, * ... * ] * }; * * [rawOption]: * * An object input to echarts.setOption. 'rawOption' may be an * 'option', or may be an object contains multi-options. For example: * var option = { * baseOption: { * title: {...}, * legend: {...}, * series: [ * {data: [...]}, * {data: [...]}, * ... * ] * }, * timeline: {...}, * options: [ * {title: {...}, series: {data: [...]}}, * {title: {...}, series: {data: [...]}}, * ... * ], * media: [ * { * query: {maxWidth: 320}, * option: {series: {x: 20}, visualMap: {show: false}} * }, * { * query: {minWidth: 320, maxWidth: 720}, * option: {series: {x: 500}, visualMap: {show: true}} * }, * { * option: {series: {x: 1200}, visualMap: {show: true}} * } * ] * }; * * @alias module:echarts/model/OptionManager * @param {module:echarts/ExtensionAPI} api */ function OptionManager(api) { /** * @private * @type {module:echarts/ExtensionAPI} */ this._api = api; /** * @private * @type {Array.} */ this._timelineOptions = []; /** * @private * @type {Array.} */ this._mediaList = []; /** * @private * @type {Object} */ this._mediaDefault; /** * -1, means default. * empty means no media. * @private * @type {Array.} */ this._currentMediaIndices = []; /** * @private * @type {Object} */ this._optionBackup; /** * @private * @type {Object} */ this._newBaseOption; } // timeline.notMerge is not supported in ec3. Firstly there is rearly // case that notMerge is needed. Secondly supporting 'notMerge' requires // rawOption cloned and backuped when timeline changed, which does no // good to performance. What's more, that both timeline and setOption // method supply 'notMerge' brings complex and some problems. // Consider this case: // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false); // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false); OptionManager.prototype = { constructor: OptionManager, /** * @public * @param {Object} rawOption Raw option. * @param {module:echarts/model/Global} ecModel * @param {Array.} optionPreprocessorFuncs * @return {Object} Init option */ setOption: function (rawOption, optionPreprocessorFuncs) { rawOption = clone(rawOption, true); // FIXME // 如果 timeline options 或者 media 中设置了某个属性，而baseOption中没有设置，则进行警告。 var oldOptionBackup = this._optionBackup; var newParsedOption = parseRawOption.call( this, rawOption, optionPreprocessorFuncs, !oldOptionBackup ); this._newBaseOption = newParsedOption.baseOption; // For setOption at second time (using merge mode); if (oldOptionBackup) { // Only baseOption can be merged. mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption); // For simplicity, timeline options and media options do not support merge, // that is, if you `setOption` twice and both has timeline options, the latter // timeline opitons will not be merged to the formers, but just substitude them. if (newParsedOption.timelineOptions.length) { oldOptionBackup.timelineOptions = newParsedOption.timelineOptions; } if (newParsedOption.mediaList.length) { oldOptionBackup.mediaList = newParsedOption.mediaList; } if (newParsedOption.mediaDefault) { oldOptionBackup.mediaDefault = newParsedOption.mediaDefault; } } else { this._optionBackup = newParsedOption; } }, /** * @param {boolean} isRecreate * @return {Object} */ mountOption: function (isRecreate) { var optionBackup = this._optionBackup; // TODO // 如果没有reset功能则不clone。 this._timelineOptions = map(optionBackup.timelineOptions, clone); this._mediaList = map(optionBackup.mediaList, clone); this._mediaDefault = clone(optionBackup.mediaDefault); this._currentMediaIndices = []; return clone(isRecreate // this._optionBackup.baseOption, which is created at the first `setOption` // called, and is merged into every new option by inner method `mergeOption` // each time `setOption` called, can be only used in `isRecreate`, because // its reliability is under suspicion. In other cases option merge is // performed by `model.mergeOption`. ? optionBackup.baseOption : this._newBaseOption ); }, /** * @param {module:echarts/model/Global} ecModel * @return {Object} */ getTimelineOption: function (ecModel) { var option; var timelineOptions = this._timelineOptions; if (timelineOptions.length) { // getTimelineOption can only be called after ecModel inited, // so we can get currentIndex from timelineModel. var timelineModel = ecModel.getComponent('timeline'); if (timelineModel) { option = clone( timelineOptions[timelineModel.getCurrentIndex()], true ); } } return option; }, /** * @param {module:echarts/model/Global} ecModel * @return {Array.} */ getMediaOption: function (ecModel) { var ecWidth = this._api.getWidth(); var ecHeight = this._api.getHeight(); var mediaList = this._mediaList; var mediaDefault = this._mediaDefault; var indices = []; var result = []; // No media defined. if (!mediaList.length && !mediaDefault) { return result; } // Multi media may be applied, the latter defined media has higher priority. for (var i = 0, len = mediaList.length; i < len; i++) { if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) { indices.push(i); } } // FIXME // 是否mediaDefault应该强制用户设置，否则可能修改不能回归。 if (!indices.length && mediaDefault) { indices = [-1]; } if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) { result = map(indices, function (index) { return clone( index === -1 ? mediaDefault.option : mediaList[index].option ); }); } // Otherwise return nothing. this._currentMediaIndices = indices; return result; } }; function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) { var timelineOptions = []; var mediaList = []; var mediaDefault; var baseOption; // Compatible with ec2. var timelineOpt = rawOption.timeline; if (rawOption.baseOption) { baseOption = rawOption.baseOption; } // For timeline if (timelineOpt || rawOption.options) { baseOption = baseOption || {}; timelineOptions = (rawOption.options || []).slice(); } // For media query if (rawOption.media) { baseOption = baseOption || {}; var media = rawOption.media; each(media, function (singleMedia) { if (singleMedia && singleMedia.option) { if (singleMedia.query) { mediaList.push(singleMedia); } else if (!mediaDefault) { // Use the first media default. mediaDefault = singleMedia; } } }); } // For normal option if (!baseOption) { baseOption = rawOption; } // Set timelineOpt to baseOption in ec3, // which is convenient for merge option. if (!baseOption.timeline) { baseOption.timeline = timelineOpt; } // Preprocess. each([baseOption].concat(timelineOptions) .concat(zrUtil.map(mediaList, function (media) { return media.option; })), function (option) { each(optionPreprocessorFuncs, function (preProcess) { preProcess(option, isNew); }); } ); return { baseOption: baseOption, timelineOptions: timelineOptions, mediaDefault: mediaDefault, mediaList: mediaList }; } /** * @see * Support: width, height, aspectRatio * Can use max or min as prefix. */ function applyMediaQuery(query, ecWidth, ecHeight) { var realMap = { width: ecWidth, height: ecHeight, aspectratio: ecWidth / ecHeight // lowser case for convenientce. }; var applicatable = true; zrUtil.each(query, function (value, attr) { var matched = attr.match(QUERY_REG); if (!matched || !matched[1] || !matched[2]) { return; } var operator = matched[1]; var realAttr = matched[2].toLowerCase(); if (!compare(realMap[realAttr], value, operator)) { applicatable = false; } }); return applicatable; } function compare(real, expect, operator) { if (operator === 'min') { return real >= expect; } else if (operator === 'max') { return real = 0) { // Progressive layer changed if (!currentProgressiveLayer) { currentProgressiveLayer = this._progressiveLayers[ Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1) ]; currentProgressiveLayer.ctx.save(); currentProgressiveLayer.renderScope = {}; if (currentProgressiveLayer && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress) ) { // flushProgressiveLayer(currentProgressiveLayer); // Quick jump all progressive elements // All progressive element are not dirty, jump over and flush directly i = currentProgressiveLayer.__nextIdxNotProg - 1; // currentProgressiveLayer = null; continue; } layerProgress = currentProgressiveLayer.__progress; if (!currentProgressiveLayer.__dirty) { // Keep rendering frame = layerProgress; } currentProgressiveLayer.__progress = frame + 1; } if (elFrame === frame) { this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope); } } else { this._doPaintEl(el, currentLayer, paintAll, scope); } el.__dirty = false; } if (currentProgressiveLayer) { flushProgressiveLayer(currentProgressiveLayer); } // Restore the lastLayer ctx ctx && ctx.restore(); // If still has clipping state // if (scope.prevElClipPaths) { // ctx.restore(); // } this._furtherProgressive = false; util.each(this._progressiveLayers, function (layer) { if (layer.__maxProgress >= layer.__progress) { this._furtherProgressive = true; } }, this); }, _doPaintEl: function (el, currentLayer, forcePaint, scope) { var ctx = currentLayer.ctx; var m = el.transform; if ( (currentLayer.__dirty || forcePaint) // Ignore invisible element && !el.invisible // Ignore transparent element && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas // Draw a scale 0 element can cause all following draw wrong // And setTransform with scale 0 will cause set back transform failed. && !(m && !m[0] && !m[3]) // Ignore culled element && !(el.culling && isDisplayableCulled(el, this._width, this._height)) ) { var clipPaths = el.__clipPaths; // Optimize when clipping on group with several elements if (scope.prevClipLayer !== currentLayer || isClipPathChanged(clipPaths, scope.prevElClipPaths) ) { // If has previous clipping state, restore from it if (scope.prevElClipPaths) { scope.prevClipLayer.ctx.restore(); scope.prevClipLayer = scope.prevElClipPaths = null; // Reset prevEl since context has been restored scope.prevEl = null; } // New clipping state if (clipPaths) { ctx.save(); doClip(clipPaths, ctx); scope.prevClipLayer = currentLayer; scope.prevElClipPaths = clipPaths; } } el.beforeBrush && el.beforeBrush(ctx); el.brush(ctx, scope.prevEl || null); scope.prevEl = el; el.afterBrush && el.afterBrush(ctx); } }, /** * 获取 zlevel 所在层，如果不存在则会创建一个新的层 * @param {number} zlevel * @return {module:zrender/Layer} */ getLayer: function (zlevel) { if (this._singleCanvas) { return this._layers[0]; } var layer = this._layers[zlevel]; if (!layer) { // Create a new layer layer = new Layer('zr_' + zlevel, this, this.dpr); layer.__builtin__ = true; if (this._layerConfig[zlevel]) { util.merge(layer, this._layerConfig[zlevel], true); } this.insertLayer(zlevel, layer); // Context is created after dom inserted to document // Or excanvas will get 0px clientWidth and clientHeight layer.initContext(); } return layer; }, insertLayer: function (zlevel, layer) { var layersMap = this._layers; var zlevelList = this._zlevelList; var len = zlevelList.length; var prevLayer = null; var i = -1; var domRoot = this._domRoot; if (layersMap[zlevel]) { log('ZLevel ' + zlevel + ' has been used already'); return; } // Check if is a valid layer if (!isLayerValid(layer)) { log('Layer of zlevel ' + zlevel + ' is not valid'); return; } if (len > 0 && zlevel > zlevelList[0]) { for (i = 0; i < len - 1; i++) { if ( zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel ) { break; } } prevLayer = layersMap[zlevelList[i]]; } zlevelList.splice(i + 1, 0, zlevel); layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen. // (It can be a WebGL layer and assigned to a ZImage element) // But it still under management of zrender. if (!layer.virtual) { if (prevLayer) { var prevDom = prevLayer.dom; if (prevDom.nextSibling) { domRoot.insertBefore( layer.dom, prevDom.nextSibling ); } else { domRoot.appendChild(layer.dom); } } else { if (domRoot.firstChild) { domRoot.insertBefore(layer.dom, domRoot.firstChild); } else { domRoot.appendChild(layer.dom); } } } }, // Iterate each layer eachLayer: function (cb, context) { var zlevelList = this._zlevelList; var z; var i; for (i = 0; i < zlevelList.length; i++) { z = zlevelList[i]; cb.call(context, this._layers[z], z); } }, // Iterate each buildin layer eachBuiltinLayer: function (cb, context) { var zlevelList = this._zlevelList; var layer; var z; var i; for (i = 0; i < zlevelList.length; i++) { z = zlevelList[i]; layer = this._layers[z]; if (layer.__builtin__) { cb.call(context, layer, z); } } }, // Iterate each other layer except buildin layer eachOtherLayer: function (cb, context) { var zlevelList = this._zlevelList; var layer; var z; var i; for (i = 0; i < zlevelList.length; i++) { z = zlevelList[i]; layer = this._layers[z]; if (!layer.__builtin__) { cb.call(context, layer, z); } } }, /** * 获取所有已创建的层 * @param {Array.} [prevLayer] */ getLayers: function () { return this._layers; }, _updateLayerStatus: function (list) { var layers = this._layers; var progressiveLayers = this._progressiveLayers; var elCountsLastFrame = {}; var progressiveElCountsLastFrame = {}; this.eachBuiltinLayer(function (layer, z) { elCountsLastFrame[z] = layer.elCount; layer.elCount = 0; layer.__dirty = false; }); util.each(progressiveLayers, function (layer, idx) { progressiveElCountsLastFrame[idx] = layer.elCount; layer.elCount = 0; layer.__dirty = false; }); var progressiveLayerCount = 0; var currentProgressiveLayer; var lastProgressiveKey; var frameCount = 0; for (var i = 0, l = list.length; i < l; i++) { var el = list[i]; var zlevel = this._singleCanvas ? 0 : el.zlevel; var layer = layers[zlevel]; var elProgress = el.progressive; if (layer) { layer.elCount++; layer.__dirty = layer.__dirty || el.__dirty; } /////// Update progressive if (elProgress >= 0) { // Fix wrong progressive sequence problem. if (lastProgressiveKey !== elProgress) { lastProgressiveKey = elProgress; frameCount++; } var elFrame = el.__frame = frameCount - 1; if (!currentProgressiveLayer) { var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1); currentProgressiveLayer = progressiveLayers[idx]; if (!currentProgressiveLayer) { currentProgressiveLayer = progressiveLayers[idx] = new Layer( 'progressive', this, this.dpr ); currentProgressiveLayer.initContext(); } currentProgressiveLayer.__maxProgress = 0; } currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty; currentProgressiveLayer.elCount++; currentProgressiveLayer.__maxProgress = Math.max( currentProgressiveLayer.__maxProgress, elFrame ); if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) { // Should keep rendering this layer because progressive rendering is not finished yet layer.__dirty = true; } } else { el.__frame = -1; if (currentProgressiveLayer) { currentProgressiveLayer.__nextIdxNotProg = i; progressiveLayerCount++; currentProgressiveLayer = null; } } } if (currentProgressiveLayer) { progressiveLayerCount++; currentProgressiveLayer.__nextIdxNotProg = i; } // 层中的元素数量有发生变化 this.eachBuiltinLayer(function (layer, z) { if (elCountsLastFrame[z] !== layer.elCount) { layer.__dirty = true; } }); progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER); util.each(progressiveLayers, function (layer, idx) { if (progressiveElCountsLastFrame[idx] !== layer.elCount) { el.__dirty = true; } if (layer.__dirty) { layer.__progress = 0; } }); }, /** * 清除hover层外所有内容 */ clear: function () { this.eachBuiltinLayer(this._clearLayer); return this; }, _clearLayer: function (layer) { layer.clear(); }, /** * 修改指定zlevel的绘制参数 * * @param {string} zlevel * @param {Object} config 配置对象 * @param {string} [config.clearColor=0] 每次清空画布的颜色 * @param {string} [config.motionBlur=false] 是否开启动态模糊 * @param {number} [config.lastFrameAlpha=0.7] * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显 */ configLayer: function (zlevel, config) { if (config) { var layerConfig = this._layerConfig; if (!layerConfig[zlevel]) { layerConfig[zlevel] = config; } else { util.merge(layerConfig[zlevel], config, true); } var layer = this._layers[zlevel]; if (layer) { util.merge(layer, layerConfig[zlevel], true); } } }, /** * 删除指定层 * @param {number} zlevel 层所在的zlevel */ delLayer: function (zlevel) { var layers = this._layers; var zlevelList = this._zlevelList; var layer = layers[zlevel]; if (!layer) { return; } layer.dom.parentNode.removeChild(layer.dom); delete layers[zlevel]; zlevelList.splice(util.indexOf(zlevelList, zlevel), 1); }, /** * 区域大小变化后重绘 */ resize: function (width, height) { var domRoot = this._domRoot; // FIXME Why ? domRoot.style.display = 'none'; // Save input w/h var opts = this._opts; width != null && (opts.width = width); height != null && (opts.height = height); width = this._getSize(0); height = this._getSize(1); domRoot.style.display = ''; // 优化没有实际改变的resize if (this._width != width || height != this._height) { domRoot.style.width = width + 'px'; domRoot.style.height = height + 'px'; for (var id in this._layers) { if (this._layers.hasOwnProperty(id)) { this._layers[id].resize(width, height); } } util.each(this._progressiveLayers, function (layer) { layer.resize(width, height); }); this.refresh(true); } this._width = width; this._height = height; return this; }, /** * 清除单独的一个层 * @param {number} zlevel */ clearLayer: function (zlevel) { var layer = this._layers[zlevel]; if (layer) { layer.clear(); } }, /** * 释放 */ dispose: function () { this.root.innerHTML = ''; this.root = this.storage = this._domRoot = this._layers = null; }, /** * Get canvas which has all thing rendered * @param {Object} opts * @param {string} [opts.backgroundColor] */ getRenderedCanvas: function (opts) { opts = opts || {}; if (this._singleCanvas) { return this._layers[0].dom; } var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr); imageLayer.initContext(); imageLayer.clearColor = opts.backgroundColor; imageLayer.clear(); var displayList = this.storage.getDisplayList(true); var scope = {}; var zlevel; var self = this; function findAndDrawOtherLayer(smaller, larger) { var zlevelList = self._zlevelList; if (smaller == null) { smaller = -Infinity; } var intermediateLayer; for (var i = 0; i < zlevelList.length; i++) { var z = zlevelList[i]; var layer = self._layers[z]; if (!layer.__builtin__ && z > smaller && z < larger) { intermediateLayer = layer; break; } } if (intermediateLayer && intermediateLayer.renderToCanvas) { imageLayer.ctx.save(); intermediateLayer.renderToCanvas(imageLayer.ctx); imageLayer.ctx.restore(); } } for (var i = 0; i < displayList.length; i++) { var el = displayList[i]; if (el.zlevel !== zlevel) { findAndDrawOtherLayer(zlevel, el.zlevel); zlevel = el.zlevel; } this._doPaintEl(el, imageLayer, true, scope); } findAndDrawOtherLayer(zlevel, Infinity); return imageLayer.dom; }, /** * 获取绘图区域宽度 */ getWidth: function () { return this._width; }, /** * 获取绘图区域高度 */ getHeight: function () { return this._height; }, _getSize: function (whIdx) { var opts = this._opts; var wh = ['width', 'height'][whIdx]; var cwh = ['clientWidth', 'clientHeight'][whIdx]; var plt = ['paddingLeft', 'paddingTop'][whIdx]; var prb = ['paddingRight', 'paddingBottom'][whIdx]; if (opts[wh] != null && opts[wh] !== 'auto') { return parseFloat(opts[wh]); } var root = this.root; // IE8 does not support getComputedStyle, but it use VML. var stl = document.defaultView.getComputedStyle(root); return ( (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) ) | 0; }, pathToImage: function (path, dpr) { dpr = dpr || this.dpr; var canvas = document.createElement('canvas'); var ctx = canvas.getContext('2d'); var rect = path.getBoundingRect(); var style = path.style; var shadowBlurSize = style.shadowBlur; var shadowOffsetX = style.shadowOffsetX; var shadowOffsetY = style.shadowOffsetY; var lineWidth = style.hasStroke() ? style.lineWidth : 0; var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize); var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize); var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize); var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize); var width = rect.width + leftMargin + rightMargin; var height = rect.height + topMargin + bottomMargin; canvas.width = width * dpr; canvas.height = height * dpr; ctx.scale(dpr, dpr); ctx.clearRect(0, 0, width, height); ctx.dpr = dpr; var pathTransform = { position: path.position, rotation: path.rotation, scale: path.scale }; path.position = [leftMargin - rect.x, topMargin - rect.y]; path.rotation = 0; path.scale = [1, 1]; path.updateTransform(); if (path) { path.brush(ctx); } var ImageShape = __webpack_require__(52); var imgShape = new ImageShape({ style: { x: 0, y: 0, image: canvas } }); if (pathTransform.position != null) { imgShape.position = path.position = pathTransform.position; } if (pathTransform.rotation != null) { imgShape.rotation = path.rotation = pathTransform.rotation; } if (pathTransform.scale != null) { imgShape.scale = path.scale = pathTransform.scale; } return imgShape; } }; module.exports = Painter; /***/ }), /* 98 */ /***/ (function(module, exports, __webpack_require__) { /** * @module zrender/Layer * @author pissang(https://www.github.com/pissang) */ var util = __webpack_require__(4); var config = __webpack_require__(35); var Style = __webpack_require__(24); var Pattern = __webpack_require__(49); function returnFalse() { return false; } /** * 创建dom * * @inner * @param {string} id dom id 待用 * @param {string} type dom type，such as canvas, div etc. * @param {Painter} painter painter instance * @param {number} number */ function createDom(id, type, painter, dpr) { var newDom = document.createElement(type); var width = painter.getWidth(); var height = painter.getHeight(); var newDomStyle = newDom.style; // 没append呢，请原谅我这样写，清晰~ newDomStyle.position = 'absolute'; newDomStyle.left = 0; newDomStyle.top = 0; newDomStyle.width = width + 'px'; newDomStyle.height = height + 'px'; newDom.width = width * dpr; newDom.height = height * dpr; // id不作为索引用，避免可能造成的重名，定义为私有属性 newDom.setAttribute('data-zr-dom-id', id); return newDom; } /** * @alias module:zrender/Layer * @constructor * @extends module:zrender/mixin/Transformable * @param {string} id * @param {module:zrender/Painter} painter * @param {number} [dpr] */ var Layer = function(id, painter, dpr) { var dom; dpr = dpr || config.devicePixelRatio; if (typeof id === 'string') { dom = createDom(id, 'canvas', painter, dpr); } // Not using isDom because in node it will return false else if (util.isObject(id)) { dom = id; id = dom.id; } this.id = id; this.dom = dom; var domStyle = dom.style; if (domStyle) { // Not in node dom.onselectstart = returnFalse; // 避免页面选中的尴尬 domStyle['-webkit-user-select'] = 'none'; domStyle['user-select'] = 'none'; domStyle['-webkit-touch-callout'] = 'none'; domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)'; domStyle['padding'] = 0; domStyle['margin'] = 0; domStyle['border-width'] = 0; } this.domBack = null; this.ctxBack = null; this.painter = painter; this.config = null; // Configs /** * 每次清空画布的颜色 * @type {string} * @default 0 */ this.clearColor = 0; /** * 是否开启动态模糊 * @type {boolean} * @default false */ this.motionBlur = false; /** * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显 * @type {number} * @default 0.7 */ this.lastFrameAlpha = 0.7; /** * Layer dpr * @type {number} */ this.dpr = dpr; }; Layer.prototype = { constructor: Layer, elCount: 0, __dirty: true, initContext: function () { this.ctx = this.dom.getContext('2d'); this.ctx.__currentValues = {}; this.ctx.dpr = this.dpr; }, createBackBuffer: function () { var dpr = this.dpr; this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr); this.ctxBack = this.domBack.getContext('2d'); this.ctxBack.__currentValues = {}; if (dpr != 1) { this.ctxBack.scale(dpr, dpr); } }, /** * @param {number} width * @param {number} height */ resize: function (width, height) { var dpr = this.dpr; var dom = this.dom; var domStyle = dom.style; var domBack = this.domBack; domStyle.width = width + 'px'; domStyle.height = height + 'px'; dom.width = width * dpr; dom.height = height * dpr; if (domBack) { domBack.width = width * dpr; domBack.height = height * dpr; if (dpr != 1) { this.ctxBack.scale(dpr, dpr); } } }, /** * 清空该层画布 * @param {boolean} clearAll Clear all with out motion blur */ clear: function (clearAll) { var dom = this.dom; var ctx = this.ctx; var width = dom.width; var height = dom.height; var clearColor = this.clearColor; var haveMotionBLur = this.motionBlur && !clearAll; var lastFrameAlpha = this.lastFrameAlpha; var dpr = this.dpr; if (haveMotionBLur) { if (!this.domBack) { this.createBackBuffer(); } this.ctxBack.globalCompositeOperation = 'copy'; this.ctxBack.drawImage( dom, 0, 0, width / dpr, height / dpr ); } ctx.clearRect(0, 0, width, height); if (clearColor) { var clearColorGradientOrPattern; // Gradient if (clearColor.colorStops) { // Cache canvas gradient clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, { x: 0, y: 0, width: width, height: height }); clearColor.__canvasGradient = clearColorGradientOrPattern; } // Pattern else if (clearColor.image) { clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx); } ctx.save(); ctx.fillStyle = clearColorGradientOrPattern || clearColor; ctx.fillRect(0, 0, width, height); ctx.restore(); } if (haveMotionBLur) { var domBack = this.domBack; ctx.save(); ctx.globalAlpha = lastFrameAlpha; ctx.drawImage(domBack, 0, 0, width, height); ctx.restore(); } } }; module.exports = Layer; /***/ }), /* 99 */ /***/ (function(module, exports, __webpack_require__) { var Gradient = __webpack_require__(69); module.exports = function (ecModel) { function encodeColor(seriesModel) { var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.'); var data = seriesModel.getData(); var color = seriesModel.get(colorAccessPath) // Set in itemStyle || seriesModel.getColorFromPalette(seriesModel.get('name')); // Default color // FIXME Set color function or use the platte color data.setVisual('color', color); // Only visible series has each data be visual encoded if (!ecModel.isSeriesFiltered(seriesModel)) { if (typeof color === 'function' && !(color instanceof Gradient)) { data.each(function (idx) { data.setItemVisual( idx, 'color', color(seriesModel.getDataParams(idx)) ); }); } // itemStyle in each data item data.each(function (idx) { var itemModel = data.getItemModel(idx); var color = itemModel.get(colorAccessPath, true); if (color != null) { data.setItemVisual(idx, 'color', color); } }); } } ecModel.eachRawSeries(encodeColor); }; /***/ }), /* 100 */ /***/ (function(module, exports, __webpack_require__) { var graphic = __webpack_require__(20); var zrUtil = __webpack_require__(4); var PI = Math.PI; /** * @param {module:echarts/ExtensionAPI} api * @param {Object} [opts] * @param {string} [opts.text] * @param {string} [opts.color] * @param {string} [opts.textColor] * @return {module:zrender/Element} */ module.exports = function (api, opts) { opts = opts || {}; zrUtil.defaults(opts, { text: 'loading', color: '#c23531', textColor: '#000', maskColor: 'rgba(255, 255, 255, 0.8)', zlevel: 0 }); var mask = new graphic.Rect({ style: { fill: opts.maskColor }, zlevel: opts.zlevel, z: 10000 }); var arc = new graphic.Arc({ shape: { startAngle: -PI / 2, endAngle: -PI / 2 + 0.1, r: 10 }, style: { stroke: opts.color, lineCap: 'round', lineWidth: 5 }, zlevel: opts.zlevel, z: 10001 }); var labelRect = new graphic.Rect({ style: { fill: 'none', text: opts.text, textPosition: 'right', textDistance: 10, textFill: opts.textColor }, zlevel: opts.zlevel, z: 10001 }); arc.animateShape(true) .when(1000, { endAngle: PI * 3 / 2 }) .start('circularInOut'); arc.animateShape(true) .when(1000, { startAngle: PI * 3 / 2 }) .delay(300) .start('circularInOut'); var group = new graphic.Group(); group.add(arc); group.add(labelRect); group.add(mask); // Inject resize group.resize = function () { var cx = api.getWidth() / 2; var cy = api.getHeight() / 2; arc.setShape({ cx: cx, cy: cy }); var r = arc.shape.r; labelRect.setShape({ x: cx - r, y: cy - r, width: r * 2, height: r * 2 }); mask.setShape({ x: 0, y: 0, width: api.getWidth(), height: api.getHeight() }); }; group.resize(); return group; }; /***/ }), /* 101 */ /***/ (function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(global) {/** * List for data storage * @module echarts/data/List */ var UNDEFINED = 'undefined'; var globalObj = typeof window === 'undefined' ? global : window; var Float64Array = typeof globalObj.Float64Array === UNDEFINED ? Array : globalObj.Float64Array; var Int32Array = typeof globalObj.Int32Array === UNDEFINED ? Array : globalObj.Int32Array; var dataCtors = { 'float': Float64Array, 'int': Int32Array, // Ordinal data type can be string or int 'ordinal': Array, 'number': Array, 'time': Array }; var Model = __webpack_require__(14); var DataDiffer = __webpack_require__(102); var zrUtil = __webpack_require__(4); var modelUtil = __webpack_require__(5); var isObject = zrUtil.isObject; var TRANSFERABLE_PROPERTIES = [ 'stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData' ]; function transferProperties(a, b) { zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) { if (b.hasOwnProperty(propName)) { a[propName] = b[propName]; } }); a.__wrappedMethods = b.__wrappedMethods; } function DefaultDataProvider(dataArray) { this._array = dataArray || []; } DefaultDataProvider.prototype.pure = false; DefaultDataProvider.prototype.count = function () { return this._array.length; }; DefaultDataProvider.prototype.getItem = function (idx) { return this._array[idx]; }; /** * @constructor * @alias module:echarts/data/List * * @param {Array.} dimensions * For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...]. * Dimensions should be concrete names like x, y, z, lng, lat, angle, radius * @param {module:echarts/model/Model} hostModel */ var List = function (dimensions, hostModel) { dimensions = dimensions || ['x', 'y']; var dimensionInfos = {}; var dimensionNames = []; for (var i = 0; i < dimensions.length; i++) { var dimensionName; var dimensionInfo = {}; if (typeof dimensions[i] === 'string') { dimensionName = dimensions[i]; dimensionInfo = { name: dimensionName, coordDim: dimensionName, coordDimIndex: 0, stackable: false, // Type can be 'float', 'int', 'number' // Default is number, Precision of float may not enough type: 'number' }; } else { dimensionInfo = dimensions[i]; dimensionName = dimensionInfo.name; dimensionInfo.type = dimensionInfo.type || 'number'; if (!dimensionInfo.coordDim) { dimensionInfo.coordDim = dimensionName; dimensionInfo.coordDimIndex = 0; } } dimensionInfo.otherDims = dimensionInfo.otherDims || {}; dimensionNames.push(dimensionName); dimensionInfos[dimensionName] = dimensionInfo; } /** * @readOnly * @type {Array.} */ this.dimensions = dimensionNames; /** * Infomation of each data dimension, like data type. * @type {Object} */ this._dimensionInfos = dimensionInfos; /** * @type {module:echarts/model/Model} */ this.hostModel = hostModel; /** * @type {module:echarts/model/Model} */ this.dataType; /** * Indices stores the indices of data subset after filtered. * This data subset will be used in chart. * @type {Array.} * @readOnly */ this.indices = []; /** * Data storage * @type {Object.} * @private */ this._storage = {}; /** * @type {Array.} */ this._nameList = []; /** * @type {Array.} */ this._idList = []; /** * Models of data option is stored sparse for optimizing memory cost * @type {Array.} * @private */ this._optionModels = []; /** * @param {module:echarts/data/List} */ this.stackedOn = null; /** * Global visual properties after visual coding * @type {Object} * @private */ this._visual = {}; /** * Globel layout properties. * @type {Object} * @private */ this._layout = {}; /** * Item visual properties after visual coding * @type {Array.} * @private */ this._itemVisuals = []; /** * Item layout properties after layout * @type {Array.} * @private */ this._itemLayouts = []; /** * Graphic elemnents * @type {Array.} * @private */ this._graphicEls = []; /** * @type {Array.} * @private */ this._rawData; /** * @type {Object} * @private */ this._extent; }; var listProto = List.prototype; listProto.type = 'list'; /** * If each data item has it's own option * @type {boolean} */ listProto.hasItemOption = true; /** * Get dimension name * @param {string|number} dim * Dimension can be concrete names like x, y, z, lng, lat, angle, radius * Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius' * @return {string} Concrete dim name. */ listProto.getDimension = function (dim) { if (!isNaN(dim)) { dim = this.dimensions[dim] || dim; } return dim; }; /** * Get type and stackable info of particular dimension * @param {string|number} dim * Dimension can be concrete names like x, y, z, lng, lat, angle, radius * Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius' */ listProto.getDimensionInfo = function (dim) { return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]); }; /** * Initialize from data * @param {Array.} data * @param {Array.} [nameList] * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number */ listProto.initData = function (data, nameList, dimValueGetter) { data = data || []; var isDataArray = zrUtil.isArray(data); if (isDataArray) { data = new DefaultDataProvider(data); } if (true) { if (!isDataArray && (typeof data.getItem != 'function' || typeof data.count != 'function')) { throw new Error('Inavlid data provider.'); } } this._rawData = data; // Clear var storage = this._storage = {}; var indices = this.indices = []; var dimensions = this.dimensions; var dimensionInfoMap = this._dimensionInfos; var size = data.count(); var idList = []; var nameRepeatCount = {}; var nameDimIdx; nameList = nameList || []; // Init storage for (var i = 0; i < dimensions.length; i++) { var dimInfo = dimensionInfoMap[dimensions[i]]; dimInfo.otherDims.itemName === 0 && (nameDimIdx = i); var DataCtor = dataCtors[dimInfo.type]; storage[dimensions[i]] = new DataCtor(size); } var self = this; if (!dimValueGetter) { self.hasItemOption = false; } // Default dim value getter dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) { var value = modelUtil.getDataItemValue(dataItem); // If any dataItem is like { value: 10 } if (modelUtil.isDataItemOption(dataItem)) { self.hasItemOption = true; } return modelUtil.converDataValue( (value instanceof Array) ? value[dimIndex] // If value is a single number or something else not array. : value, dimensionInfoMap[dimName] ); }; for (var i = 0; i < size; i++) { // NOTICE: Try not to write things into dataItem var dataItem = data.getItem(i); // Each data item is value // [1, 2] // 2 // Bar chart, line chart which uses category axis // only gives the 'y' value. 'x' value is the indices of cateogry // Use a tempValue to normalize the value to be a (x, y) value // Store the data by dimensions for (var k = 0; k < dimensions.length; k++) { var dim = dimensions[k]; var dimStorage = storage[dim]; // PENDING NULL is empty or zero dimStorage[i] = dimValueGetter(dataItem, dim, i, k); } indices.push(i); } // Use the name in option and create id for (var i = 0; i < size; i++) { var dataItem = data.getItem(i); if (!nameList[i] && dataItem) { if (dataItem.name != null) { nameList[i] = dataItem.name; } else if (nameDimIdx != null) { nameList[i] = storage[dimensions[nameDimIdx]][i]; } } var name = nameList[i] || ''; // Try using the id in option var id = dataItem && dataItem.id; if (!id && name) { // Use name as id and add counter to avoid same name nameRepeatCount[name] = nameRepeatCount[name] || 0; id = name; if (nameRepeatCount[name] > 0) { id += '__ec__' + nameRepeatCount[name]; } nameRepeatCount[name]++; } id && (idList[i] = id); } this._nameList = nameList; this._idList = idList; }; /** * @return {number} */ listProto.count = function () { return this.indices.length; }; /** * Get value. Return NaN if idx is out of range. * @param {string} dim Dim must be concrete name. * @param {number} idx * @param {boolean} stack * @return {number} */ listProto.get = function (dim, idx, stack) { var storage = this._storage; var dataIndex = this.indices[idx]; // If value not exists if (dataIndex == null || !storage[dim]) { return NaN; } var value = storage[dim][dataIndex]; // FIXME ordinal data type is not stackable if (stack) { var dimensionInfo = this._dimensionInfos[dim]; if (dimensionInfo && dimensionInfo.stackable) { var stackedOn = this.stackedOn; while (stackedOn) { // Get no stacked data of stacked on var stackedValue = stackedOn.get(dim, idx); // Considering positive stack, negative stack and empty data if ((value >= 0 && stackedValue > 0) // Positive stack || (value = min && coord 0 && max > 0 && !fixMin) { min = 0; } // Axis is under zero and max is not set if (min < 0 && max < 0 && !fixMax) { max = 0; } } return [min, max]; }; axisHelper.niceScaleExtent = function (scale, model) { var extent = axisHelper.getScaleExtent(scale, model); var fixMin = model.getMin() != null; var fixMax = model.getMax() != null; var splitNumber = model.get('splitNumber'); if (scale.type === 'log') { scale.base = model.get('logBase'); } var scaleType = scale.type; scale.setExtent(extent[0], extent[1]); scale.niceExtent({ splitNumber: splitNumber, fixMin: fixMin, fixMax: fixMax, minInterval: (scaleType === 'interval' || scaleType === 'time') ? model.get('minInterval') : null, maxInterval: (scaleType === 'interval' || scaleType === 'time') ? model.get('maxInterval') : null }); // If some one specified the min, max. And the default calculated interval // is not good enough. He can specify the interval. It is often appeared // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard // to be 60. // FIXME var interval = model.get('interval'); if (interval != null) { scale.setInterval && scale.setInterval(interval); } }; /** * @param {module:echarts/model/Model} model * @param {string} [axisType] Default retrieve from model.type * @return {module:echarts/scale/*} */ axisHelper.createScaleByModel = function(model, axisType) { axisType = axisType || model.get('type'); if (axisType) { switch (axisType) { // Buildin scale case 'category': return new OrdinalScale( model.getCategories(), [Infinity, -Infinity] ); case 'value': return new IntervalScale(); // Extended scale, like time and log default: return (Scale.getClass(axisType) || IntervalScale).create(model); } } }; /** * Check if the axis corss 0 */ axisHelper.ifAxisCrossZero = function (axis) { var dataExtent = axis.scale.getExtent(); var min = dataExtent[0]; var max = dataExtent[1]; return !((min > 0 && max > 0) || (min < 0 && max < 0)); }; /** * @param {Array.} tickCoords In axis self coordinate. * @param {Array.} labels * @param {string} font * @param {boolean} isAxisHorizontal * @return {number} */ axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) { // FIXME // 不同角的axis和label，不只是horizontal和vertical. var textSpaceTakenRect; var autoLabelInterval = 0; var accumulatedLabelInterval = 0; var step = 1; if (labels.length > 40) { // Simple optimization for large amount of labels step = Math.floor(labels.length / 40); } for (var i = 0; i < tickCoords.length; i += step) { var tickCoord = tickCoords[i]; var rect = textContain.getBoundingRect( labels[i], font, 'center', 'top' ); rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord; // FIXME Magic number 1.5 rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3; if (!textSpaceTakenRect) { textSpaceTakenRect = rect.clone(); } // There is no space for current label; else if (textSpaceTakenRect.intersect(rect)) { accumulatedLabelInterval++; autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval); } else { textSpaceTakenRect.union(rect); // Reset accumulatedLabelInterval = 0; } } if (autoLabelInterval === 0 && step > 1) { return step; } return (autoLabelInterval + 1) * step - 1; }; /** * @param {Object} axis * @param {Function} labelFormatter * @return {Array.} */ axisHelper.getFormattedLabels = function (axis, labelFormatter) { var scale = axis.scale; var labels = scale.getTicksLabels(); var ticks = scale.getTicks(); if (typeof labelFormatter === 'string') { labelFormatter = (function (tpl) { return function (val) { return tpl.replace('{value}', val != null ? val : ''); }; })(labelFormatter); // Consider empty array return zrUtil.map(labels, labelFormatter); } else if (typeof labelFormatter === 'function') { return zrUtil.map(ticks, function (tick, idx) { return labelFormatter( axisHelper.getAxisRawValue(axis, tick), idx ); }, this); } else { return labels; } }; axisHelper.getAxisRawValue = function (axis, value) { // In category axis with data zoom, tick is not the original // index of axis.data. So tick should not be exposed to user // in category axis. return axis.type === 'category' ? axis.scale.getLabel(value) : value; }; module.exports = axisHelper; /***/ }), /* 105 */ /***/ (function(module, exports, __webpack_require__) { /** * Linear continuous scale * @module echarts/coord/scale/Ordinal * * http://en.wikipedia.org/wiki/Level_of_measurement */ // FIXME only one data var zrUtil = __webpack_require__(4); var Scale = __webpack_require__(106); var scaleProto = Scale.prototype; var OrdinalScale = Scale.extend({ type: 'ordinal', init: function (data, extent) { this._data = data; this._extent = extent || [0, data.length - 1]; }, parse: function (val) { return typeof val === 'string' ? zrUtil.indexOf(this._data, val) // val might be float. : Math.round(val); }, contain: function (rank) { rank = this.parse(rank); return scaleProto.contain.call(this, rank) && this._data[rank] != null; }, /** * Normalize given rank or name to linear [0, 1] * @param {number|string} [val] * @return {number} */ normalize: function (val) { return scaleProto.normalize.call(this, this.parse(val)); }, scale: function (val) { return Math.round(scaleProto.scale.call(this, val)); }, /** * @return {Array} */ getTicks: function () { var ticks = []; var extent = this._extent; var rank = extent[0]; while (rank = extent[0] && val extent[1] && (extent[1] = other[1]); // not setExtent because in log axis it may transformed to power // this.setExtent(extent[0], extent[1]); }; /** * Set extent from data * @param {module:echarts/data/List} data * @param {string} dim */ scaleProto.unionExtentFromData = function (data, dim) { this.unionExtent(data.getDataExtent(dim, true)); }; /** * Get extent * @return {Array.} */ scaleProto.getExtent = function () { return this._extent.slice(); }; /** * Set extent * @param {number} start * @param {number} end */ scaleProto.setExtent = function (start, end) { var thisExtent = this._extent; if (!isNaN(start)) { thisExtent[0] = start; } if (!isNaN(end)) { thisExtent[1] = end; } }; /** * @return {Array.} */ scaleProto.getTicksLabels = function () { var labels = []; var ticks = this.getTicks(); for (var i = 0; i < ticks.length; i++) { labels.push(this.getLabel(ticks[i])); } return labels; }; /** * When axis extent depends on data and no data exists, * axis ticks should not be drawn, which is named 'blank'. */ scaleProto.isBlank = function () { return this._isBlank; }, /** * When axis extent depends on data and no data exists, * axis ticks should not be drawn, which is named 'blank'. */ scaleProto.setBlank = function (isBlank) { this._isBlank = isBlank; }; clazzUtil.enableClassExtend(Scale); clazzUtil.enableClassManagement(Scale, { registerWhenExtend: true }); module.exports = Scale; /***/ }), /* 107 */ /***/ (function(module, exports, __webpack_require__) { /** * Interval scale * @module echarts/scale/Interval */ var numberUtil = __webpack_require__(7); var formatUtil = __webpack_require__(6); var Scale = __webpack_require__(106); var helper = __webpack_require__(108); var roundNumber = numberUtil.round; /** * @alias module:echarts/coord/scale/Interval * @constructor */ var IntervalScale = Scale.extend({ type: 'interval', _interval: 0, _intervalPrecision: 2, setExtent: function (start, end) { var thisExtent = this._extent; //start,end may be a Number like '25',so... if (!isNaN(start)) { thisExtent[0] = parseFloat(start); } if (!isNaN(end)) { thisExtent[1] = parseFloat(end); } }, unionExtent: function (other) { var extent = this._extent; other[0] < extent[0] && (extent[0] = other[0]); other[1] > extent[1] && (extent[1] = other[1]); // unionExtent may called by it's sub classes IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]); }, /** * Get interval */ getInterval: function () { return this._interval; }, /** * Set interval */ setInterval: function (interval) { this._interval = interval; // Dropped auto calculated niceExtent and use user setted extent // We assume user wan't to set both interval, min, max to get a better result this._niceExtent = this._extent.slice(); this._intervalPrecision = helper.getIntervalPrecision(interval); }, /** * @return {Array.} */ getTicks: function () { return helper.intervalScaleGetTicks( this._interval, this._extent, this._niceExtent, this._intervalPrecision ); }, /** * @return {Array.} */ getTicksLabels: function () { var labels = []; var ticks = this.getTicks(); for (var i = 0; i < ticks.length; i++) { labels.push(this.getLabel(ticks[i])); } return labels; }, /** * @param {number} data * @param {Object} [opt] * @param {number|string} [opt.precision] If 'auto', use nice presision. * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2. * @return {string} */ getLabel: function (data, opt) { if (data == null) { return ''; } var precision = opt && opt.precision; if (precision == null) { precision = numberUtil.getPrecisionSafe(data) || 0; } else if (precision === 'auto') { // Should be more precise then tick. precision = this._intervalPrecision; } // (1) If `precision` is set, 12.005 should be display as '12.00500'. // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'. data = roundNumber(data, precision, true); return formatUtil.addCommas(data); }, /** * Update interval and extent of intervals for nice ticks * * @param {number} [splitNumber = 5] Desired number of ticks * @param {number} [minInterval] * @param {number} [maxInterval] */ niceTicks: function (splitNumber, minInterval, maxInterval) { splitNumber = splitNumber || 5; var extent = this._extent; var span = extent[1] - extent[0]; if (!isFinite(span)) { return; } // User may set axis min 0 and data are all negative // FIXME If it needs to reverse ? if (span < 0) { span = -span; extent.reverse(); } var result = helper.intervalScaleNiceTicks( extent, splitNumber, minInterval, maxInterval ); this._intervalPrecision = result.intervalPrecision; this._interval = result.interval; this._niceExtent = result.niceTickExtent; }, /** * Nice extent. * @param {Object} opt * @param {number} [opt.splitNumber = 5] Given approx tick number * @param {boolean} [opt.fixMin=false] * @param {boolean} [opt.fixMax=false] * @param {boolean} [opt.minInterval] * @param {boolean} [opt.maxInterval] */ niceExtent: function (opt) { var extent = this._extent; // If extent start and end are same, expand them if (extent[0] === extent[1]) { if (extent[0] !== 0) { // Expand extent var expandSize = extent[0]; // In the fowllowing case // Axis has been fixed max 100 // Plus data are all 100 and axis extent are [100, 100]. // Extend to the both side will cause expanded max is larger than fixed max. // So only expand to the smaller side. if (!opt.fixMax) { extent[1] += expandSize / 2; extent[0] -= expandSize / 2; } else { extent[0] -= expandSize / 2; } } else { extent[1] = 1; } } var span = extent[1] - extent[0]; // If there are no data and extent are [Infinity, -Infinity] if (!isFinite(span)) { extent[0] = 0; extent[1] = 1; } this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // var extent = this._extent; var interval = this._interval; if (!opt.fixMin) { extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval); } if (!opt.fixMax) { extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval); } } }); /** * @return {module:echarts/scale/Time} */ IntervalScale.create = function () { return new IntervalScale(); }; module.exports = IntervalScale; /***/ }), /* 108 */ /***/ (function(module, exports, __webpack_require__) { /** * For testable. */ var numberUtil = __webpack_require__(7); var roundNumber = numberUtil.round; var helper = {}; /** * @param {Array.} extent Both extent[0] and extent[1] should be valid number. * Should be extent[0] < extent[1]. * @param {number} splitNumber splitNumber should be >= 1. * @param {number} [minInterval] * @param {number} [maxInterval] * @return {Object} {interval, intervalPrecision, niceTickExtent} */ helper.intervalScaleNiceTicks = function (extent, splitNumber, minInterval, maxInterval) { var result = {}; var span = extent[1] - extent[0]; var interval = result.interval = numberUtil.nice(span / splitNumber, true); if (minInterval != null && interval < minInterval) { interval = result.interval = minInterval; } if (maxInterval != null && interval > maxInterval) { interval = result.interval = maxInterval; } // Tow more digital for tick. var precision = result.intervalPrecision = helper.getIntervalPrecision(interval); // Niced extent inside original extent var niceTickExtent = result.niceTickExtent = [ roundNumber(Math.ceil(extent[0] / interval) * interval, precision), roundNumber(Math.floor(extent[1] / interval) * interval, precision) ]; helper.fixExtent(niceTickExtent, extent); return result; }; /** * @param {number} interval * @return {number} interval precision */ helper.getIntervalPrecision = function (interval) { // Tow more digital for tick. return numberUtil.getPrecisionSafe(interval) + 2; }; function clamp(niceTickExtent, idx, extent) { niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]); } // In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent. helper.fixExtent = function (niceTickExtent, extent) { !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]); !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]); clamp(niceTickExtent, 0, extent); clamp(niceTickExtent, 1, extent); if (niceTickExtent[0] > niceTickExtent[1]) { niceTickExtent[0] = niceTickExtent[1]; } }; helper.intervalScaleGetTicks = function (interval, extent, niceTickExtent, intervalPrecision) { var ticks = []; // If interval is 0, return []; if (!interval) { return ticks; } // Consider this case: using dataZoom toolbox, zoom and zoom. var safeLimit = 10000; if (extent[0] < niceTickExtent[0]) { ticks.push(extent[0]); } var tick = niceTickExtent[0]; while (tick safeLimit) { return []; } } // Consider this case: the last item of ticks is smaller // than niceTickExtent[1] and niceTickExtent[1] === extent[1]. if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1])) { ticks.push(extent[1]); } return ticks; }; module.exports = helper; /***/ }), /* 109 */ /***/ (function(module, exports, __webpack_require__) { /** * Interval scale * @module echarts/coord/scale/Time */ // [About UTC and local time zone]: // In most cases, `number.parseDate` will treat input data string as local time // (except time zone is specified in time string). And `format.formateTime` returns // local time by default. option.useUTC is false by default. This design have // concidered these common case: // (1) Time that is persistent in server is in UTC, but it is needed to be diplayed // in local time by default. // (2) By default, the input data string (e.g., '2011-01-02') should be displayed // as its original time, without any time difference. var zrUtil = __webpack_require__(4); var numberUtil = __webpack_require__(7); var formatUtil = __webpack_require__(6); var scaleHelper = __webpack_require__(108); var IntervalScale = __webpack_require__(107); var intervalScaleProto = IntervalScale.prototype; var mathCeil = Math.ceil; var mathFloor = Math.floor; var ONE_SECOND = 1000; var ONE_MINUTE = ONE_SECOND * 60; var ONE_HOUR = ONE_MINUTE * 60; var ONE_DAY = ONE_HOUR * 24; // FIXME 公用？ var bisect = function (a, x, lo, hi) { while (lo < hi) { var mid = lo + hi >>> 1; if (a[mid][2] < x) { lo = mid + 1; } else { hi = mid; } } return lo; }; /** * @alias module:echarts/coord/scale/Time * @constructor */ var TimeScale = IntervalScale.extend({ type: 'time', /** * @override */ getLabel: function (val) { var stepLvl = this._stepLvl; var date = new Date(val); return formatUtil.formatTime(stepLvl[0], date, this.getSetting('useUTC')); }, /** * @override */ niceExtent: function (opt) { var extent = this._extent; // If extent start and end are same, expand them if (extent[0] === extent[1]) { // Expand extent extent[0] -= ONE_DAY; extent[1] += ONE_DAY; } // If there are no data and extent are [Infinity, -Infinity] if (extent[1] === -Infinity && extent[0] === Infinity) { var d = new Date(); extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate()); extent[0] = extent[1] - ONE_DAY; } this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval); // var extent = this._extent; var interval = this._interval; if (!opt.fixMin) { extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval); } if (!opt.fixMax) { extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval); } }, /** * @override */ niceTicks: function (approxTickNum, minInterval, maxInterval) { approxTickNum = approxTickNum || 10; var extent = this._extent; var span = extent[1] - extent[0]; var approxInterval = span / approxTickNum; if (minInterval != null && approxInterval < minInterval) { approxInterval = minInterval; } if (maxInterval != null && approxInterval > maxInterval) { approxInterval = maxInterval; } var scaleLevelsLen = scaleLevels.length; var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen); var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)]; var interval = level[2]; // Same with interval scale if span is much larger than 1 year if (level[0] === 'year') { var yearSpan = span / interval; // From \"Nice Numbers for Graph Labels\" of Graphic Gems // var niceYearSpan = numberUtil.nice(yearSpan, false); var yearStep = numberUtil.nice(yearSpan / approxTickNum, true); interval *= yearStep; } var timezoneOffset = this.getSetting('useUTC') ? 0 : (new Date(+extent[0] || +extent[1])).getTimezoneOffset() * 60 * 1000; var niceExtent = [ Math.round(mathCeil((extent[0] - timezoneOffset) / interval) * interval + timezoneOffset), Math.round(mathFloor((extent[1] - timezoneOffset) / interval) * interval + timezoneOffset) ]; scaleHelper.fixExtent(niceExtent, extent); this._stepLvl = level; // Interval will be used in getTicks this._interval = interval; this._niceExtent = niceExtent; }, parse: function (val) { // val might be float. return +numberUtil.parseDate(val); } }); zrUtil.each(['contain', 'normalize'], function (methodName) { TimeScale.prototype[methodName] = function (val) { return intervalScaleProto[methodName].call(this, this.parse(val)); }; }); // Steps from d3 var scaleLevels = [ // Format step interval ['hh:mm:ss', 1, ONE_SECOND], // 1s ['hh:mm:ss', 5, ONE_SECOND * 5], // 5s ['hh:mm:ss', 10, ONE_SECOND * 10], // 10s ['hh:mm:ss', 15, ONE_SECOND * 15], // 15s ['hh:mm:ss', 30, ONE_SECOND * 30], // 30s ['hh:mm\\nMM-dd',1, ONE_MINUTE], // 1m ['hh:mm\\nMM-dd',5, ONE_MINUTE * 5], // 5m ['hh:mm\\nMM-dd',10, ONE_MINUTE * 10], // 10m ['hh:mm\\nMM-dd',15, ONE_MINUTE * 15], // 15m ['hh:mm\\nMM-dd',30, ONE_MINUTE * 30], // 30m ['hh:mm\\nMM-dd',1, ONE_HOUR], // 1h ['hh:mm\\nMM-dd',2, ONE_HOUR * 2], // 2h ['hh:mm\\nMM-dd',6, ONE_HOUR * 6], // 6h ['hh:mm\\nMM-dd',12, ONE_HOUR * 12], // 12h ['MM-dd\\nyyyy', 1, ONE_DAY], // 1d ['week', 7, ONE_DAY * 7], // 7d ['month', 1, ONE_DAY * 31], // 1M ['quarter', 3, ONE_DAY * 380 / 4], // 3M ['half-year', 6, ONE_DAY * 380 / 2], // 6M ['year', 1, ONE_DAY * 380] // 1Y ]; /** * @param {module:echarts/model/Model} * @return {module:echarts/scale/Time} */ TimeScale.create = function (model) { return new TimeScale({useUTC: model.ecModel.get('useUTC')}); }; module.exports = TimeScale; /***/ }), /* 110 */ /***/ (function(module, exports, __webpack_require__) { /** * Log scale * @module echarts/scale/Log */ var zrUtil = __webpack_require__(4); var Scale = __webpack_require__(106); var numberUtil = __webpack_require__(7); // Use some method of IntervalScale var IntervalScale = __webpack_require__(107); var scaleProto = Scale.prototype; var intervalScaleProto = IntervalScale.prototype; var getPrecisionSafe = numberUtil.getPrecisionSafe; var roundingErrorFix = numberUtil.round; var mathFloor = Math.floor; var mathCeil = Math.ceil; var mathPow = Math.pow; var mathLog = Math.log; var LogScale = Scale.extend({ type: 'log', base: 10, $constructor: function () { Scale.apply(this, arguments); this._originalScale = new IntervalScale(); }, /** * @return {Array.} */ getTicks: function () { var originalScale = this._originalScale; var extent = this._extent; var originalExtent = originalScale.getExtent(); return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) { var powVal = numberUtil.round(mathPow(this.base, val)); // Fix #4158 powVal = (val === extent[0] && originalScale.__fixMin) ? fixRoundingError(powVal, originalExtent[0]) : powVal; powVal = (val === extent[1] && originalScale.__fixMax) ? fixRoundingError(powVal, originalExtent[1]) : powVal; return powVal; }, this); }, /** * @param {number} val * @return {string} */ getLabel: intervalScaleProto.getLabel, /** * @param {number} val * @return {number} */ scale: function (val) { val = scaleProto.scale.call(this, val); return mathPow(this.base, val); }, /** * @param {number} start * @param {number} end */ setExtent: function (start, end) { var base = this.base; start = mathLog(start) / mathLog(base); end = mathLog(end) / mathLog(base); intervalScaleProto.setExtent.call(this, start, end); }, /** * @return {number} end */ getExtent: function () { var base = this.base; var extent = scaleProto.getExtent.call(this); extent[0] = mathPow(base, extent[0]); extent[1] = mathPow(base, extent[1]); // Fix #4158 var originalScale = this._originalScale; var originalExtent = originalScale.getExtent(); originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0])); originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1])); return extent; }, /** * @param {Array.} extent */ unionExtent: function (extent) { this._originalScale.unionExtent(extent); var base = this.base; extent[0] = mathLog(extent[0]) / mathLog(base); extent[1] = mathLog(extent[1]) / mathLog(base); scaleProto.unionExtent.call(this, extent); }, /** * @override */ unionExtentFromData: function (data, dim) { this.unionExtent(data.getDataExtent(dim, true, function (val) { return val > 0; })); }, /** * Update interval and extent of intervals for nice ticks * @param {number} [approxTickNum = 10] Given approx tick number */ niceTicks: function (approxTickNum) { approxTickNum = approxTickNum || 10; var extent = this._extent; var span = extent[1] - extent[0]; if (span === Infinity || span Array.` * `getCategories() => Array.` * `getMin(origin: boolean) => number` * `getMax(origin: boolean) => number` * `getNeedCrossZero() => boolean` * `setRange(start: number, end: number)` * `resetRange()` */ mixinAxisModelCommonMethods: function (Model) { util.mixin(Model, axisModelCommonMixin); } }; /***/ }), /* 112 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var List = __webpack_require__(101); var completeDimensions = __webpack_require__(113); var zrUtil = __webpack_require__(4); var modelUtil = __webpack_require__(5); var CoordinateSystem = __webpack_require__(79); var getDataItemValue = modelUtil.getDataItemValue; var converDataValue = modelUtil.converDataValue; function firstDataNotNull(data) { var i = 0; while (i < data.length && data[i] == null) { i++; } return data[i]; } function ifNeedCompleteOrdinalData(data) { var sampleItem = firstDataNotNull(data); return sampleItem != null && !zrUtil.isArray(getDataItemValue(sampleItem)); } /** * Helper function to create a list from option data */ function createListFromArray(data, seriesModel, ecModel) { // If data is undefined data = data || []; if (true) { if (!zrUtil.isArray(data)) { throw new Error('Invalid data.'); } } var coordSysName = seriesModel.get('coordinateSystem'); var creator = creators[coordSysName]; var registeredCoordSys = CoordinateSystem.get(coordSysName); var completeDimOpt = { encodeDef: seriesModel.get('encode'), dimsDef: seriesModel.get('dimensions') }; // FIXME var axesInfo = creator && creator(data, seriesModel, ecModel, completeDimOpt); var dimensions = axesInfo && axesInfo.dimensions; if (!dimensions) { // Get dimensions from registered coordinate system dimensions = (registeredCoordSys && ( registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice() )) || ['x', 'y']; dimensions = completeDimensions(dimensions, data, completeDimOpt); } var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1; var list = new List(dimensions, seriesModel); var nameList = createNameList(axesInfo, data); var categories = {}; var dimValueGetter = (categoryIndex >= 0 && ifNeedCompleteOrdinalData(data)) ? function (itemOpt, dimName, dataIndex, dimIndex) { // If any dataItem is like { value: 10 } if (modelUtil.isDataItemOption(itemOpt)) { list.hasItemOption = true; } // Use dataIndex as ordinal value in categoryAxis return dimIndex === categoryIndex ? dataIndex : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]); } : function (itemOpt, dimName, dataIndex, dimIndex) { var value = getDataItemValue(itemOpt); var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]); // If any dataItem is like { value: 10 } if (modelUtil.isDataItemOption(itemOpt)) { list.hasItemOption = true; } var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels; if (categoryAxesModels && categoryAxesModels[dimName]) { // If given value is a category string if (typeof val === 'string') { // Lazy get categories categories[dimName] = categories[dimName] || categoryAxesModels[dimName].getCategories(); val = zrUtil.indexOf(categories[dimName], val); if (val < 0 && !isNaN(val)) { // In case some one write '1', '2' istead of 1, 2 val = +val; } } } return val; }; list.hasItemOption = false; list.initData(data, nameList, dimValueGetter); return list; } function isStackable(axisType) { return axisType !== 'category' && axisType !== 'time'; } function getDimTypeByAxis(axisType) { return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float'; } /** * Creaters for each coord system. */ var creators = { cartesian2d: function (data, seriesModel, ecModel, completeDimOpt) { var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) { return ecModel.queryComponents({ mainType: name, index: seriesModel.get(name + 'Index'), id: seriesModel.get(name + 'Id') })[0]; }); var xAxisModel = axesModels[0]; var yAxisModel = axesModels[1]; if (true) { if (!xAxisModel) { throw new Error('xAxis \"' + zrUtil.retrieve( seriesModel.get('xAxisIndex'), seriesModel.get('xAxisId'), 0 ) + '\" not found'); } if (!yAxisModel) { throw new Error('yAxis \"' + zrUtil.retrieve( seriesModel.get('xAxisIndex'), seriesModel.get('yAxisId'), 0 ) + '\" not found'); } } var xAxisType = xAxisModel.get('type'); var yAxisType = yAxisModel.get('type'); var dimensions = [ { name: 'x', type: getDimTypeByAxis(xAxisType), stackable: isStackable(xAxisType) }, { name: 'y', // If two category axes type: getDimTypeByAxis(yAxisType), stackable: isStackable(yAxisType) } ]; var isXAxisCateogry = xAxisType === 'category'; var isYAxisCategory = yAxisType === 'category'; dimensions = completeDimensions(dimensions, data, completeDimOpt); var categoryAxesModels = {}; if (isXAxisCateogry) { categoryAxesModels.x = xAxisModel; } if (isYAxisCategory) { categoryAxesModels.y = yAxisModel; } return { dimensions: dimensions, categoryIndex: isXAxisCateogry ? 0 : (isYAxisCategory ? 1 : -1), categoryAxesModels: categoryAxesModels }; }, singleAxis: function (data, seriesModel, ecModel, completeDimOpt) { var singleAxisModel = ecModel.queryComponents({ mainType: 'singleAxis', index: seriesModel.get('singleAxisIndex'), id: seriesModel.get('singleAxisId') })[0]; if (true) { if (!singleAxisModel) { throw new Error('singleAxis should be specified.'); } } var singleAxisType = singleAxisModel.get('type'); var isCategory = singleAxisType === 'category'; var dimensions = [{ name: 'single', type: getDimTypeByAxis(singleAxisType), stackable: isStackable(singleAxisType) }]; dimensions = completeDimensions(dimensions, data, completeDimOpt); var categoryAxesModels = {}; if (isCategory) { categoryAxesModels.single = singleAxisModel; } return { dimensions: dimensions, categoryIndex: isCategory ? 0 : -1, categoryAxesModels: categoryAxesModels }; }, polar: function (data, seriesModel, ecModel, completeDimOpt) { var polarModel = ecModel.queryComponents({ mainType: 'polar', index: seriesModel.get('polarIndex'), id: seriesModel.get('polarId') })[0]; var angleAxisModel = polarModel.findAxisModel('angleAxis'); var radiusAxisModel = polarModel.findAxisModel('radiusAxis'); if (true) { if (!angleAxisModel) { throw new Error('angleAxis option not found'); } if (!radiusAxisModel) { throw new Error('radiusAxis option not found'); } } var radiusAxisType = radiusAxisModel.get('type'); var angleAxisType = angleAxisModel.get('type'); var dimensions = [ { name: 'radius', type: getDimTypeByAxis(radiusAxisType), stackable: isStackable(radiusAxisType) }, { name: 'angle', type: getDimTypeByAxis(angleAxisType), stackable: isStackable(angleAxisType) } ]; var isAngleAxisCateogry = angleAxisType === 'category'; var isRadiusAxisCateogry = radiusAxisType === 'category'; dimensions = completeDimensions(dimensions, data, completeDimOpt); var categoryAxesModels = {}; if (isRadiusAxisCateogry) { categoryAxesModels.radius = radiusAxisModel; } if (isAngleAxisCateogry) { categoryAxesModels.angle = angleAxisModel; } return { dimensions: dimensions, categoryIndex: isAngleAxisCateogry ? 1 : (isRadiusAxisCateogry ? 0 : -1), categoryAxesModels: categoryAxesModels }; }, geo: function (data, seriesModel, ecModel, completeDimOpt) { // TODO Region // 多个散点图系列在同一个地区的时候 return { dimensions: completeDimensions([ {name: 'lng'}, {name: 'lat'} ], data, completeDimOpt) }; } }; function createNameList(result, data) { var nameList = []; var categoryDim = result && result.dimensions[result.categoryIndex]; var categoryAxisModel; if (categoryDim) { categoryAxisModel = result.categoryAxesModels[categoryDim.name]; } if (categoryAxisModel) { // FIXME Two category axis var categories = categoryAxisModel.getCategories(); if (categories) { var dataLen = data.length; // Ordered data is given explicitly like // [[3, 0.2], [1, 0.3], [2, 0.15]] // or given scatter data, // pick the category if (zrUtil.isArray(data[0]) && data[0].length > 1) { nameList = []; for (var i = 0; i < dataLen; i++) { nameList[i] = categories[data[i][result.categoryIndex || 0]]; } } else { nameList = categories.slice(0); } } } return nameList; } module.exports = createListFromArray; /***/ }), /* 113 */ /***/ (function(module, exports, __webpack_require__) { /** * Complete dimensions by data (guess dimension). */ var zrUtil = __webpack_require__(4); var modelUtil = __webpack_require__(5); var each = zrUtil.each; var isString = zrUtil.isString; var defaults = zrUtil.defaults; var normalizeToArray = modelUtil.normalizeToArray; var OTHER_DIMS = {tooltip: 1, label: 1, itemName: 1}; /** * Complete the dimensions array, by user defined `dimension` and `encode`, * and guessing from the data structure. * If no 'value' dimension specified, the first no-named dimension will be * named as 'value'. * * @param {Array.} sysDims Necessary dimensions, like ['x', 'y'], which * provides not only dim template, but also default order. * `name` of each item provides default coord name. * [{dimsDef: []}, ...] can be specified to give names. * @param {Array} data Data list. [[1, 2, 3], [2, 3, 4]]. * @param {Object} [opt] * @param {Array.} [opt.dimsDef] option.series.dimensions User defined dimensions * For example: ['asdf', {name, type}, ...]. * @param {Object} [opt.encodeDef] option.series.encode {x: 2, y: [3, 1], tooltip: [1, 2], label: 3} * @param {string} [opt.extraPrefix] Prefix of name when filling the left dimensions. * @param {string} [opt.extraFromZero] If specified, extra dim names will be: * extraPrefix + 0, extraPrefix + extraBaseIndex + 1 ... * If not specified, extra dim names will be: * extraPrefix, extraPrefix + 0, extraPrefix + 1 ... * @param {number} [opt.dimCount] If not specified, guess by the first data item. * @return {Array.} [{ * name: string mandatory, * coordDim: string mandatory, * coordDimIndex: number mandatory, * type: string optional, * tooltipName: string optional, * otherDims: { * tooltip: number optional, * label: number optional * }, * isExtraCoord: boolean true or undefined. * other props ... * }] */ function completeDimensions(sysDims, data, opt) { data = data || []; opt = opt || {}; sysDims = (sysDims || []).slice(); var dimsDef = (opt.dimsDef || []).slice(); var encodeDef = zrUtil.createHashMap(opt.encodeDef); var dataDimNameMap = zrUtil.createHashMap(); var coordDimNameMap = zrUtil.createHashMap(); // var valueCandidate; var result = []; var dimCount = opt.dimCount; if (dimCount == null) { var value0 = retrieveValue(data[0]); dimCount = Math.max( zrUtil.isArray(value0) && value0.length || 1, sysDims.length, dimsDef.length ); each(sysDims, function (sysDimItem) { var sysDimItemDimsDef = sysDimItem.dimsDef; sysDimItemDimsDef && (dimCount = Math.max(dimCount, sysDimItemDimsDef.length)); }); } // Apply user defined dims (`name` and `type`) and init result. for (var i = 0; i < dimCount; i++) { var dimDefItem = isString(dimsDef[i]) ? {name: dimsDef[i]} : (dimsDef[i] || {}); var userDimName = dimDefItem.name; var resultItem = result[i] = {otherDims: {}}; // Name will be applied later for avoiding duplication. if (userDimName != null && dataDimNameMap.get(userDimName) == null) { // Only if `series.dimensions` is defined in option, tooltipName // will be set, and dimension will be diplayed vertically in // tooltip by default. resultItem.name = resultItem.tooltipName = userDimName; dataDimNameMap.set(userDimName, i); } dimDefItem.type != null && (resultItem.type = dimDefItem.type); } // Set `coordDim` and `coordDimIndex` by `encodeDef` and normalize `encodeDef`. encodeDef.each(function (dataDims, coordDim) { dataDims = encodeDef.set(coordDim, normalizeToArray(dataDims).slice()); each(dataDims, function (resultDimIdx, coordDimIndex) { // The input resultDimIdx can be dim name or index. isString(resultDimIdx) && (resultDimIdx = dataDimNameMap.get(resultDimIdx)); if (resultDimIdx != null && resultDimIdx < dimCount) { dataDims[coordDimIndex] = resultDimIdx; applyDim(result[resultDimIdx], coordDim, coordDimIndex); } }); }); // Apply templetes and default order from `sysDims`. var availDimIdx = 0; each(sysDims, function (sysDimItem, sysDimIndex) { var coordDim; var sysDimItem; var sysDimItemDimsDef; var sysDimItemOtherDims; if (isString(sysDimItem)) { coordDim = sysDimItem; sysDimItem = {}; } else { coordDim = sysDimItem.name; sysDimItem = zrUtil.clone(sysDimItem); // `coordDimIndex` should not be set directly. sysDimItemDimsDef = sysDimItem.dimsDef; sysDimItemOtherDims = sysDimItem.otherDims; sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null; } var dataDims = normalizeToArray(encodeDef.get(coordDim)); // dimensions provides default dim sequences. if (!dataDims.length) { for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) { while (availDimIdx < result.length && result[availDimIdx].coordDim != null) { availDimIdx++; } availDimIdx < result.length && dataDims.push(availDimIdx++); } } // Apply templates. each(dataDims, function (resultDimIdx, coordDimIndex) { var resultItem = result[resultDimIdx]; applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex); if (resultItem.name == null && sysDimItemDimsDef) { resultItem.name = resultItem.tooltipName = sysDimItemDimsDef[coordDimIndex]; } sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims); }); }); // Make sure the first extra dim is 'value'. var extra = opt.extraPrefix || 'value'; // Set dim `name` and other `coordDim` and other props. for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) { var resultItem = result[resultDimIdx] = result[resultDimIdx] || {}; var coordDim = resultItem.coordDim; coordDim == null && ( resultItem.coordDim = genName(extra, coordDimNameMap, opt.extraFromZero), resultItem.coordDimIndex = 0, resultItem.isExtraCoord = true ); resultItem.name == null && (resultItem.name = genName( resultItem.coordDim, dataDimNameMap )); resultItem.type == null && guessOrdinal(data, resultDimIdx) && (resultItem.type = 'ordinal'); } return result; function applyDim(resultItem, coordDim, coordDimIndex) { if (OTHER_DIMS[coordDim]) { resultItem.otherDims[coordDim] = coordDimIndex; } else { resultItem.coordDim = coordDim; resultItem.coordDimIndex = coordDimIndex; coordDimNameMap.set(coordDim, true); } } function genName(name, map, fromZero) { if (fromZero || map.get(name) != null) { var i = 0; while (map.get(name + i) != null) { i++; } name += i; } map.set(name, true); return name; } } // The rule should not be complex, otherwise user might not // be able to known where the data is wrong. var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) { for (var i = 0, len = data.length; i < len; i++) { var value = retrieveValue(data[i]); if (!zrUtil.isArray(value)) { return false; } var value = value[dimIndex]; // Consider usage convenience, '1', '2' will be treated as \"number\". // `isFinit('')` get `true`. if (value != null && isFinite(value) && value !== '') { return false; } else if (isString(value) && value !== '-') { return true; } } return false; }; function retrieveValue(o) { return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value: o; } module.exports = completeDimensions; /***/ }), /* 114 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // Symbol factory var graphic = __webpack_require__(20); var BoundingRect = __webpack_require__(9); /** * Triangle shape * @inner */ var Triangle = graphic.extendShape({ type: 'triangle', shape: { cx: 0, cy: 0, width: 0, height: 0 }, buildPath: function (path, shape) { var cx = shape.cx; var cy = shape.cy; var width = shape.width / 2; var height = shape.height / 2; path.moveTo(cx, cy - height); path.lineTo(cx + width, cy + height); path.lineTo(cx - width, cy + height); path.closePath(); } }); /** * Diamond shape * @inner */ var Diamond = graphic.extendShape({ type: 'diamond', shape: { cx: 0, cy: 0, width: 0, height: 0 }, buildPath: function (path, shape) { var cx = shape.cx; var cy = shape.cy; var width = shape.width / 2; var height = shape.height / 2; path.moveTo(cx, cy - height); path.lineTo(cx + width, cy); path.lineTo(cx, cy + height); path.lineTo(cx - width, cy); path.closePath(); } }); /** * Pin shape * @inner */ var Pin = graphic.extendShape({ type: 'pin', shape: { // x, y on the cusp x: 0, y: 0, width: 0, height: 0 }, buildPath: function (path, shape) { var x = shape.x; var y = shape.y; var w = shape.width / 5 * 3; // Height must be larger than width var h = Math.max(w, shape.height); var r = w / 2; // Dist on y with tangent point and circle center var dy = r * r / (h - r); var cy = y - h + r + dy; var angle = Math.asin(dy / r); // Dist on x with tangent point and circle center var dx = Math.cos(angle) * r; var tanX = Math.sin(angle); var tanY = Math.cos(angle); path.arc( x, cy, r, Math.PI - angle, Math.PI * 2 + angle ); var cpLen = r * 0.6; var cpLen2 = r * 0.7; path.bezierCurveTo( x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y ); path.bezierCurveTo( x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy ); path.closePath(); } }); /** * Arrow shape * @inner */ var Arrow = graphic.extendShape({ type: 'arrow', shape: { x: 0, y: 0, width: 0, height: 0 }, buildPath: function (ctx, shape) { var height = shape.height; var width = shape.width; var x = shape.x; var y = shape.y; var dx = width / 3 * 2; ctx.moveTo(x, y); ctx.lineTo(x + dx, y + height); ctx.lineTo(x, y + height / 4 * 3); ctx.lineTo(x - dx, y + height); ctx.lineTo(x, y); ctx.closePath(); } }); /** * Map of path contructors * @type {Object.} */ var symbolCtors = { line: graphic.Line, rect: graphic.Rect, roundRect: graphic.Rect, square: graphic.Rect, circle: graphic.Circle, diamond: Diamond, pin: Pin, arrow: Arrow, triangle: Triangle }; var symbolShapeMakers = { line: function (x, y, w, h, shape) { // FIXME shape.x1 = x; shape.y1 = y + h / 2; shape.x2 = x + w; shape.y2 = y + h / 2; }, rect: function (x, y, w, h, shape) { shape.x = x; shape.y = y; shape.width = w; shape.height = h; }, roundRect: function (x, y, w, h, shape) { shape.x = x; shape.y = y; shape.width = w; shape.height = h; shape.r = Math.min(w, h) / 4; }, square: function (x, y, w, h, shape) { var size = Math.min(w, h); shape.x = x; shape.y = y; shape.width = size; shape.height = size; }, circle: function (x, y, w, h, shape) { // Put circle in the center of square shape.cx = x + w / 2; shape.cy = y + h / 2; shape.r = Math.min(w, h) / 2; }, diamond: function (x, y, w, h, shape) { shape.cx = x + w / 2; shape.cy = y + h / 2; shape.width = w; shape.height = h; }, pin: function (x, y, w, h, shape) { shape.x = x + w / 2; shape.y = y + h / 2; shape.width = w; shape.height = h; }, arrow: function (x, y, w, h, shape) { shape.x = x + w / 2; shape.y = y + h / 2; shape.width = w; shape.height = h; }, triangle: function (x, y, w, h, shape) { shape.cx = x + w / 2; shape.cy = y + h / 2; shape.width = w; shape.height = h; } }; var symbolBuildProxies = {}; for (var name in symbolCtors) { if (symbolCtors.hasOwnProperty(name)) { symbolBuildProxies[name] = new symbolCtors[name](); } } var Symbol = graphic.extendShape({ type: 'symbol', shape: { symbolType: '', x: 0, y: 0, width: 0, height: 0 }, beforeBrush: function () { var style = this.style; var shape = this.shape; // FIXME if (shape.symbolType === 'pin' && style.textPosition === 'inside') { style.textPosition = ['50%', '40%']; style.textAlign = 'center'; style.textVerticalAlign = 'middle'; } }, buildPath: function (ctx, shape, inBundle) { var symbolType = shape.symbolType; var proxySymbol = symbolBuildProxies[symbolType]; if (shape.symbolType !== 'none') { if (!proxySymbol) { // Default rect symbolType = 'rect'; proxySymbol = symbolBuildProxies[symbolType]; } symbolShapeMakers[symbolType]( shape.x, shape.y, shape.width, shape.height, proxySymbol.shape ); proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle); } } }); // Provide setColor helper method to avoid determine if set the fill or stroke outside var symbolPathSetColor = function (color) { if (this.type !== 'image') { var symbolStyle = this.style; var symbolShape = this.shape; if (symbolShape && symbolShape.symbolType === 'line') { symbolStyle.stroke = color; } else if (this.__isEmptyBrush) { symbolStyle.stroke = color; symbolStyle.fill = '#fff'; } else { // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ? symbolStyle.fill && (symbolStyle.fill = color); symbolStyle.stroke && (symbolStyle.stroke = color); } this.dirty(false); } }; var symbolUtil = { /** * Create a symbol element with given symbol configuration: shape, x, y, width, height, color * @param {string} symbolType * @param {number} x * @param {number} y * @param {number} w * @param {number} h * @param {string} color */ createSymbol: function (symbolType, x, y, w, h, color) { // TODO Support image object, DynamicImage. var isEmpty = symbolType.indexOf('empty') === 0; if (isEmpty) { symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6); } var symbolPath; if (symbolType.indexOf('image://') === 0) { symbolPath = new graphic.Image({ style: { image: symbolType.slice(8), x: x, y: y, width: w, height: h } }); } else if (symbolType.indexOf('path://') === 0) { symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h)); } else { symbolPath = new Symbol({ shape: { symbolType: symbolType, x: x, y: y, width: w, height: h } }); } symbolPath.__isEmptyBrush = isEmpty; symbolPath.setColor = symbolPathSetColor; symbolPath.setColor(color); return symbolPath; } }; module.exports = symbolUtil; /***/ }), /* 115 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); var axisHelper = __webpack_require__(104); function getName(obj) { if (zrUtil.isObject(obj) && obj.value != null) { return obj.value; } else { return obj + ''; } } module.exports = { /** * Format labels * @return {Array.} */ getFormattedLabels: function () { return axisHelper.getFormattedLabels( this.axis, this.get('axisLabel.formatter') ); }, /** * Get categories */ getCategories: function () { return this.get('type') === 'category' && zrUtil.map(this.get('data'), getName); }, /** * @param {boolean} origin * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN */ getMin: function (origin) { var option = this.option; var min = (!origin && option.rangeStart != null) ? option.rangeStart : option.min; if (this.axis && min != null && min !== 'dataMin' && typeof min !== 'function' && !zrUtil.eqNaN(min) ) { min = this.axis.scale.parse(min); } return min; }, /** * @param {boolean} origin * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN */ getMax: function (origin) { var option = this.option; var max = (!origin && option.rangeEnd != null) ? option.rangeEnd : option.max; if (this.axis && max != null && max !== 'dataMax' && typeof max !== 'function' && !zrUtil.eqNaN(max) ) { max = this.axis.scale.parse(max); } return max; }, /** * @return {boolean} */ getNeedCrossZero: function () { var option = this.option; return (option.rangeStart != null || option.rangeEnd != null) ? false : !option.scale; }, /** * Should be implemented by each axis model if necessary. * @return {module:echarts/model/Component} coordinate system model */ getCoordSysModel: zrUtil.noop, /** * @param {number} rangeStart Can only be finite number or null/undefined or NaN. * @param {number} rangeEnd Can only be finite number or null/undefined or NaN. */ setRange: function (rangeStart, rangeEnd) { this.option.rangeStart = rangeStart; this.option.rangeEnd = rangeEnd; }, /** * Reset range */ resetRange: function () { // rangeStart and rangeEnd is readonly. this.option.rangeStart = this.option.rangeEnd = null; } }; /***/ }), /* 116 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); var echarts = __webpack_require__(1); var PRIORITY = echarts.PRIORITY; __webpack_require__(117); __webpack_require__(118); echarts.registerVisual(zrUtil.curry( __webpack_require__(124), 'line', 'circle', 'line' )); echarts.registerLayout(zrUtil.curry( __webpack_require__(125), 'line' )); // Down sample after filter echarts.registerProcessor(PRIORITY.PROCESSOR.STATISTIC, zrUtil.curry( __webpack_require__(126), 'line' )); // In case developer forget to include grid component __webpack_require__(127); /***/ }), /* 117 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var createListFromArray = __webpack_require__(112); var SeriesModel = __webpack_require__(83); module.exports = SeriesModel.extend({ type: 'series.line', dependencies: ['grid', 'polar'], getInitialData: function (option, ecModel) { if (true) { var coordSys = option.coordinateSystem; if (coordSys !== 'polar' && coordSys !== 'cartesian2d') { throw new Error('Line not support coordinateSystem besides cartesian and polar'); } } return createListFromArray(option.data, this, ecModel); }, defaultOption: { zlevel: 0, // 一级层叠 z: 2, // 二级层叠 coordinateSystem: 'cartesian2d', legendHoverLink: true, hoverAnimation: true, // stack: null // xAxisIndex: 0, // yAxisIndex: 0, // polarIndex: 0, // If clip the overflow value clipOverflow: true, // cursor: null, label: { normal: { position: 'top' } }, // itemStyle: { // normal: {}, // emphasis: {} // }, lineStyle: { normal: { width: 2, type: 'solid' } }, // areaStyle: {}, // false, 'start', 'end', 'middle' step: false, // Disabled if step is true smooth: false, smoothMonotone: null, // 拐点图形类型 symbol: 'emptyCircle', // 拐点图形大小 symbolSize: 4, // 拐点图形旋转控制 symbolRotate: null, // 是否显示 symbol, 只有在 tooltip hover 的时候显示 showSymbol: true, // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略） showAllSymbol: false, // 是否连接断点 connectNulls: false, // 数据过滤，'average', 'max', 'min', 'sum' sampling: 'none', animationEasing: 'linear', // Disable progressive progressive: 0, hoverLayerThreshold: Infinity } }); /***/ }), /* 118 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // FIXME step not support polar var zrUtil = __webpack_require__(4); var SymbolDraw = __webpack_require__(119); var Symbol = __webpack_require__(120); var lineAnimationDiff = __webpack_require__(122); var graphic = __webpack_require__(20); var modelUtil = __webpack_require__(5); var polyHelper = __webpack_require__(123); var ChartView = __webpack_require__(85); function isPointsSame(points1, points2) { if (points1.length !== points2.length) { return; } for (var i = 0; i < points1.length; i++) { var p1 = points1[i]; var p2 = points2[i]; if (p1[0] !== p2[0] || p1[1] !== p2[1]) { return; } } return true; } function getSmooth(smooth) { return typeof (smooth) === 'number' ? smooth : (smooth ? 0.3 : 0); } function getAxisExtentWithGap(axis) { var extent = axis.getGlobalExtent(); if (axis.onBand) { // Remove extra 1px to avoid line miter in clipped edge var halfBandWidth = axis.getBandWidth() / 2 - 1; var dir = extent[1] > extent[0] ? 1 : -1; extent[0] += dir * halfBandWidth; extent[1] -= dir * halfBandWidth; } return extent; } function sign(val) { return val >= 0 ? 1 : -1; } /** * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys * @param {module:echarts/data/List} data * @param {Array.} points * @private */ function getStackedOnPoints(coordSys, data) { var baseAxis = coordSys.getBaseAxis(); var valueAxis = coordSys.getOtherAxis(baseAxis); var valueStart = 0; if (!baseAxis.onZero) { var extent = valueAxis.scale.getExtent(); if (extent[0] > 0) { // Both positive valueStart = extent[0]; } else if (extent[1] < 0) { // Both negative valueStart = extent[1]; } // If is one positive, and one negative, onZero shall be true } var valueDim = valueAxis.dim; var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0; return data.mapArray([valueDim], function (val, idx) { var stackedOnSameSign; var stackedOn = data.stackedOn; // Find first stacked value with same sign while (stackedOn && sign(stackedOn.get(valueDim, idx)) === sign(val) ) { stackedOnSameSign = stackedOn; break; } var stackedData = []; stackedData[baseDataOffset] = data.get(baseAxis.dim, idx); stackedData[1 - baseDataOffset] = stackedOnSameSign ? stackedOnSameSign.get(valueDim, idx, true) : valueStart; return coordSys.dataToPoint(stackedData); }, true); } function createGridClipShape(cartesian, hasAnimation, seriesModel) { var xExtent = getAxisExtentWithGap(cartesian.getAxis('x')); var yExtent = getAxisExtentWithGap(cartesian.getAxis('y')); var isHorizontal = cartesian.getBaseAxis().isHorizontal(); var x = Math.min(xExtent[0], xExtent[1]); var y = Math.min(yExtent[0], yExtent[1]); var width = Math.max(xExtent[0], xExtent[1]) - x; var height = Math.max(yExtent[0], yExtent[1]) - y; var lineWidth = seriesModel.get('lineStyle.normal.width') || 2; // Expand clip shape to avoid clipping when line value exceeds axis var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height); if (isHorizontal) { y -= expandSize; height += expandSize * 2; } else { x -= expandSize; width += expandSize * 2; } var clipPath = new graphic.Rect({ shape: { x: x, y: y, width: width, height: height } }); if (hasAnimation) { clipPath.shape[isHorizontal ? 'width' : 'height'] = 0; graphic.initProps(clipPath, { shape: { width: width, height: height } }, seriesModel); } return clipPath; } function createPolarClipShape(polar, hasAnimation, seriesModel) { var angleAxis = polar.getAngleAxis(); var radiusAxis = polar.getRadiusAxis(); var radiusExtent = radiusAxis.getExtent(); var angleExtent = angleAxis.getExtent(); var RADIAN = Math.PI / 180; var clipPath = new graphic.Sector({ shape: { cx: polar.cx, cy: polar.cy, r0: radiusExtent[0], r: radiusExtent[1], startAngle: -angleExtent[0] * RADIAN, endAngle: -angleExtent[1] * RADIAN, clockwise: angleAxis.inverse } }); if (hasAnimation) { clipPath.shape.endAngle = -angleExtent[0] * RADIAN; graphic.initProps(clipPath, { shape: { endAngle: -angleExtent[1] * RADIAN } }, seriesModel); } return clipPath; } function createClipShape(coordSys, hasAnimation, seriesModel) { return coordSys.type === 'polar' ? createPolarClipShape(coordSys, hasAnimation, seriesModel) : createGridClipShape(coordSys, hasAnimation, seriesModel); } function turnPointsIntoStep(points, coordSys, stepTurnAt) { var baseAxis = coordSys.getBaseAxis(); var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1; var stepPoints = []; for (var i = 0; i < points.length - 1; i++) { var nextPt = points[i + 1]; var pt = points[i]; stepPoints.push(pt); var stepPt = []; switch (stepTurnAt) { case 'end': stepPt[baseIndex] = nextPt[baseIndex]; stepPt[1 - baseIndex] = pt[1 - baseIndex]; // default is start stepPoints.push(stepPt); break; case 'middle': // default is start var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2; var stepPt2 = []; stepPt[baseIndex] = stepPt2[baseIndex] = middle; stepPt[1 - baseIndex] = pt[1 - baseIndex]; stepPt2[1 - baseIndex] = nextPt[1 - baseIndex]; stepPoints.push(stepPt); stepPoints.push(stepPt2); break; default: stepPt[baseIndex] = pt[baseIndex]; stepPt[1 - baseIndex] = nextPt[1 - baseIndex]; // default is start stepPoints.push(stepPt); } } // Last points points[i] && stepPoints.push(points[i]); return stepPoints; } function getVisualGradient(data, coordSys) { var visualMetaList = data.getVisual('visualMeta'); if (!visualMetaList || !visualMetaList.length || !data.count()) { // When data.count() is 0, gradient range can not be calculated. return; } var visualMeta; for (var i = visualMetaList.length - 1; i >= 0; i--) { // Can only be x or y if (visualMetaList[i].dimension < 2) { visualMeta = visualMetaList[i]; break; } } if (!visualMeta || coordSys.type !== 'cartesian2d') { if (true) { console.warn('Visual map on line style only support x or y dimension.'); } return; } // If the area to be rendered is bigger than area defined by LinearGradient, // the canvas spec prescribes that the color of the first stop and the last // stop should be used. But if two stops are added at offset 0, in effect // browsers use the color of the second stop to render area outside // LinearGradient. So we can only infinitesimally extend area defined in // LinearGradient to render `outerColors`. var dimension = visualMeta.dimension; var dimName = data.dimensions[dimension]; var axis = coordSys.getAxis(dimName); // dataToCoor mapping may not be linear, but must be monotonic. var colorStops = zrUtil.map(visualMeta.stops, function (stop) { return { coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)), color: stop.color }; }); var stopLen = colorStops.length; var outerColors = visualMeta.outerColors.slice(); if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) { colorStops.reverse(); outerColors.reverse(); } var tinyExtent = 10; // Arbitrary value: 10px var minCoord = colorStops[0].coord - tinyExtent; var maxCoord = colorStops[stopLen - 1].coord + tinyExtent; var coordSpan = maxCoord - minCoord; if (coordSpan < 1e-3) { return 'transparent'; } zrUtil.each(colorStops, function (stop) { stop.offset = (stop.coord - minCoord) / coordSpan; }); colorStops.push({ offset: stopLen ? colorStops[stopLen - 1].offset : 0.5, color: outerColors[1] || 'transparent' }); colorStops.unshift({ // notice colorStops.length have been changed. offset: stopLen ? colorStops[0].offset : 0.5, color: outerColors[0] || 'transparent' }); // zrUtil.each(colorStops, function (colorStop) { // // Make sure each offset has rounded px to avoid not sharp edge // colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start); // }); var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true); gradient[dimName] = minCoord; gradient[dimName + '2'] = maxCoord; return gradient; } module.exports = ChartView.extend({ type: 'line', init: function () { var lineGroup = new graphic.Group(); var symbolDraw = new SymbolDraw(); this.group.add(symbolDraw.group); this._symbolDraw = symbolDraw; this._lineGroup = lineGroup; }, render: function (seriesModel, ecModel, api) { var coordSys = seriesModel.coordinateSystem; var group = this.group; var data = seriesModel.getData(); var lineStyleModel = seriesModel.getModel('lineStyle.normal'); var areaStyleModel = seriesModel.getModel('areaStyle.normal'); var points = data.mapArray(data.getItemLayout, true); var isCoordSysPolar = coordSys.type === 'polar'; var prevCoordSys = this._coordSys; var symbolDraw = this._symbolDraw; var polyline = this._polyline; var polygon = this._polygon; var lineGroup = this._lineGroup; var hasAnimation = seriesModel.get('animation'); var isAreaChart = !areaStyleModel.isEmpty(); var stackedOnPoints = getStackedOnPoints(coordSys, data); var showSymbol = seriesModel.get('showSymbol'); var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol') && this._getSymbolIgnoreFunc(data, coordSys); // Remove temporary symbols var oldData = this._data; oldData && oldData.eachItemGraphicEl(function (el, idx) { if (el.__temp) { group.remove(el); oldData.setItemGraphicEl(idx, null); } }); // Remove previous created symbols if showSymbol changed to false if (!showSymbol) { symbolDraw.remove(); } group.add(lineGroup); // FIXME step not support polar var step = !isCoordSysPolar && seriesModel.get('step'); // Initialization animation or coordinate system changed if ( !(polyline && prevCoordSys.type === coordSys.type && step === this._step) ) { showSymbol && symbolDraw.updateData(data, isSymbolIgnore); if (step) { // TODO If stacked series is not step points = turnPointsIntoStep(points, coordSys, step); stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step); } polyline = this._newPolyline(points, coordSys, hasAnimation); if (isAreaChart) { polygon = this._newPolygon( points, stackedOnPoints, coordSys, hasAnimation ); } lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel)); } else { if (isAreaChart && !polygon) { // If areaStyle is added polygon = this._newPolygon( points, stackedOnPoints, coordSys, hasAnimation ); } else if (polygon && !isAreaChart) { // If areaStyle is removed lineGroup.remove(polygon); polygon = this._polygon = null; } // Update clipPath lineGroup.setClipPath(createClipShape(coordSys, false, seriesModel)); // Always update, or it is wrong in the case turning on legend // because points are not changed showSymbol && symbolDraw.updateData(data, isSymbolIgnore); // Stop symbol animation and sync with line points // FIXME performance? data.eachItemGraphicEl(function (el) { el.stopAnimation(true); }); // In the case data zoom triggerred refreshing frequently // Data may not change if line has a category axis. So it should animate nothing if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points) ) { if (hasAnimation) { this._updateAnimation( data, stackedOnPoints, coordSys, api, step ); } else { // Not do it in update with animation if (step) { // TODO If stacked series is not step points = turnPointsIntoStep(points, coordSys, step); stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step); } polyline.setShape({ points: points }); polygon && polygon.setShape({ points: points, stackedOnPoints: stackedOnPoints }); } } } var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color'); polyline.useStyle(zrUtil.defaults( // Use color in lineStyle first lineStyleModel.getLineStyle(), { fill: 'none', stroke: visualColor, lineJoin: 'bevel' } )); var smooth = seriesModel.get('smooth'); smooth = getSmooth(seriesModel.get('smooth')); polyline.setShape({ smooth: smooth, smoothMonotone: seriesModel.get('smoothMonotone'), connectNulls: seriesModel.get('connectNulls') }); if (polygon) { var stackedOn = data.stackedOn; var stackedOnSmooth = 0; polygon.useStyle(zrUtil.defaults( areaStyleModel.getAreaStyle(), { fill: visualColor, opacity: 0.7, lineJoin: 'bevel' } )); if (stackedOn) { var stackedOnSeries = stackedOn.hostModel; stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth')); } polygon.setShape({ smooth: smooth, stackedOnSmooth: stackedOnSmooth, smoothMonotone: seriesModel.get('smoothMonotone'), connectNulls: seriesModel.get('connectNulls') }); } this._data = data; // Save the coordinate system for transition animation when data changed this._coordSys = coordSys; this._stackedOnPoints = stackedOnPoints; this._points = points; this._step = step; }, dispose: function () {}, highlight: function (seriesModel, ecModel, api, payload) { var data = seriesModel.getData(); var dataIndex = modelUtil.queryDataIndex(data, payload); if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) { var symbol = data.getItemGraphicEl(dataIndex); if (!symbol) { // Create a temporary symbol if it is not exists var pt = data.getItemLayout(dataIndex); if (!pt) { // Null data return; } symbol = new Symbol(data, dataIndex); symbol.position = pt; symbol.setZ( seriesModel.get('zlevel'), seriesModel.get('z') ); symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]); symbol.__temp = true; data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation symbol.stopSymbolAnimation(true); this.group.add(symbol); } symbol.highlight(); } else { // Highlight whole series ChartView.prototype.highlight.call( this, seriesModel, ecModel, api, payload ); } }, downplay: function (seriesModel, ecModel, api, payload) { var data = seriesModel.getData(); var dataIndex = modelUtil.queryDataIndex(data, payload); if (dataIndex != null && dataIndex >= 0) { var symbol = data.getItemGraphicEl(dataIndex); if (symbol) { if (symbol.__temp) { data.setItemGraphicEl(dataIndex, null); this.group.remove(symbol); } else { symbol.downplay(); } } } else { // FIXME // can not downplay completely. // Downplay whole series ChartView.prototype.downplay.call( this, seriesModel, ecModel, api, payload ); } }, /** * @param {module:zrender/container/Group} group * @param {Array.} points * @private */ _newPolyline: function (points) { var polyline = this._polyline; // Remove previous created polyline if (polyline) { this._lineGroup.remove(polyline); } polyline = new polyHelper.Polyline({ shape: { points: points }, silent: true, z2: 10 }); this._lineGroup.add(polyline); this._polyline = polyline; return polyline; }, /** * @param {module:zrender/container/Group} group * @param {Array.} stackedOnPoints * @param {Array.} points * @private */ _newPolygon: function (points, stackedOnPoints) { var polygon = this._polygon; // Remove previous created polygon if (polygon) { this._lineGroup.remove(polygon); } polygon = new polyHelper.Polygon({ shape: { points: points, stackedOnPoints: stackedOnPoints }, silent: true }); this._lineGroup.add(polygon); this._polygon = polygon; return polygon; }, /** * @private */ _getSymbolIgnoreFunc: function (data, coordSys) { var categoryAxis = coordSys.getAxesByScale('ordinal')[0]; // `getLabelInterval` is provided by echarts/component/axis if (categoryAxis && categoryAxis.isLabelIgnored) { return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis); } }, /** * @private */ // FIXME Two value axis _updateAnimation: function (data, stackedOnPoints, coordSys, api, step) { var polyline = this._polyline; var polygon = this._polygon; var seriesModel = data.hostModel; var diff = lineAnimationDiff( this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys ); var current = diff.current; var stackedOnCurrent = diff.stackedOnCurrent; var next = diff.next; var stackedOnNext = diff.stackedOnNext; if (step) { // TODO If stacked series is not step current = turnPointsIntoStep(diff.current, coordSys, step); stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step); next = turnPointsIntoStep(diff.next, coordSys, step); stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step); } // `diff.current` is subset of `current` (which should be ensured by // turnPointsIntoStep), so points in `__points` can be updated when // points in `current` are update during animation. polyline.shape.__points = diff.current; polyline.shape.points = current; graphic.updateProps(polyline, { shape: { points: next } }, seriesModel); if (polygon) { polygon.setShape({ points: current, stackedOnPoints: stackedOnCurrent }); graphic.updateProps(polygon, { shape: { points: next, stackedOnPoints: stackedOnNext } }, seriesModel); } var updatedDataInfo = []; var diffStatus = diff.status; for (var i = 0; i < diffStatus.length; i++) { var cmd = diffStatus[i].cmd; if (cmd === '=') { var el = data.getItemGraphicEl(diffStatus[i].idx1); if (el) { updatedDataInfo.push({ el: el, ptIdx: i // Index of points }); } } } if (polyline.animators && polyline.animators.length) { polyline.animators[0].during(function () { for (var i = 0; i < updatedDataInfo.length; i++) { var el = updatedDataInfo[i].el; el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]); } }); } }, remove: function (ecModel) { var group = this.group; var oldData = this._data; this._lineGroup.removeAll(); this._symbolDraw.remove(true); // Remove temporary created elements when highlighting oldData && oldData.eachItemGraphicEl(function (el, idx) { if (el.__temp) { group.remove(el); oldData.setItemGraphicEl(idx, null); } }); this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null; } }); /***/ }), /* 119 */ /***/ (function(module, exports, __webpack_require__) { /** * @module echarts/chart/helper/SymbolDraw */ var graphic = __webpack_require__(20); var Symbol = __webpack_require__(120); /** * @constructor * @alias module:echarts/chart/helper/SymbolDraw * @param {module:zrender/graphic/Group} [symbolCtor] */ function SymbolDraw(symbolCtor) { this.group = new graphic.Group(); this._symbolCtor = symbolCtor || Symbol; } var symbolDrawProto = SymbolDraw.prototype; function symbolNeedsDraw(data, idx, isIgnore) { var point = data.getItemLayout(idx); // Is an object // if (point && point.hasOwnProperty('point')) { // point = point.point; // } return point && !isNaN(point[0]) && !isNaN(point[1]) && !(isIgnore && isIgnore(idx)) && data.getItemVisual(idx, 'symbol') !== 'none'; } /** * Update symbols draw by new data * @param {module:echarts/data/List} data * @param {Array.} [isIgnore] */ symbolDrawProto.updateData = function (data, isIgnore) { var group = this.group; var seriesModel = data.hostModel; var oldData = this._data; var SymbolCtor = this._symbolCtor; var seriesScope = { itemStyle: seriesModel.getModel('itemStyle.normal').getItemStyle(['color']), hoverItemStyle: seriesModel.getModel('itemStyle.emphasis').getItemStyle(), symbolRotate: seriesModel.get('symbolRotate'), symbolOffset: seriesModel.get('symbolOffset'), hoverAnimation: seriesModel.get('hoverAnimation'), labelModel: seriesModel.getModel('label.normal'), hoverLabelModel: seriesModel.getModel('label.emphasis'), cursorStyle: seriesModel.get('cursor') }; data.diff(oldData) .add(function (newIdx) { var point = data.getItemLayout(newIdx); if (symbolNeedsDraw(data, newIdx, isIgnore)) { var symbolEl = new SymbolCtor(data, newIdx, seriesScope); symbolEl.attr('position', point); data.setItemGraphicEl(newIdx, symbolEl); group.add(symbolEl); } }) .update(function (newIdx, oldIdx) { var symbolEl = oldData.getItemGraphicEl(oldIdx); var point = data.getItemLayout(newIdx); if (!symbolNeedsDraw(data, newIdx, isIgnore)) { group.remove(symbolEl); return; } if (!symbolEl) { symbolEl = new SymbolCtor(data, newIdx); symbolEl.attr('position', point); } else { symbolEl.updateData(data, newIdx, seriesScope); graphic.updateProps(symbolEl, { position: point }, seriesModel); } // Add back group.add(symbolEl); data.setItemGraphicEl(newIdx, symbolEl); }) .remove(function (oldIdx) { var el = oldData.getItemGraphicEl(oldIdx); el && el.fadeOut(function () { group.remove(el); }); }) .execute(); this._data = data; }; symbolDrawProto.updateLayout = function () { var data = this._data; if (data) { // Not use animation data.eachItemGraphicEl(function (el, idx) { var point = data.getItemLayout(idx); el.attr('position', point); }); } }; symbolDrawProto.remove = function (enableAnimation) { var group = this.group; var data = this._data; if (data) { if (enableAnimation) { data.eachItemGraphicEl(function (el) { el.fadeOut(function () { group.remove(el); }); }); } else { group.removeAll(); } } }; module.exports = SymbolDraw; /***/ }), /* 120 */ /***/ (function(module, exports, __webpack_require__) { /** * @module echarts/chart/helper/Symbol */ var zrUtil = __webpack_require__(4); var symbolUtil = __webpack_require__(114); var graphic = __webpack_require__(20); var numberUtil = __webpack_require__(7); var labelHelper = __webpack_require__(121); function getSymbolSize(data, idx) { var symbolSize = data.getItemVisual(idx, 'symbolSize'); return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize]; } function getScale(symbolSize) { return [symbolSize[0] / 2, symbolSize[1] / 2]; } /** * @constructor * @alias {module:echarts/chart/helper/Symbol} * @param {module:echarts/data/List} data * @param {number} idx * @extends {module:zrender/graphic/Group} */ function Symbol(data, idx, seriesScope) { graphic.Group.call(this); this.updateData(data, idx, seriesScope); } var symbolProto = Symbol.prototype; function driftSymbol(dx, dy) { this.parent.drift(dx, dy); } symbolProto._createSymbol = function (symbolType, data, idx, symbolSize) { // Remove paths created before this.removeAll(); var seriesModel = data.hostModel; var color = data.getItemVisual(idx, 'color'); // var symbolPath = symbolUtil.createSymbol( // symbolType, -0.5, -0.5, 1, 1, color // ); // If width/height are set too small (e.g., set to 1) on ios10 // and macOS Sierra, a circle stroke become a rect, no matter what // the scale is set. So we set width/height as 2. See #4150. var symbolPath = symbolUtil.createSymbol( symbolType, -1, -1, 2, 2, color ); symbolPath.attr({ z2: 100, culling: true, scale: [0, 0] }); // Rewrite drift method symbolPath.drift = driftSymbol; graphic.initProps(symbolPath, { scale: getScale(symbolSize) }, seriesModel, idx); this._symbolType = symbolType; this.add(symbolPath); }; /** * Stop animation * @param {boolean} toLastFrame */ symbolProto.stopSymbolAnimation = function (toLastFrame) { this.childAt(0).stopAnimation(toLastFrame); }; /** * Get symbol path element */ symbolProto.getSymbolPath = function () { return this.childAt(0); }; /** * Get scale(aka, current symbol size). * Including the change caused by animation */ symbolProto.getScale = function () { return this.childAt(0).scale; }; /** * Highlight symbol */ symbolProto.highlight = function () { this.childAt(0).trigger('emphasis'); }; /** * Downplay symbol */ symbolProto.downplay = function () { this.childAt(0).trigger('normal'); }; /** * @param {number} zlevel * @param {number} z */ symbolProto.setZ = function (zlevel, z) { var symbolPath = this.childAt(0); symbolPath.zlevel = zlevel; symbolPath.z = z; }; symbolProto.setDraggable = function (draggable) { var symbolPath = this.childAt(0); symbolPath.draggable = draggable; symbolPath.cursor = draggable ? 'move' : 'pointer'; }; /** * Update symbol properties * @param {module:echarts/data/List} data * @param {number} idx */ symbolProto.updateData = function (data, idx, seriesScope) { this.silent = false; var symbolType = data.getItemVisual(idx, 'symbol') || 'circle'; var seriesModel = data.hostModel; var symbolSize = getSymbolSize(data, idx); if (symbolType !== this._symbolType) { this._createSymbol(symbolType, data, idx, symbolSize); } else { var symbolPath = this.childAt(0); symbolPath.silent = false; graphic.updateProps(symbolPath, { scale: getScale(symbolSize) }, seriesModel, idx); } this._updateCommon(data, idx, symbolSize, seriesScope); this._seriesModel = seriesModel; }; // Update common properties var normalStyleAccessPath = ['itemStyle', 'normal']; var emphasisStyleAccessPath = ['itemStyle', 'emphasis']; var normalLabelAccessPath = ['label', 'normal']; var emphasisLabelAccessPath = ['label', 'emphasis']; symbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) { var symbolPath = this.childAt(0); var seriesModel = data.hostModel; var color = data.getItemVisual(idx, 'color'); // Reset style if (symbolPath.type !== 'image') { symbolPath.useStyle({ strokeNoScale: true }); } seriesScope = seriesScope || null; var itemStyle = seriesScope && seriesScope.itemStyle; var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle; var symbolRotate = seriesScope && seriesScope.symbolRotate; var symbolOffset = seriesScope && seriesScope.symbolOffset; var labelModel = seriesScope && seriesScope.labelModel; var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel; var hoverAnimation = seriesScope && seriesScope.hoverAnimation; var cursorStyle = seriesScope && seriesScope.cursorStyle; if (!seriesScope || data.hasItemOption) { var itemModel = data.getItemModel(idx); // Color must be excluded. // Because symbol provide setColor individually to set fill and stroke itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']); hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle(); symbolRotate = itemModel.getShallow('symbolRotate'); symbolOffset = itemModel.getShallow('symbolOffset'); labelModel = itemModel.getModel(normalLabelAccessPath); hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath); hoverAnimation = itemModel.getShallow('hoverAnimation'); cursorStyle = itemModel.getShallow('cursor'); } else { hoverItemStyle = zrUtil.extend({}, hoverItemStyle); } var elStyle = symbolPath.style; symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0); if (symbolOffset) { symbolPath.attr('position', [ numberUtil.parsePercent(symbolOffset[0], symbolSize[0]), numberUtil.parsePercent(symbolOffset[1], symbolSize[1]) ]); } cursorStyle && symbolPath.attr('cursor', cursorStyle); // PENDING setColor before setStyle!!! symbolPath.setColor(color); symbolPath.setStyle(itemStyle); var opacity = data.getItemVisual(idx, 'opacity'); if (opacity != null) { elStyle.opacity = opacity; } var valueDim = labelHelper.findLabelValueDim(data); if (valueDim != null) { graphic.setLabelStyle( elStyle, hoverItemStyle, labelModel, hoverLabelModel, { labelFetcher: seriesModel, labelDataIndex: idx, defaultText: data.get(valueDim, idx), isRectText: true, autoColor: color } ); } symbolPath.off('mouseover') .off('mouseout') .off('emphasis') .off('normal'); symbolPath.hoverStyle = hoverItemStyle; // FIXME // Do not use symbol.trigger('emphasis'), but use symbol.highlight() instead. graphic.setHoverStyle(symbolPath); var scale = getScale(symbolSize); if (hoverAnimation && seriesModel.isAnimationEnabled()) { var onEmphasis = function() { var ratio = scale[1] / scale[0]; this.animateTo({ scale: [ Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio) ] }, 400, 'elasticOut'); }; var onNormal = function() { this.animateTo({ scale: scale }, 400, 'elasticOut'); }; symbolPath.on('mouseover', onEmphasis) .on('mouseout', onNormal) .on('emphasis', onEmphasis) .on('normal', onNormal); } }; symbolProto.fadeOut = function (cb) { var symbolPath = this.childAt(0); // Avoid mistaken hover when fading out this.silent = symbolPath.silent = true; // Not show text when animating symbolPath.style.text = null; graphic.updateProps(symbolPath, { scale: [0, 0] }, this._seriesModel, this.dataIndex, cb); }; zrUtil.inherits(Symbol, graphic.Group); module.exports = Symbol; /***/ }), /* 121 */ /***/ (function(module, exports, __webpack_require__) { /** * @module echarts/chart/helper/Symbol */ var modelUtil = __webpack_require__(5); var helper = {}; helper.findLabelValueDim = function (data) { var valueDim; var labelDims = modelUtil.otherDimToDataDim(data, 'label'); if (labelDims.length) { valueDim = labelDims[0]; } else { // Get last value dim var dimensions = data.dimensions.slice(); var dataType; while (dimensions.length && ( valueDim = dimensions.pop(), dataType = data.getDimensionInfo(valueDim).type, dataType === 'ordinal' || dataType === 'time' )) {} // jshint ignore:line } return valueDim; }; module.exports = helper; /***/ }), /* 122 */ /***/ (function(module, exports) { // var arrayDiff = require('zrender/lib/core/arrayDiff'); // 'zrender/core/arrayDiff' has been used before, but it did // not do well in performance when roam with fixed dataZoom window. function sign(val) { return val >= 0 ? 1 : -1; } function getStackedOnPoint(coordSys, data, idx) { var baseAxis = coordSys.getBaseAxis(); var valueAxis = coordSys.getOtherAxis(baseAxis); var valueStart = baseAxis.onZero ? 0 : valueAxis.scale.getExtent()[0]; var valueDim = valueAxis.dim; var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0; var stackedOnSameSign; var stackedOn = data.stackedOn; var val = data.get(valueDim, idx); // Find first stacked value with same sign while (stackedOn && sign(stackedOn.get(valueDim, idx)) === sign(val) ) { stackedOnSameSign = stackedOn; break; } var stackedData = []; stackedData[baseDataOffset] = data.get(baseAxis.dim, idx); stackedData[1 - baseDataOffset] = stackedOnSameSign ? stackedOnSameSign.get(valueDim, idx, true) : valueStart; return coordSys.dataToPoint(stackedData); } // function convertToIntId(newIdList, oldIdList) { // // Generate int id instead of string id. // // Compare string maybe slow in score function of arrDiff // // Assume id in idList are all unique // var idIndicesMap = {}; // var idx = 0; // for (var i = 0; i < newIdList.length; i++) { // idIndicesMap[newIdList[i]] = idx; // newIdList[i] = idx++; // } // for (var i = 0; i < oldIdList.length; i++) { // var oldId = oldIdList[i]; // // Same with newIdList // if (idIndicesMap[oldId]) { // oldIdList[i] = idIndicesMap[oldId]; // } // else { // oldIdList[i] = idx++; // } // } // } function diffData(oldData, newData) { var diffResult = []; newData.diff(oldData) .add(function (idx) { diffResult.push({cmd: '+', idx: idx}); }) .update(function (newIdx, oldIdx) { diffResult.push({cmd: '=', idx: oldIdx, idx1: newIdx}); }) .remove(function (idx) { diffResult.push({cmd: '-', idx: idx}); }) .execute(); return diffResult; } module.exports = function ( oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys ) { var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId); // var oldIdList = oldData.mapArray(oldData.getId); // convertToIntId(newIdList, oldIdList); // // FIXME One data ? // diff = arrayDiff(oldIdList, newIdList); var currPoints = []; var nextPoints = []; // Points for stacking base line var currStackedPoints = []; var nextStackedPoints = []; var status = []; var sortedIndices = []; var rawIndices = []; var dims = newCoordSys.dimensions; for (var i = 0; i < diff.length; i++) { var diffItem = diff[i]; var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast // Which is in case remvoing or add more than one data in the tail or head switch (diffItem.cmd) { case '=': var currentPt = oldData.getItemLayout(diffItem.idx); var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly if (isNaN(currentPt[0]) || isNaN(currentPt[1])) { currentPt = nextPt.slice(); } currPoints.push(currentPt); nextPoints.push(nextPt); currStackedPoints.push(oldStackedOnPoints[diffItem.idx]); nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]); rawIndices.push(newData.getRawIndex(diffItem.idx1)); break; case '+': var idx = diffItem.idx; currPoints.push( oldCoordSys.dataToPoint([ newData.get(dims[0], idx, true), newData.get(dims[1], idx, true) ]) ); nextPoints.push(newData.getItemLayout(idx).slice()); currStackedPoints.push( getStackedOnPoint(oldCoordSys, newData, idx) ); nextStackedPoints.push(newStackedOnPoints[idx]); rawIndices.push(newData.getRawIndex(idx)); break; case '-': var idx = diffItem.idx; var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue // FIXME FIXME FIXME if (rawIndex !== idx) { currPoints.push(oldData.getItemLayout(idx)); nextPoints.push(newCoordSys.dataToPoint([ oldData.get(dims[0], idx, true), oldData.get(dims[1], idx, true) ])); currStackedPoints.push(oldStackedOnPoints[idx]); nextStackedPoints.push( getStackedOnPoint( newCoordSys, oldData, idx ) ); rawIndices.push(rawIndex); } else { pointAdded = false; } } // Original indices if (pointAdded) { status.push(diffItem); sortedIndices.push(sortedIndices.length); } } // Diff result may be crossed if all items are changed // Sort by data index sortedIndices.sort(function (a, b) { return rawIndices[a] - rawIndices[b]; }); var sortedCurrPoints = []; var sortedNextPoints = []; var sortedCurrStackedPoints = []; var sortedNextStackedPoints = []; var sortedStatus = []; for (var i = 0; i < sortedIndices.length; i++) { var idx = sortedIndices[i]; sortedCurrPoints[i] = currPoints[idx]; sortedNextPoints[i] = nextPoints[idx]; sortedCurrStackedPoints[i] = currStackedPoints[idx]; sortedNextStackedPoints[i] = nextStackedPoints[idx]; sortedStatus[i] = status[idx]; } return { current: sortedCurrPoints, next: sortedNextPoints, stackedOnCurrent: sortedCurrStackedPoints, stackedOnNext: sortedNextStackedPoints, status: sortedStatus }; }; /***/ }), /* 123 */ /***/ (function(module, exports, __webpack_require__) { // Poly path support NaN point var Path = __webpack_require__(22); var vec2 = __webpack_require__(10); var fixClipWithShadow = __webpack_require__(56); var vec2Min = vec2.min; var vec2Max = vec2.max; var scaleAndAdd = vec2.scaleAndAdd; var v2Copy = vec2.copy; // Temporary variable var v = []; var cp0 = []; var cp1 = []; function isPointNull(p) { return isNaN(p[0]) || isNaN(p[1]); } function drawSegment( ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls ) { var prevIdx = 0; var idx = start; for (var k = 0; k < segLen; k++) { var p = points[idx]; if (idx >= allLen || idx < 0) { break; } if (isPointNull(p)) { if (connectNulls) { idx += dir; continue; } break; } if (idx === start) { ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]); v2Copy(cp0, p); } else { if (smooth > 0) { var nextIdx = idx + dir; var nextP = points[nextIdx]; if (connectNulls) { // Find next point not null while (nextP && isPointNull(points[nextIdx])) { nextIdx += dir; nextP = points[nextIdx]; } } var ratioNextSeg = 0.5; var prevP = points[prevIdx]; var nextP = points[nextIdx]; // Last point if (!nextP || isPointNull(nextP)) { v2Copy(cp1, p); } else { // If next data is null in not connect case if (isPointNull(nextP) && !connectNulls) { nextP = p; } vec2.sub(v, nextP, prevP); var lenPrevSeg; var lenNextSeg; if (smoothMonotone === 'x' || smoothMonotone === 'y') { var dim = smoothMonotone === 'x' ? 0 : 1; lenPrevSeg = Math.abs(p[dim] - prevP[dim]); lenNextSeg = Math.abs(p[dim] - nextP[dim]); } else { lenPrevSeg = vec2.dist(p, prevP); lenNextSeg = vec2.dist(p, nextP); } // Use ratio of seg length ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg); scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg)); } // Smooth constraint vec2Min(cp0, cp0, smoothMax); vec2Max(cp0, cp0, smoothMin); vec2Min(cp1, cp1, smoothMax); vec2Max(cp1, cp1, smoothMin); ctx.bezierCurveTo( cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1] ); // cp0 of next segment scaleAndAdd(cp0, p, v, smooth * ratioNextSeg); } else { ctx.lineTo(p[0], p[1]); } } prevIdx = idx; idx += dir; } return k; } function getBoundingBox(points, smoothConstraint) { var ptMin = [Infinity, Infinity]; var ptMax = [-Infinity, -Infinity]; if (smoothConstraint) { for (var i = 0; i < points.length; i++) { var pt = points[i]; if (pt[0] < ptMin[0]) { ptMin[0] = pt[0]; } if (pt[1] < ptMin[1]) { ptMin[1] = pt[1]; } if (pt[0] > ptMax[0]) { ptMax[0] = pt[0]; } if (pt[1] > ptMax[1]) { ptMax[1] = pt[1]; } } } return { min: smoothConstraint ? ptMin : ptMax, max: smoothConstraint ? ptMax : ptMin }; } module.exports = { Polyline: Path.extend({ type: 'ec-polyline', shape: { points: [], smooth: 0, smoothConstraint: true, smoothMonotone: null, connectNulls: false }, style: { fill: null, stroke: '#000' }, brush: fixClipWithShadow(Path.prototype.brush), buildPath: function (ctx, shape) { var points = shape.points; var i = 0; var len = points.length; var result = getBoundingBox(points, shape.smoothConstraint); if (shape.connectNulls) { // Must remove first and last null values avoid draw error in polygon for (; len > 0; len--) { if (!isPointNull(points[len - 1])) { break; } } for (; i < len; i++) { if (!isPointNull(points[i])) { break; } } } while (i < len) { i += drawSegment( ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls ) + 1; } } }), Polygon: Path.extend({ type: 'ec-polygon', shape: { points: [], // Offset between stacked base points and points stackedOnPoints: [], smooth: 0, stackedOnSmooth: 0, smoothConstraint: true, smoothMonotone: null, connectNulls: false }, brush: fixClipWithShadow(Path.prototype.brush), buildPath: function (ctx, shape) { var points = shape.points; var stackedOnPoints = shape.stackedOnPoints; var i = 0; var len = points.length; var smoothMonotone = shape.smoothMonotone; var bbox = getBoundingBox(points, shape.smoothConstraint); var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint); if (shape.connectNulls) { // Must remove first and last null values avoid draw error in polygon for (; len > 0; len--) { if (!isPointNull(points[len - 1])) { break; } } for (; i < len; i++) { if (!isPointNull(points[i])) { break; } } } while (i < len) { var k = drawSegment( ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls ); drawSegment( ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls ); i += k + 1; ctx.closePath(); } } }) }; /***/ }), /* 124 */ /***/ (function(module, exports) { module.exports = function (seriesType, defaultSymbolType, legendSymbol, ecModel, api) { // Encoding visual for all series include which is filtered for legend drawing ecModel.eachRawSeriesByType(seriesType, function (seriesModel) { var data = seriesModel.getData(); var symbolType = seriesModel.get('symbol') || defaultSymbolType; var symbolSize = seriesModel.get('symbolSize'); data.setVisual({ legendSymbol: legendSymbol || symbolType, symbol: symbolType, symbolSize: symbolSize }); // Only visible series has each data be visual encoded if (!ecModel.isSeriesFiltered(seriesModel)) { if (typeof symbolSize === 'function') { data.each(function (idx) { var rawValue = seriesModel.getRawValue(idx); // FIXME var params = seriesModel.getDataParams(idx); data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params)); }); } data.each(function (idx) { var itemModel = data.getItemModel(idx); var itemSymbolType = itemModel.getShallow('symbol', true); var itemSymbolSize = itemModel.getShallow('symbolSize', true); // If has item symbol if (itemSymbolType != null) { data.setItemVisual(idx, 'symbol', itemSymbolType); } if (itemSymbolSize != null) { // PENDING Transform symbolSize ? data.setItemVisual(idx, 'symbolSize', itemSymbolSize); } }); } }); }; /***/ }), /* 125 */ /***/ (function(module, exports) { module.exports = function (seriesType, ecModel) { ecModel.eachSeriesByType(seriesType, function (seriesModel) { var data = seriesModel.getData(); var coordSys = seriesModel.coordinateSystem; if (!coordSys) { return; } var dims = []; var coordDims = coordSys.dimensions; for (var i = 0; i < coordDims.length; i++) { dims.push(seriesModel.coordDimToDataDim(coordSys.dimensions[i])[0]); } if (dims.length === 1) { data.each(dims[0], function (x, idx) { // Also {Array.}, not undefined to avoid if...else... statement data.setItemLayout(idx, isNaN(x) ? [NaN, NaN] : coordSys.dataToPoint(x)); }); } else if (dims.length === 2) { data.each(dims, function (x, y, idx) { // Also {Array.}, not undefined to avoid if...else... statement data.setItemLayout( idx, (isNaN(x) || isNaN(y)) ? [NaN, NaN] : coordSys.dataToPoint([x, y]) ); }, true); } }); }; /***/ }), /* 126 */ /***/ (function(module, exports) { var samplers = { average: function (frame) { var sum = 0; var count = 0; for (var i = 0; i < frame.length; i++) { if (!isNaN(frame[i])) { sum += frame[i]; count++; } } // Return NaN if count is 0 return count === 0 ? NaN : sum / count; }, sum: function (frame) { var sum = 0; for (var i = 0; i < frame.length; i++) { // Ignore NaN sum += frame[i] || 0; } return sum; }, max: function (frame) { var max = -Infinity; for (var i = 0; i < frame.length; i++) { frame[i] > max && (max = frame[i]); } return max; }, min: function (frame) { var min = Infinity; for (var i = 0; i < frame.length; i++) { frame[i] < min && (min = frame[i]); } return min; }, // TODO // Median nearest: function (frame) { return frame[0]; } }; var indexSampler = function (frame, value) { return Math.round(frame.length / 2); }; module.exports = function (seriesType, ecModel, api) { ecModel.eachSeriesByType(seriesType, function (seriesModel) { var data = seriesModel.getData(); var sampling = seriesModel.get('sampling'); var coordSys = seriesModel.coordinateSystem; // Only cartesian2d support down sampling if (coordSys.type === 'cartesian2d' && sampling) { var baseAxis = coordSys.getBaseAxis(); var valueAxis = coordSys.getOtherAxis(baseAxis); var extent = baseAxis.getExtent(); // Coordinste system has been resized var size = extent[1] - extent[0]; var rate = Math.round(data.count() / size); if (rate > 1) { var sampler; if (typeof sampling === 'string') { sampler = samplers[sampling]; } else if (typeof sampling === 'function') { sampler = sampling; } if (sampler) { data = data.downSample( valueAxis.dim, 1 / rate, sampler, indexSampler ); seriesModel.setData(data); } } } }, this); }; /***/ }), /* 127 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var graphic = __webpack_require__(20); var zrUtil = __webpack_require__(4); var echarts = __webpack_require__(1); __webpack_require__(128); __webpack_require__(136); // Grid view echarts.extendComponentView({ type: 'grid', render: function (gridModel, ecModel) { this.group.removeAll(); if (gridModel.get('show')) { this.group.add(new graphic.Rect({ shape: gridModel.coordinateSystem.getRect(), style: zrUtil.defaults({ fill: gridModel.get('backgroundColor') }, gridModel.getItemStyle()), silent: true, z2: -1 })); } } }); echarts.registerPreprocessor(function (option) { // Only create grid when need if (option.xAxis && option.yAxis && !option.grid) { option.grid = {}; } }); /***/ }), /* 128 */ /***/ (function(module, exports, __webpack_require__) { /** * Grid is a region which contains at most 4 cartesian systems * * TODO Default cartesian */ var factory = exports; var layout = __webpack_require__(74); var axisHelper = __webpack_require__(104); var zrUtil = __webpack_require__(4); var Cartesian2D = __webpack_require__(129); var Axis2D = __webpack_require__(131); var each = zrUtil.each; var ifAxisCrossZero = axisHelper.ifAxisCrossZero; var niceScaleExtent = axisHelper.niceScaleExtent; // 依赖 GridModel, AxisModel 做预处理 __webpack_require__(132); /** * Check if the axis is used in the specified grid * @inner */ function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) { return axisModel.getCoordSysModel() === gridModel; } function getLabelUnionRect(axis) { var axisModel = axis.model; var labels = axisModel.getFormattedLabels(); var axisLabelModel = axisModel.getModel('axisLabel'); var rect; var step = 1; var labelCount = labels.length; if (labelCount > 40) { // Simple optimization for large amount of labels step = Math.ceil(labelCount / 40); } for (var i = 0; i < labelCount; i += step) { if (!axis.isLabelIgnored(i)) { var singleRect = axisLabelModel.getTextRect(labels[i]); // FIXME consider label rotate rect ? rect.union(singleRect) : (rect = singleRect); } } return rect; } function Grid(gridModel, ecModel, api) { /** * @type {Object.} * @private */ this._coordsMap = {}; /** * @type {Array.} * @private */ this._coordsList = []; /** * @type {Object.} * @private */ this._axesMap = {}; /** * @type {Array.} * @private */ this._axesList = []; this._initCartesian(gridModel, ecModel, api); this.model = gridModel; } var gridProto = Grid.prototype; gridProto.type = 'grid'; gridProto.axisPointerEnabled = true; gridProto.getRect = function () { return this._rect; }; gridProto.update = function (ecModel, api) { var axesMap = this._axesMap; this._updateScale(ecModel, this.model); each(axesMap.x, function (xAxis) { niceScaleExtent(xAxis.scale, xAxis.model); }); each(axesMap.y, function (yAxis) { niceScaleExtent(yAxis.scale, yAxis.model); }); each(axesMap.x, function (xAxis) { fixAxisOnZero(axesMap, 'y', xAxis); }); each(axesMap.y, function (yAxis) { fixAxisOnZero(axesMap, 'x', yAxis); }); // Resize again if containLabel is enabled // FIXME It may cause getting wrong grid size in data processing stage this.resize(this.model, api); }; function fixAxisOnZero(axesMap, otherAxisDim, axis) { // onZero can not be enabled in these two situations: // 1. When any other axis is a category axis. // 2. When no axis is cross 0 point. var axes = axesMap[otherAxisDim]; if (!axis.onZero) { return; } var onZeroAxisIndex = axis.onZeroAxisIndex; // If target axis is specified. if (onZeroAxisIndex != null) { var otherAxis = axes[onZeroAxisIndex]; if (otherAxis && canNotOnZeroToAxis(otherAxis)) { axis.onZero = false; } return; } for (var idx in axes) { if (axes.hasOwnProperty(idx)) { var otherAxis = axes[idx]; if (otherAxis && !canNotOnZeroToAxis(otherAxis)) { onZeroAxisIndex = +idx; break; } } } if (onZeroAxisIndex == null) { axis.onZero = false; } axis.onZeroAxisIndex = onZeroAxisIndex; } function canNotOnZeroToAxis(axis) { return axis.type === 'category' || axis.type === 'time' || !ifAxisCrossZero(axis); } /** * Resize the grid * @param {module:echarts/coord/cartesian/GridModel} gridModel * @param {module:echarts/ExtensionAPI} api */ gridProto.resize = function (gridModel, api, ignoreContainLabel) { var gridRect = layout.getLayoutRect( gridModel.getBoxLayoutParams(), { width: api.getWidth(), height: api.getHeight() }); this._rect = gridRect; var axesList = this._axesList; adjustAxes(); // Minus label size if (!ignoreContainLabel && gridModel.get('containLabel')) { each(axesList, function (axis) { if (!axis.model.get('axisLabel.inside')) { var labelUnionRect = getLabelUnionRect(axis); if (labelUnionRect) { var dim = axis.isHorizontal() ? 'height' : 'width'; var margin = axis.model.get('axisLabel.margin'); gridRect[dim] -= labelUnionRect[dim] + margin; if (axis.position === 'top') { gridRect.y += labelUnionRect.height + margin; } else if (axis.position === 'left') { gridRect.x += labelUnionRect.width + margin; } } } }); adjustAxes(); } function adjustAxes() { each(axesList, function (axis) { var isHorizontal = axis.isHorizontal(); var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height]; var idx = axis.inverse ? 1 : 0; axis.setExtent(extent[idx], extent[1 - idx]); updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y); }); } }; /** * @param {string} axisType * @param {number} [axisIndex] */ gridProto.getAxis = function (axisType, axisIndex) { var axesMapOnDim = this._axesMap[axisType]; if (axesMapOnDim != null) { if (axisIndex == null) { // Find first axis for (var name in axesMapOnDim) { if (axesMapOnDim.hasOwnProperty(name)) { return axesMapOnDim[name]; } } } return axesMapOnDim[axisIndex]; } }; /** * @return {Array.} */ gridProto.getAxes = function () { return this._axesList.slice(); }; /** * Usage: * grid.getCartesian(xAxisIndex, yAxisIndex); * grid.getCartesian(xAxisIndex); * grid.getCartesian(null, yAxisIndex); * grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...}); * * @param {number|Object} [xAxisIndex] * @param {number} [yAxisIndex] */ gridProto.getCartesian = function (xAxisIndex, yAxisIndex) { if (xAxisIndex != null && yAxisIndex != null) { var key = 'x' + xAxisIndex + 'y' + yAxisIndex; return this._coordsMap[key]; } if (zrUtil.isObject(xAxisIndex)) { yAxisIndex = xAxisIndex.yAxisIndex; xAxisIndex = xAxisIndex.xAxisIndex; } // When only xAxisIndex or yAxisIndex given, find its first cartesian. for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) { if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex ) { return coordList[i]; } } }; gridProto.getCartesians = function () { return this._coordsList.slice(); }; /** * @implements * see {module:echarts/CoodinateSystem} */ gridProto.convertToPixel = function (ecModel, finder, value) { var target = this._findConvertTarget(ecModel, finder); return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null; }; /** * @implements * see {module:echarts/CoodinateSystem} */ gridProto.convertFromPixel = function (ecModel, finder, value) { var target = this._findConvertTarget(ecModel, finder); return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null; }; /** * @inner */ gridProto._findConvertTarget = function (ecModel, finder) { var seriesModel = finder.seriesModel; var xAxisModel = finder.xAxisModel || (seriesModel && seriesModel.getReferringComponents('xAxis')[0]); var yAxisModel = finder.yAxisModel || (seriesModel && seriesModel.getReferringComponents('yAxis')[0]); var gridModel = finder.gridModel; var coordsList = this._coordsList; var cartesian; var axis; if (seriesModel) { cartesian = seriesModel.coordinateSystem; zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null); } else if (xAxisModel && yAxisModel) { cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex); } else if (xAxisModel) { axis = this.getAxis('x', xAxisModel.componentIndex); } else if (yAxisModel) { axis = this.getAxis('y', yAxisModel.componentIndex); } // Lowest priority. else if (gridModel) { var grid = gridModel.coordinateSystem; if (grid === this) { cartesian = this._coordsList[0]; } } return {cartesian: cartesian, axis: axis}; }; /** * @implements * see {module:echarts/CoodinateSystem} */ gridProto.containPoint = function (point) { var coord = this._coordsList[0]; if (coord) { return coord.containPoint(point); } }; /** * Initialize cartesian coordinate systems * @private */ gridProto._initCartesian = function (gridModel, ecModel, api) { var axisPositionUsed = { left: false, right: false, top: false, bottom: false }; var axesMap = { x: {}, y: {} }; var axesCount = { x: 0, y: 0 }; /// Create axis ecModel.eachComponent('xAxis', createAxisCreator('x'), this); ecModel.eachComponent('yAxis', createAxisCreator('y'), this); if (!axesCount.x || !axesCount.y) { // Roll back when there no either x or y axis this._axesMap = {}; this._axesList = []; return; } this._axesMap = axesMap; /// Create cartesian2d each(axesMap.x, function (xAxis, xAxisIndex) { each(axesMap.y, function (yAxis, yAxisIndex) { var key = 'x' + xAxisIndex + 'y' + yAxisIndex; var cartesian = new Cartesian2D(key); cartesian.grid = this; cartesian.model = gridModel; this._coordsMap[key] = cartesian; this._coordsList.push(cartesian); cartesian.addAxis(xAxis); cartesian.addAxis(yAxis); }, this); }, this); function createAxisCreator(axisType) { return function (axisModel, idx) { if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) { return; } var axisPosition = axisModel.get('position'); if (axisType === 'x') { // Fix position if (axisPosition !== 'top' && axisPosition !== 'bottom') { // Default bottom of X axisPosition = 'bottom'; if (axisPositionUsed[axisPosition]) { axisPosition = axisPosition === 'top' ? 'bottom' : 'top'; } } } else { // Fix position if (axisPosition !== 'left' && axisPosition !== 'right') { // Default left of Y axisPosition = 'left'; if (axisPositionUsed[axisPosition]) { axisPosition = axisPosition === 'left' ? 'right' : 'left'; } } } axisPositionUsed[axisPosition] = true; var axis = new Axis2D( axisType, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition ); var isCategory = axis.type === 'category'; axis.onBand = isCategory && axisModel.get('boundaryGap'); axis.inverse = axisModel.get('inverse'); axis.onZero = axisModel.get('axisLine.onZero'); axis.onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex'); // Inject axis into axisModel axisModel.axis = axis; // Inject axisModel into axis axis.model = axisModel; // Inject grid info axis axis.grid = this; // Index of axis, can be used as key axis.index = idx; this._axesList.push(axis); axesMap[axisType][idx] = axis; axesCount[axisType]++; }; } }; /** * Update cartesian properties from series * @param {module:echarts/model/Option} option * @private */ gridProto._updateScale = function (ecModel, gridModel) { // Reset scale zrUtil.each(this._axesList, function (axis) { axis.scale.setExtent(Infinity, -Infinity); }); ecModel.eachSeries(function (seriesModel) { if (isCartesian2D(seriesModel)) { var axesModels = findAxesModels(seriesModel, ecModel); var xAxisModel = axesModels[0]; var yAxisModel = axesModels[1]; if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel) ) { return; } var cartesian = this.getCartesian( xAxisModel.componentIndex, yAxisModel.componentIndex ); var data = seriesModel.getData(); var xAxis = cartesian.getAxis('x'); var yAxis = cartesian.getAxis('y'); if (data.type === 'list') { unionExtent(data, xAxis, seriesModel); unionExtent(data, yAxis, seriesModel); } } }, this); function unionExtent(data, axis, seriesModel) { each(seriesModel.coordDimToDataDim(axis.dim), function (dim) { axis.scale.unionExtentFromData(data, dim); }); } }; /** * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined * @return {Object} {baseAxes: [], otherAxes: []} */ gridProto.getTooltipAxes = function (dim) { var baseAxes = []; var otherAxes = []; each(this.getCartesians(), function (cartesian) { var baseAxis = (dim != null && dim !== 'auto') ? cartesian.getAxis(dim) : cartesian.getBaseAxis(); var otherAxis = cartesian.getOtherAxis(baseAxis); zrUtil.indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis); zrUtil.indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis); }); return {baseAxes: baseAxes, otherAxes: otherAxes}; }; /** * @inner */ function updateAxisTransfrom(axis, coordBase) { var axisExtent = axis.getExtent(); var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform axis.toGlobalCoord = axis.dim === 'x' ? function (coord) { return coord + coordBase; } : function (coord) { return axisExtentSum - coord + coordBase; }; axis.toLocalCoord = axis.dim === 'x' ? function (coord) { return coord - coordBase; } : function (coord) { return axisExtentSum - coord + coordBase; }; } var axesTypes = ['xAxis', 'yAxis']; /** * @inner */ function findAxesModels(seriesModel, ecModel) { return zrUtil.map(axesTypes, function (axisType) { var axisModel = seriesModel.getReferringComponents(axisType)[0]; if (true) { if (!axisModel) { throw new Error(axisType + ' \"' + zrUtil.retrieve( seriesModel.get(axisType + 'Index'), seriesModel.get(axisType + 'Id'), 0 ) + '\" not found'); } } return axisModel; }); } /** * @inner */ function isCartesian2D(seriesModel) { return seriesModel.get('coordinateSystem') === 'cartesian2d'; } Grid.create = function (ecModel, api) { var grids = []; ecModel.eachComponent('grid', function (gridModel, idx) { var grid = new Grid(gridModel, ecModel, api); grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize // should be performed in create stage. grid.resize(gridModel, api, true); gridModel.coordinateSystem = grid; grids.push(grid); }); // Inject the coordinateSystems into seriesModel ecModel.eachSeries(function (seriesModel) { if (!isCartesian2D(seriesModel)) { return; } var axesModels = findAxesModels(seriesModel, ecModel); var xAxisModel = axesModels[0]; var yAxisModel = axesModels[1]; var gridModel = xAxisModel.getCoordSysModel(); if (true) { if (!gridModel) { throw new Error( 'Grid \"' + zrUtil.retrieve( xAxisModel.get('gridIndex'), xAxisModel.get('gridId'), 0 ) + '\" not found' ); } if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) { throw new Error('xAxis and yAxis must use the same grid'); } } var grid = gridModel.coordinateSystem; seriesModel.coordinateSystem = grid.getCartesian( xAxisModel.componentIndex, yAxisModel.componentIndex ); }); return grids; }; // For deciding which dimensions to use when creating list data Grid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions; __webpack_require__(79).register('cartesian2d', Grid); module.exports = Grid; /***/ }), /* 129 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var zrUtil = __webpack_require__(4); var Cartesian = __webpack_require__(130); function Cartesian2D(name) { Cartesian.call(this, name); } Cartesian2D.prototype = { constructor: Cartesian2D, type: 'cartesian2d', /** * @type {Array.} * @readOnly */ dimensions: ['x', 'y'], /** * Base axis will be used on stacking. * * @return {module:echarts/coord/cartesian/Axis2D} */ getBaseAxis: function () { return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x'); }, /** * If contain point * @param {Array.} point * @return {boolean} */ containPoint: function (point) { var axisX = this.getAxis('x'); var axisY = this.getAxis('y'); return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1])); }, /** * If contain data * @param {Array.} data * @return {boolean} */ containData: function (data) { return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]); }, /** * @param {Array.} data * @param {boolean} [clamp=false] * @return {Array.} */ dataToPoint: function (data, clamp) { var xAxis = this.getAxis('x'); var yAxis = this.getAxis('y'); return [ xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)), yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp)) ]; }, /** * @param {Array.} point * @param {boolean} [clamp=false] * @return {Array.} */ pointToData: function (point, clamp) { var xAxis = this.getAxis('x'); var yAxis = this.getAxis('y'); return [ xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp), yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp) ]; }, /** * Get other axis * @param {module:echarts/coord/cartesian/Axis2D} axis */ getOtherAxis: function (axis) { return this.getAxis(axis.dim === 'x' ? 'y' : 'x'); } }; zrUtil.inherits(Cartesian2D, Cartesian); module.exports = Cartesian2D; /***/ }), /* 130 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; /** * Cartesian coordinate system * @module echarts/coord/Cartesian * */ var zrUtil = __webpack_require__(4); function dimAxisMapper(dim) { return this._axes[dim]; } /** * @alias module:echarts/coord/Cartesian * @constructor */ var Cartesian = function (name) { this._axes = {}; this._dimList = []; /** * @type {string} */ this.name = name || ''; }; Cartesian.prototype = { constructor: Cartesian, type: 'cartesian', /** * Get axis * @param {number|string} dim * @return {module:echarts/coord/Cartesian~Axis} */ getAxis: function (dim) { return this._axes[dim]; }, /** * Get axes list * @return {Array.} */ getAxes: function () { return zrUtil.map(this._dimList, dimAxisMapper, this); }, /** * Get axes list by given scale type */ getAxesByScale: function (scaleType) { scaleType = scaleType.toLowerCase(); return zrUtil.filter( this.getAxes(), function (axis) { return axis.scale.type === scaleType; } ); }, /** * Add axis * @param {module:echarts/coord/Cartesian.Axis} */ addAxis: function (axis) { var dim = axis.dim; this._axes[dim] = axis; this._dimList.push(dim); }, /** * Convert data to coord in nd space * @param {Array.|Object.} val * @return {Array.|Object.} */ dataToCoord: function (val) { return this._dataCoordConvert(val, 'dataToCoord'); }, /** * Convert coord in nd space to data * @param {Array.|Object.} val * @return {Array.|Object.} */ coordToData: function (val) { return this._dataCoordConvert(val, 'coordToData'); }, _dataCoordConvert: function (input, method) { var dimList = this._dimList; var output = input instanceof Array ? [] : {}; for (var i = 0; i < dimList.length; i++) { var dim = dimList[i]; var axis = this._axes[dim]; output[dim] = axis[method](input[dim]); } return output; } }; module.exports = Cartesian; /***/ }), /* 131 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); var Axis = __webpack_require__(103); /** * Extend axis 2d * @constructor module:echarts/coord/cartesian/Axis2D * @extends {module:echarts/coord/cartesian/Axis} * @param {string} dim * @param {*} scale * @param {Array.} coordExtent * @param {string} axisType * @param {string} position */ var Axis2D = function (dim, scale, coordExtent, axisType, position) { Axis.call(this, dim, scale, coordExtent); /** * Axis type * - 'category' * - 'value' * - 'time' * - 'log' * @type {string} */ this.type = axisType || 'value'; /** * Axis position * - 'top' * - 'bottom' * - 'left' * - 'right' */ this.position = position || 'bottom'; }; Axis2D.prototype = { constructor: Axis2D, /** * Index of axis, can be used as key */ index: 0, /** * If axis is on the zero position of the other axis * @type {boolean} */ onZero: false, /** * Axis model * @param {module:echarts/coord/cartesian/AxisModel} */ model: null, isHorizontal: function () { var position = this.position; return position === 'top' || position === 'bottom'; }, /** * Each item cooresponds to this.getExtent(), which * means globalExtent[0] may greater than globalExtent[1], * unless `asc` is input. * * @param {boolean} [asc] * @return {Array.} */ getGlobalExtent: function (asc) { var ret = this.getExtent(); ret[0] = this.toGlobalCoord(ret[0]); ret[1] = this.toGlobalCoord(ret[1]); asc && ret[0] > ret[1] && ret.reverse(); return ret; }, getOtherAxis: function () { this.grid.getOtherAxis(); }, /** * If label is ignored. * Automatically used when axis is category and label can not be all shown * @param {number} idx * @return {boolean} */ isLabelIgnored: function (idx) { if (this.type === 'category') { var labelInterval = this.getLabelInterval(); return ((typeof labelInterval === 'function') && !labelInterval(idx, this.scale.getLabel(idx))) || idx % (labelInterval + 1); } }, /** * @override */ pointToData: function (point, clamp) { return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp); }, /** * Transform global coord to local coord, * i.e. var localCoord = axis.toLocalCoord(80); * designate by module:echarts/coord/cartesian/Grid. * @type {Function} */ toLocalCoord: null, /** * Transform global coord to local coord, * i.e. var globalCoord = axis.toLocalCoord(40); * designate by module:echarts/coord/cartesian/Grid. * @type {Function} */ toGlobalCoord: null }; zrUtil.inherits(Axis2D, Axis); module.exports = Axis2D; /***/ }), /* 132 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // Grid 是在有直角坐标系的时候必须要存在的 // 所以这里也要被 Cartesian2D 依赖 __webpack_require__(133); var ComponentModel = __webpack_require__(72); module.exports = ComponentModel.extend({ type: 'grid', dependencies: ['xAxis', 'yAxis'], layoutMode: 'box', /** * @type {module:echarts/coord/cartesian/Grid} */ coordinateSystem: null, defaultOption: { show: false, zlevel: 0, z: 0, left: '10%', top: 60, right: '10%', bottom: 60, // If grid size contain label containLabel: false, // width: {totalWidth} - left - right, // height: {totalHeight} - top - bottom, backgroundColor: 'rgba(0,0,0,0)', borderWidth: 1, borderColor: '#ccc' } }); /***/ }), /* 133 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var ComponentModel = __webpack_require__(72); var zrUtil = __webpack_require__(4); var axisModelCreator = __webpack_require__(134); var AxisModel = ComponentModel.extend({ type: 'cartesian2dAxis', /** * @type {module:echarts/coord/cartesian/Axis2D} */ axis: null, /** * @override */ init: function () { AxisModel.superApply(this, 'init', arguments); this.resetRange(); }, /** * @override */ mergeOption: function () { AxisModel.superApply(this, 'mergeOption', arguments); this.resetRange(); }, /** * @override */ restoreData: function () { AxisModel.superApply(this, 'restoreData', arguments); this.resetRange(); }, /** * @override * @return {module:echarts/model/Component} */ getCoordSysModel: function () { return this.ecModel.queryComponents({ mainType: 'grid', index: this.option.gridIndex, id: this.option.gridId })[0]; } }); function getAxisType(axisDim, option) { // Default axis with data is category axis return option.type || (option.data ? 'category' : 'value'); } zrUtil.merge(AxisModel.prototype, __webpack_require__(115)); var extraOption = { // gridIndex: 0, // gridId: '', // Offset is for multiple axis on the same position offset: 0 }; axisModelCreator('x', AxisModel, getAxisType, extraOption); axisModelCreator('y', AxisModel, getAxisType, extraOption); module.exports = AxisModel; /***/ }), /* 134 */ /***/ (function(module, exports, __webpack_require__) { var axisDefault = __webpack_require__(135); var zrUtil = __webpack_require__(4); var ComponentModel = __webpack_require__(72); var layout = __webpack_require__(74); // FIXME axisType is fixed ? var AXIS_TYPES = ['value', 'category', 'time', 'log']; /** * Generate sub axis model class * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel' * @param {module:echarts/model/Component} BaseAxisModelClass * @param {Function} axisTypeDefaulter * @param {Object} [extraDefaultOption] */ module.exports = function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) { zrUtil.each(AXIS_TYPES, function (axisType) { BaseAxisModelClass.extend({ type: axisName + 'Axis.' + axisType, mergeDefaultAndTheme: function (option, ecModel) { var layoutMode = this.layoutMode; var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {}; var themeModel = ecModel.getTheme(); zrUtil.merge(option, themeModel.get(axisType + 'Axis')); zrUtil.merge(option, this.getDefaultOption()); option.type = axisTypeDefaulter(axisName, option); if (layoutMode) { layout.mergeLayoutParam(option, inputPositionParams, layoutMode); } }, defaultOption: zrUtil.mergeAll( [ {}, axisDefault[axisType + 'Axis'], extraDefaultOption ], true ) }); }); ComponentModel.registerSubTypeDefaulter( axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName) ); }; /***/ }), /* 135 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); var defaultOption = { show: true, zlevel: 0, // 一级层叠 z: 0, // 二级层叠 // 反向坐标轴 inverse: false, // 坐标轴名字，默认为空 name: '', // 坐标轴名字位置，支持'start' | 'middle' | 'end' nameLocation: 'end', // 坐标轴名字旋转，degree。 nameRotate: null, // Adapt to axis rotate, when nameLocation is 'middle'. nameTruncate: { maxWidth: null, ellipsis: '...', placeholder: '.' }, // 坐标轴文字样式，默认取全局样式 nameTextStyle: {}, // 文字与轴线距离 nameGap: 15, silent: false, // Default false to support tooltip. triggerEvent: false, // Default false to avoid legacy user event listener fail. tooltip: { show: false }, axisPointer: {}, // 坐标轴线 axisLine: { // 默认显示，属性show控制显示与否 show: true, onZero: true, onZeroAxisIndex: null, // 属性lineStyle控制线条样式 lineStyle: { color: '#333', width: 1, type: 'solid' } }, // 坐标轴小标记 axisTick: { // 属性show控制显示与否，默认显示 show: true, // 控制小标记是否在grid里 inside: false, // 属性length控制线长 length: 5, // 属性lineStyle控制线条样式 lineStyle: { width: 1 } }, // 坐标轴文本标签，详见axis.axisLabel axisLabel: { show: true, // 控制文本标签是否在grid里 inside: false, rotate: 0, showMinLabel: null, // true | false | null (auto) showMaxLabel: null, // true | false | null (auto) margin: 8, // formatter: null, // 其余属性默认使用全局文本样式，详见TEXTSTYLE fontSize: 12 }, // 分隔线 splitLine: { // 默认显示，属性show控制显示与否 show: true, // 属性lineStyle（详见lineStyle）控制线条样式 lineStyle: { color: ['#ccc'], width: 1, type: 'solid' } }, // 分隔区域 splitArea: { // 默认不显示，属性show控制显示与否 show: false, // 属性areaStyle（详见areaStyle）控制区域样式 areaStyle: { color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)'] } } }; var categoryAxis = zrUtil.merge({ // 类目起始和结束两端空白策略 boundaryGap: true, // splitArea: { // show: false // }, splitLine: { show: false }, // 坐标轴小标记 axisTick: { // If tick is align with label when boundaryGap is true alignWithLabel: false, interval: 'auto' }, // 坐标轴文本标签，详见axis.axisLabel axisLabel: { interval: 'auto' } }, defaultOption); var valueAxis = zrUtil.merge({ // 数值起始和结束两端空白策略 boundaryGap: [0, 0], // 最小值, 设置成 'dataMin' 则从数据中计算最小值 // min: null, // 最大值，设置成 'dataMax' 则从数据中计算最大值 // max: null, // Readonly prop, specifies start value of the range when using data zoom. // rangeStart: null // Readonly prop, specifies end value of the range when using data zoom. // rangeEnd: null // 脱离0值比例，放大聚焦到最终_min，_max区间 // scale: false, // 分割段数，默认为5 splitNumber: 5 // Minimum interval // minInterval: null // maxInterval: null }, defaultOption); // FIXME var timeAxis = zrUtil.defaults({ scale: true, min: 'dataMin', max: 'dataMax' }, valueAxis); var logAxis = zrUtil.defaults({ scale: true, logBase: 10 }, valueAxis); module.exports = { categoryAxis: categoryAxis, valueAxis: valueAxis, timeAxis: timeAxis, logAxis: logAxis }; /***/ }), /* 136 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; // TODO boundaryGap __webpack_require__(133); __webpack_require__(137); /***/ }), /* 137 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); var graphic = __webpack_require__(20); var AxisBuilder = __webpack_require__(138); var AxisView = __webpack_require__(139); var cartesianAxisHelper = __webpack_require__(141); var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick; var getInterval = AxisBuilder.getInterval; var axisBuilderAttrs = [ 'axisLine', 'axisTickLabel', 'axisName' ]; var selfBuilderAttrs = [ 'splitArea', 'splitLine' ]; // function getAlignWithLabel(model, axisModel) { // var alignWithLabel = model.get('alignWithLabel'); // if (alignWithLabel === 'auto') { // alignWithLabel = axisModel.get('axisTick.alignWithLabel'); // } // return alignWithLabel; // } var CartesianAxisView = AxisView.extend({ type: 'cartesianAxis', axisPointerClass: 'CartesianAxisPointer', /** * @override */ render: function (axisModel, ecModel, api, payload) { this.group.removeAll(); var oldAxisGroup = this._axisGroup; this._axisGroup = new graphic.Group(); this.group.add(this._axisGroup); if (!axisModel.get('show')) { return; } var gridModel = axisModel.getCoordSysModel(); var layout = cartesianAxisHelper.layout(gridModel, axisModel); var axisBuilder = new AxisBuilder(axisModel, layout); zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder); this._axisGroup.add(axisBuilder.getGroup()); zrUtil.each(selfBuilderAttrs, function (name) { if (axisModel.get(name + '.show')) { this['_' + name](axisModel, gridModel, layout.labelInterval); } }, this); graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel); CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload); }, /** * @param {module:echarts/coord/cartesian/AxisModel} axisModel * @param {module:echarts/coord/cartesian/GridModel} gridModel * @param {number|Function} labelInterval * @private */ _splitLine: function (axisModel, gridModel, labelInterval) { var axis = axisModel.axis; if (axis.scale.isBlank()) { return; } var splitLineModel = axisModel.getModel('splitLine'); var lineStyleModel = splitLineModel.getModel('lineStyle'); var lineColors = lineStyleModel.get('color'); var lineInterval = getInterval(splitLineModel, labelInterval); lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors]; var gridRect = gridModel.coordinateSystem.getRect(); var isHorizontal = axis.isHorizontal(); var lineCount = 0; var ticksCoords = axis.getTicksCoords( // splitLineModel.get('alignWithLabel') ); var ticks = axis.scale.getTicks(); var showMinLabel = axisModel.get('axisLabel.showMinLabel'); var showMaxLabel = axisModel.get('axisLabel.showMaxLabel'); var p1 = []; var p2 = []; // Simple optimization // Batching the lines if color are the same var lineStyle = lineStyleModel.getLineStyle(); for (var i = 0; i < ticksCoords.length; i++) { if (ifIgnoreOnTick( axis, i, lineInterval, ticksCoords.length, showMinLabel, showMaxLabel )) { continue; } var tickCoord = axis.toGlobalCoord(ticksCoords[i]); if (isHorizontal) { p1[0] = tickCoord; p1[1] = gridRect.y; p2[0] = tickCoord; p2[1] = gridRect.y + gridRect.height; } else { p1[0] = gridRect.x; p1[1] = tickCoord; p2[0] = gridRect.x + gridRect.width; p2[1] = tickCoord; } var colorIndex = (lineCount++) % lineColors.length; this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({ anid: 'line_' + ticks[i], shape: { x1: p1[0], y1: p1[1], x2: p2[0], y2: p2[1] }, style: zrUtil.defaults({ stroke: lineColors[colorIndex] }, lineStyle), silent: true }))); } }, /** * @param {module:echarts/coord/cartesian/AxisModel} axisModel * @param {module:echarts/coord/cartesian/GridModel} gridModel * @param {number|Function} labelInterval * @private */ _splitArea: function (axisModel, gridModel, labelInterval) { var axis = axisModel.axis; if (axis.scale.isBlank()) { return; } var splitAreaModel = axisModel.getModel('splitArea'); var areaStyleModel = splitAreaModel.getModel('areaStyle'); var areaColors = areaStyleModel.get('color'); var gridRect = gridModel.coordinateSystem.getRect(); var ticksCoords = axis.getTicksCoords( // splitAreaModel.get('alignWithLabel') ); var ticks = axis.scale.getTicks(); var prevX = axis.toGlobalCoord(ticksCoords[0]); var prevY = axis.toGlobalCoord(ticksCoords[0]); var count = 0; var areaInterval = getInterval(splitAreaModel, labelInterval); var areaStyle = areaStyleModel.getAreaStyle(); areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors]; var showMinLabel = axisModel.get('axisLabel.showMinLabel'); var showMaxLabel = axisModel.get('axisLabel.showMaxLabel'); for (var i = 1; i < ticksCoords.length; i++) { if (ifIgnoreOnTick( axis, i, areaInterval, ticksCoords.length, showMinLabel, showMaxLabel )) { continue; } var tickCoord = axis.toGlobalCoord(ticksCoords[i]); var x; var y; var width; var height; if (axis.isHorizontal()) { x = prevX; y = gridRect.y; width = tickCoord - x; height = gridRect.height; } else { x = gridRect.x; y = prevY; width = gridRect.width; height = tickCoord - y; } var colorIndex = (count++) % areaColors.length; this._axisGroup.add(new graphic.Rect({ anid: 'area_' + ticks[i], shape: { x: x, y: y, width: width, height: height }, style: zrUtil.defaults({ fill: areaColors[colorIndex] }, areaStyle), silent: true })); prevX = x + width; prevY = y + height; } } }); CartesianAxisView.extend({ type: 'xAxis' }); CartesianAxisView.extend({ type: 'yAxis' }); /***/ }), /* 138 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); var formatUtil = __webpack_require__(6); var graphic = __webpack_require__(20); var Model = __webpack_require__(14); var numberUtil = __webpack_require__(7); var remRadian = numberUtil.remRadian; var isRadianAroundZero = numberUtil.isRadianAroundZero; var vec2 = __webpack_require__(10); var matrix = __webpack_require__(11); var v2ApplyTransform = vec2.applyTransform; var retrieve = zrUtil.retrieve; var PI = Math.PI; function makeAxisEventDataBase(axisModel) { var eventData = { componentType: axisModel.mainType }; eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex; return eventData; } /** * A final axis is translated and rotated from a \"standard axis\". * So opt.position and opt.rotation is required. * * A standard axis is and axis from [0, 0] to [0, axisExtent[1]], * for example: (0, 0) ------------> (0, 50) * * nameDirection or tickDirection or labelDirection is 1 means tick * or label is below the standard axis, whereas is -1 means above * the standard axis. labelOffset means offset between label and axis, * which is useful when 'onZero', where axisLabel is in the grid and * label in outside grid. * * Tips: like always, * positive rotation represents anticlockwise, and negative rotation * represents clockwise. * The direction of position coordinate is the same as the direction * of screen coordinate. * * Do not need to consider axis 'inverse', which is auto processed by * axis extent. * * @param {module:zrender/container/Group} group * @param {Object} axisModel * @param {Object} opt Standard axis parameters. * @param {Array.} opt.position [x, y] * @param {number} opt.rotation by radian * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle' or 'center'. * @param {number} [opt.tickDirection=1] 1 or -1 * @param {number} [opt.labelDirection=1] 1 or -1 * @param {number} [opt.labelOffset=0] Usefull when onZero. * @param {string} [opt.axisLabelShow] default get from axisModel. * @param {string} [opt.axisName] default get from axisModel. * @param {number} [opt.axisNameAvailableWidth] * @param {number} [opt.labelRotate] by degree, default get from axisModel. * @param {number} [opt.labelInterval] Default label interval when label * interval from model is null or 'auto'. * @param {number} [opt.strokeContainThreshold] Default label interval when label * @param {number} [opt.nameTruncateMaxWidth] */ var AxisBuilder = function (axisModel, opt) { /** * @readOnly */ this.opt = opt; /** * @readOnly */ this.axisModel = axisModel; // Default value zrUtil.defaults( opt, { labelOffset: 0, nameDirection: 1, tickDirection: 1, labelDirection: 1, silent: true } ); /** * @readOnly */ this.group = new graphic.Group(); // FIXME Not use a seperate text group? var dumbGroup = new graphic.Group({ position: opt.position.slice(), rotation: opt.rotation }); // this.group.add(dumbGroup); // this._dumbGroup = dumbGroup; dumbGroup.updateTransform(); this._transform = dumbGroup.transform; this._dumbGroup = dumbGroup; }; AxisBuilder.prototype = { constructor: AxisBuilder, hasBuilder: function (name) { return !!builders[name]; }, add: function (name) { builders[name].call(this); }, getGroup: function () { return this.group; } }; var builders = { /** * @private */ axisLine: function () { var opt = this.opt; var axisModel = this.axisModel; if (!axisModel.get('axisLine.show')) { return; } var extent = this.axisModel.axis.getExtent(); var matrix = this._transform; var pt1 = [extent[0], 0]; var pt2 = [extent[1], 0]; if (matrix) { v2ApplyTransform(pt1, pt1, matrix); v2ApplyTransform(pt2, pt2, matrix); } this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({ // Id for animation anid: 'line', shape: { x1: pt1[0], y1: pt1[1], x2: pt2[0], y2: pt2[1] }, style: zrUtil.extend( {lineCap: 'round'}, axisModel.getModel('axisLine.lineStyle').getLineStyle() ), strokeContainThreshold: opt.strokeContainThreshold || 5, silent: true, z2: 1 }))); }, /** * @private */ axisTickLabel: function () { var axisModel = this.axisModel; var opt = this.opt; var tickEls = buildAxisTick(this, axisModel, opt); var labelEls = buildAxisLabel(this, axisModel, opt); fixMinMaxLabelShow(axisModel, labelEls, tickEls); }, /** * @private */ axisName: function () { var opt = this.opt; var axisModel = this.axisModel; var name = retrieve(opt.axisName, axisModel.get('name')); if (!name) { return; } var nameLocation = axisModel.get('nameLocation'); var nameDirection = opt.nameDirection; var textStyleModel = axisModel.getModel('nameTextStyle'); var gap = axisModel.get('nameGap') || 0; var extent = this.axisModel.axis.getExtent(); var gapSignal = extent[0] > extent[1] ? -1 : 1; var pos = [ nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // 'middle' // Reuse labelOffset. isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0 ]; var labelLayout; var nameRotation = axisModel.get('nameRotate'); if (nameRotation != null) { nameRotation = nameRotation * PI / 180; // To radian. } var axisNameAvailableWidth; if (isNameLocationCenter(nameLocation)) { labelLayout = innerTextLayout( opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis. nameDirection ); } else { labelLayout = endTextLayout( opt, nameLocation, nameRotation || 0, extent ); axisNameAvailableWidth = opt.axisNameAvailableWidth; if (axisNameAvailableWidth != null) { axisNameAvailableWidth = Math.abs( axisNameAvailableWidth / Math.sin(labelLayout.rotation) ); !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null); } } var textFont = textStyleModel.getFont(); var truncateOpt = axisModel.get('nameTruncate', true) || {}; var ellipsis = truncateOpt.ellipsis; var maxWidth = retrieve( opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth ); // FIXME // truncate rich text? (consider performance) var truncatedText = (ellipsis != null && maxWidth != null) ? formatUtil.truncateText( name, maxWidth, textFont, ellipsis, {minChar: 2, placeholder: truncateOpt.placeholder} ) : name; var tooltipOpt = axisModel.get('tooltip', true); var mainType = axisModel.mainType; var formatterParams = { componentType: mainType, name: name, $vars: ['name'] }; formatterParams[mainType + 'Index'] = axisModel.componentIndex; var textEl = new graphic.Text({ // Id for animation anid: 'name', __fullText: name, __truncatedText: truncatedText, position: pos, rotation: labelLayout.rotation, silent: isSilent(axisModel), z2: 1, tooltip: (tooltipOpt && tooltipOpt.show) ? zrUtil.extend({ content: name, formatter: function () { return name; }, formatterParams: formatterParams }, tooltipOpt) : null }); graphic.setTextStyle(textEl.style, textStyleModel, { text: truncatedText, textFont: textFont, textFill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'), textAlign: labelLayout.textAlign, textVerticalAlign: labelLayout.textVerticalAlign }); if (axisModel.get('triggerEvent')) { textEl.eventData = makeAxisEventDataBase(axisModel); textEl.eventData.targetType = 'axisName'; textEl.eventData.name = name; } // FIXME this._dumbGroup.add(textEl); textEl.updateTransform(); this.group.add(textEl); textEl.decomposeTransform(); } }; /** * @public * @static * @param {Object} opt * @param {number} axisRotation in radian * @param {number} textRotation in radian * @param {number} direction * @return {Object} { * rotation, // according to axis * textAlign, * textVerticalAlign * } */ var innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) { var rotationDiff = remRadian(textRotation - axisRotation); var textAlign; var textVerticalAlign; if (isRadianAroundZero(rotationDiff)) { // Label is parallel with axis line. textVerticalAlign = direction > 0 ? 'top' : 'bottom'; textAlign = 'center'; } else if (isRadianAroundZero(rotationDiff - PI)) { // Label is inverse parallel with axis line. textVerticalAlign = direction > 0 ? 'bottom' : 'top'; textAlign = 'center'; } else { textVerticalAlign = 'middle'; if (rotationDiff > 0 && rotationDiff < PI) { textAlign = direction > 0 ? 'right' : 'left'; } else { textAlign = direction > 0 ? 'left' : 'right'; } } return { rotation: rotationDiff, textAlign: textAlign, textVerticalAlign: textVerticalAlign }; }; function endTextLayout(opt, textPosition, textRotate, extent) { var rotationDiff = remRadian(textRotate - opt.rotation); var textAlign; var textVerticalAlign; var inverse = extent[0] > extent[1]; var onLeft = (textPosition === 'start' && !inverse) || (textPosition !== 'start' && inverse); if (isRadianAroundZero(rotationDiff - PI / 2)) { textVerticalAlign = onLeft ? 'bottom' : 'top'; textAlign = 'center'; } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) { textVerticalAlign = onLeft ? 'top' : 'bottom'; textAlign = 'center'; } else { textVerticalAlign = 'middle'; if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) { textAlign = onLeft ? 'left' : 'right'; } else { textAlign = onLeft ? 'right' : 'left'; } } return { rotation: rotationDiff, textAlign: textAlign, textVerticalAlign: textVerticalAlign }; } function isSilent(axisModel) { var tooltipOpt = axisModel.get('tooltip'); return axisModel.get('silent') // Consider mouse cursor, add these restrictions. || !( axisModel.get('triggerEvent') || (tooltipOpt && tooltipOpt.show) ); } function fixMinMaxLabelShow(axisModel, labelEls, tickEls) { // If min or max are user set, we need to check // If the tick on min(max) are overlap on their neighbour tick // If they are overlapped, we need to hide the min(max) tick label var showMinLabel = axisModel.get('axisLabel.showMinLabel'); var showMaxLabel = axisModel.get('axisLabel.showMaxLabel'); // FIXME // Have not consider onBand yet, where tick els is more than label els. labelEls = labelEls || []; tickEls = tickEls || []; var firstLabel = labelEls[0]; var nextLabel = labelEls[1]; var lastLabel = labelEls[labelEls.length - 1]; var prevLabel = labelEls[labelEls.length - 2]; var firstTick = tickEls[0]; var nextTick = tickEls[1]; var lastTick = tickEls[tickEls.length - 1]; var prevTick = tickEls[tickEls.length - 2]; if (showMinLabel === false) { ignoreEl(firstLabel); ignoreEl(firstTick); } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) { if (showMinLabel) { ignoreEl(nextLabel); ignoreEl(nextTick); } else { ignoreEl(firstLabel); ignoreEl(firstTick); } } if (showMaxLabel === false) { ignoreEl(lastLabel); ignoreEl(lastTick); } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) { if (showMaxLabel) { ignoreEl(prevLabel); ignoreEl(prevTick); } else { ignoreEl(lastLabel); ignoreEl(lastTick); } } } function ignoreEl(el) { el && (el.ignore = true); } function isTwoLabelOverlapped(current, next, labelLayout) { // current and next has the same rotation. var firstRect = current && current.getBoundingRect().clone(); var nextRect = next && next.getBoundingRect().clone(); if (!firstRect || !nextRect) { return; } // When checking intersect of two rotated labels, we use mRotationBack // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`. var mRotationBack = matrix.identity([]); matrix.rotate(mRotationBack, mRotationBack, -current.rotation); firstRect.applyTransform(matrix.mul([], mRotationBack, current.getLocalTransform())); nextRect.applyTransform(matrix.mul([], mRotationBack, next.getLocalTransform())); return firstRect.intersect(nextRect); } function isNameLocationCenter(nameLocation) { return nameLocation === 'middle' || nameLocation === 'center'; } /** * @static */ var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function ( axis, i, interval, ticksCnt, showMinLabel, showMaxLabel ) { if (i === 0 && showMinLabel || i === ticksCnt - 1 && showMaxLabel) { return false; } // FIXME // Have not consider label overlap (if label is too long) yet. var rawTick; var scale = axis.scale; return scale.type === 'ordinal' && ( typeof interval === 'function' ? ( rawTick = scale.getTicks()[i], !interval(rawTick, scale.getLabel(rawTick)) ) : i % (interval + 1) ); }; /** * @static */ var getInterval = AxisBuilder.getInterval = function (model, labelInterval) { var interval = model.get('interval'); if (interval == null || interval == 'auto') { interval = labelInterval; } return interval; }; function buildAxisTick(axisBuilder, axisModel, opt) { var axis = axisModel.axis; if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) { return; } var tickModel = axisModel.getModel('axisTick'); var lineStyleModel = tickModel.getModel('lineStyle'); var tickLen = tickModel.get('length'); var tickInterval = getInterval(tickModel, opt.labelInterval); var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel')); // FIXME // Corresponds to ticksCoords ? var ticks = axis.scale.getTicks(); var showMinLabel = axisModel.get('axisLabel.showMinLabel'); var showMaxLabel = axisModel.get('axisLabel.showMaxLabel'); var pt1 = []; var pt2 = []; var matrix = axisBuilder._transform; var tickEls = []; var ticksCnt = ticksCoords.length; for (var i = 0; i < ticksCnt; i++) { // Only ordinal scale support tick interval if (ifIgnoreOnTick( axis, i, tickInterval, ticksCnt, showMinLabel, showMaxLabel )) { continue; } var tickCoord = ticksCoords[i]; pt1[0] = tickCoord; pt1[1] = 0; pt2[0] = tickCoord; pt2[1] = opt.tickDirection * tickLen; if (matrix) { v2ApplyTransform(pt1, pt1, matrix); v2ApplyTransform(pt2, pt2, matrix); } // Tick line, Not use group transform to have better line draw var tickEl = new graphic.Line(graphic.subPixelOptimizeLine({ // Id for animation anid: 'tick_' + ticks[i], shape: { x1: pt1[0], y1: pt1[1], x2: pt2[0], y2: pt2[1] }, style: zrUtil.defaults( lineStyleModel.getLineStyle(), { stroke: axisModel.get('axisLine.lineStyle.color') } ), z2: 2, silent: true })); axisBuilder.group.add(tickEl); tickEls.push(tickEl); } return tickEls; } function buildAxisLabel(axisBuilder, axisModel, opt) { var axis = axisModel.axis; var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show')); if (!show || axis.scale.isBlank()) { return; } var labelModel = axisModel.getModel('axisLabel'); var labelMargin = labelModel.get('margin'); var ticks = axis.scale.getTicks(); var labels = axisModel.getFormattedLabels(); // Special label rotate. var labelRotation = ( retrieve(opt.labelRotate, labelModel.get('rotate')) || 0 ) * PI / 180; var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection); var categoryData = axisModel.get('data'); var labelEls = []; var silent = isSilent(axisModel); var triggerEvent = axisModel.get('triggerEvent'); var showMinLabel = axisModel.get('axisLabel.showMinLabel'); var showMaxLabel = axisModel.get('axisLabel.showMaxLabel'); zrUtil.each(ticks, function (tickVal, index) { if (ifIgnoreOnTick( axis, index, opt.labelInterval, ticks.length, showMinLabel, showMaxLabel )) { return; } var itemLabelModel = labelModel; if (categoryData && categoryData[tickVal] && categoryData[tickVal].textStyle) { itemLabelModel = new Model( categoryData[tickVal].textStyle, labelModel, axisModel.ecModel ); } var textColor = itemLabelModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'); var tickCoord = axis.dataToCoord(tickVal); var pos = [ tickCoord, opt.labelOffset + opt.labelDirection * labelMargin ]; var labelStr = axis.scale.getLabel(tickVal); var textEl = new graphic.Text({ // Id for animation anid: 'label_' + tickVal, position: pos, rotation: labelLayout.rotation, silent: silent, z2: 10 }); graphic.setTextStyle(textEl.style, itemLabelModel, { text: labels[index], textAlign: itemLabelModel.getShallow('align', true) || labelLayout.textAlign, textVerticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign, textFill: typeof textColor === 'function' ? textColor( // (1) In category axis with data zoom, tick is not the original // index of axis.data. So tick should not be exposed to user // in category axis. // (2) Compatible with previous version, which always returns labelStr. // But in interval scale labelStr is like '223,445', which maked // user repalce ','. So we modify it to return original val but remain // it as 'string' to avoid error in replacing. axis.type === 'category' ? labelStr : axis.type === 'value' ? tickVal + '' : tickVal, index ) : textColor }); // Pack data for mouse event if (triggerEvent) { textEl.eventData = makeAxisEventDataBase(axisModel); textEl.eventData.targetType = 'axisLabel'; textEl.eventData.value = labelStr; } // FIXME axisBuilder._dumbGroup.add(textEl); textEl.updateTransform(); labelEls.push(textEl); axisBuilder.group.add(textEl); textEl.decomposeTransform(); }); return labelEls; } module.exports = AxisBuilder; /***/ }), /* 139 */ /***/ (function(module, exports, __webpack_require__) { var axisPointerModelHelper = __webpack_require__(140); /** * Base class of AxisView. */ var AxisView = __webpack_require__(1).extendComponentView({ type: 'axis', /** * @private */ _axisPointer: null, /** * @protected * @type {string} */ axisPointerClass: null, /** * @override */ render: function (axisModel, ecModel, api, payload) { // FIXME // This process should proformed after coordinate systems updated // (axis scale updated), and should be performed each time update. // So put it here temporarily, although it is not appropriate to // put a model-writing procedure in `view`. this.axisPointerClass && axisPointerModelHelper.fixValue(axisModel); AxisView.superApply(this, 'render', arguments); updateAxisPointer(this, axisModel, ecModel, api, payload, true); }, /** * Action handler. * @public * @param {module:echarts/coord/cartesian/AxisModel} axisModel * @param {module:echarts/model/Global} ecModel * @param {module:echarts/ExtensionAPI} api * @param {Object} payload */ updateAxisPointer: function (axisModel, ecModel, api, payload, force) { updateAxisPointer(this, axisModel, ecModel, api, payload, false); }, /** * @override */ remove: function (ecModel, api) { var axisPointer = this._axisPointer; axisPointer && axisPointer.remove(api); AxisView.superApply(this, 'remove', arguments); }, /** * @override */ dispose: function (ecModel, api) { disposeAxisPointer(this, api); AxisView.superApply(this, 'dispose', arguments); } }); function updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) { var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass); if (!Clazz) { return; } var axisPointerModel = axisPointerModelHelper.getAxisPointerModel(axisModel); axisPointerModel ? (axisView._axisPointer || (axisView._axisPointer = new Clazz())) .render(axisModel, axisPointerModel, api, forceRender) : disposeAxisPointer(axisView, api); } function disposeAxisPointer(axisView, ecModel, api) { var axisPointer = axisView._axisPointer; axisPointer && axisPointer.dispose(ecModel, api); axisView._axisPointer = null; } var axisPointerClazz = []; AxisView.registerAxisPointerClass = function (type, clazz) { if (true) { if (axisPointerClazz[type]) { throw new Error('axisPointer ' + type + ' exists'); } } axisPointerClazz[type] = clazz; }; AxisView.getAxisPointerClass = function (type) { return type && axisPointerClazz[type]; }; module.exports = AxisView; /***/ }), /* 140 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); var Model = __webpack_require__(14); var each = zrUtil.each; var curry = zrUtil.curry; var helper = {}; // Build axisPointerModel, mergin tooltip.axisPointer model for each axis. // allAxesInfo should be updated when setOption performed. helper.collect = function (ecModel, api) { var result = { /** * key: makeKey(axis.model) * value: { * axis, * coordSys, * axisPointerModel, * triggerTooltip, * involveSeries, * snap, * seriesModels, * seriesDataCount * } */ axesInfo: {}, seriesInvolved: false, /** * key: makeKey(coordSys.model) * value: Object: key makeKey(axis.model), value: axisInfo */ coordSysAxesInfo: {}, coordSysMap: {} }; collectAxesInfo(result, ecModel, api); // Check seriesInvolved for performance, in case too many series in some chart. result.seriesInvolved && collectSeriesInfo(result, ecModel); return result; }; function collectAxesInfo(result, ecModel, api) { var globalTooltipModel = ecModel.getComponent('tooltip'); var globalAxisPointerModel = ecModel.getComponent('axisPointer'); // links can only be set on global. var linksOption = globalAxisPointerModel.get('link', true) || []; var linkGroups = []; // Collect axes info. each(api.getCoordinateSystems(), function (coordSys) { // Some coordinate system do not support axes, like geo. if (!coordSys.axisPointerEnabled) { return; } var coordSysKey = makeKey(coordSys.model); var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {}; result.coordSysMap[coordSysKey] = coordSys; // Set tooltip (like 'cross') is a convienent way to show axisPointer // for user. So we enable seting tooltip on coordSys model. var coordSysModel = coordSys.model; var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel); each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null)); // If axis tooltip used, choose tooltip axis for each coordSys. // Notice this case: coordSys is `grid` but not `cartesian2D` here. if (coordSys.getTooltipAxes && globalTooltipModel // If tooltip.showContent is set as false, tooltip will not // show but axisPointer will show as normal. && baseTooltipModel.get('show') ) { // Compatible with previous logic. But series.tooltip.trigger: 'axis' // or series.data[n].tooltip.trigger: 'axis' are not support any more. var triggerAxis = baseTooltipModel.get('trigger') === 'axis'; var cross = baseTooltipModel.get('axisPointer.type') === 'cross'; var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get('axisPointer.axis')); if (triggerAxis || cross) { each(tooltipAxes.baseAxes, curry( saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis )); } if (cross) { each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, 'cross', false)); } } // fromTooltip: true | false | 'cross' // triggerTooltip: true | false | null function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) { var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel); var axisPointerShow = axisPointerModel.get('show'); if (!axisPointerShow || ( axisPointerShow === 'auto' && !fromTooltip && !isHandleTrigger(axisPointerModel) )) { return; } if (triggerTooltip == null) { triggerTooltip = axisPointerModel.get('triggerTooltip'); } axisPointerModel = fromTooltip ? makeAxisPointerModel( axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip ) : axisPointerModel; var snap = axisPointerModel.get('snap'); var key = makeKey(axis.model); var involveSeries = triggerTooltip || snap || axis.type === 'category'; // If result.axesInfo[key] exist, override it (tooltip has higher priority). var axisInfo = result.axesInfo[key] = { key: key, axis: axis, coordSys: coordSys, axisPointerModel: axisPointerModel, triggerTooltip: triggerTooltip, involveSeries: involveSeries, snap: snap, useHandle: isHandleTrigger(axisPointerModel), seriesModels: [] }; axesInfoInCoordSys[key] = axisInfo; result.seriesInvolved |= involveSeries; var groupIndex = getLinkGroupIndex(linksOption, axis); if (groupIndex != null) { var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {axesInfo: {}}); linkGroup.axesInfo[key] = axisInfo; linkGroup.mapper = linksOption[groupIndex].mapper; axisInfo.linkGroup = linkGroup; } } }); } function makeAxisPointerModel( axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip ) { var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer'); var volatileOption = {}; each( [ 'type', 'snap', 'lineStyle', 'shadowStyle', 'label', 'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z' ], function (field) { volatileOption[field] = zrUtil.clone(tooltipAxisPointerModel.get(field)); } ); // category axis do not auto snap, otherwise some tick that do not // has value can not be hovered. value/time/log axis default snap if // triggered from tooltip and trigger tooltip. volatileOption.snap = axis.type !== 'category' && !!triggerTooltip; // Compatibel with previous behavior, tooltip axis do not show label by default. // Only these properties can be overrided from tooltip to axisPointer. if (tooltipAxisPointerModel.get('type') === 'cross') { volatileOption.type = 'line'; } var labelOption = volatileOption.label || (volatileOption.label = {}); // Follow the convention, do not show label when triggered by tooltip by default. labelOption.show == null && (labelOption.show = false); if (fromTooltip === 'cross') { // When 'cross', both axes show labels. labelOption.show = true; // If triggerTooltip, this is a base axis, which should better not use cross style // (cross style is dashed by default) if (!triggerTooltip) { var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle'); crossStyle && zrUtil.defaults(labelOption, crossStyle.textStyle); } } return axis.model.getModel( 'axisPointer', new Model(volatileOption, globalAxisPointerModel, ecModel) ); } function collectSeriesInfo(result, ecModel) { // Prepare data for axis trigger ecModel.eachSeries(function (seriesModel) { // Notice this case: this coordSys is `cartesian2D` but not `grid`. var coordSys = seriesModel.coordinateSystem; var seriesTooltipTrigger = seriesModel.get('tooltip.trigger', true); var seriesTooltipShow = seriesModel.get('tooltip.show', true); if (!coordSys || seriesTooltipTrigger === 'none' || seriesTooltipTrigger === false || seriesTooltipTrigger === 'item' || seriesTooltipShow === false || seriesModel.get('axisPointer.show', true) === false ) { return; } each(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) { var axis = axisInfo.axis; if (coordSys.getAxis(axis.dim) === axis) { axisInfo.seriesModels.push(seriesModel); axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0); axisInfo.seriesDataCount += seriesModel.getData().count(); } }); }, this); } /** * For example: * { * axisPointer: { * links: [{ * xAxisIndex: [2, 4], * yAxisIndex: 'all' * }, { * xAxisId: ['a5', 'a7'], * xAxisName: 'xxx' * }] * } * } */ function getLinkGroupIndex(linksOption, axis) { var axisModel = axis.model; var dim = axis.dim; for (var i = 0; i < linksOption.length; i++) { var linkOption = linksOption[i] || {}; if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id) || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex) || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name) ) { return i; } } } function checkPropInLink(linkPropValue, axisPropValue) { return linkPropValue === 'all' || (zrUtil.isArray(linkPropValue) && zrUtil.indexOf(linkPropValue, axisPropValue) >= 0) || linkPropValue === axisPropValue; } helper.fixValue = function (axisModel) { var axisInfo = helper.getAxisInfo(axisModel); if (!axisInfo) { return; } var axisPointerModel = axisInfo.axisPointerModel; var scale = axisInfo.axis.scale; var option = axisPointerModel.option; var status = axisPointerModel.get('status'); var value = axisPointerModel.get('value'); // Parse init value for category and time axis. if (value != null) { value = scale.parse(value); } var useHandle = isHandleTrigger(axisPointerModel); // If `handle` used, `axisPointer` will always be displayed, so value // and status should be initialized. if (status == null) { option.status = useHandle ? 'show' : 'hide'; } var extent = scale.getExtent().slice(); extent[0] > extent[1] && extent.reverse(); if (// Pick a value on axis when initializing. value == null // If both `handle` and `dataZoom` are used, value may be out of axis extent, // where we should re-pick a value to keep `handle` displaying normally. || value > extent[1] ) { // Make handle displayed on the end of the axis when init, which looks better. value = extent[1]; } if (value < extent[0]) { value = extent[0]; } option.value = value; if (useHandle) { option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show'; } }; helper.getAxisInfo = function (axisModel) { var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo; return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)]; }; helper.getAxisPointerModel = function (axisModel) { var axisInfo = helper.getAxisInfo(axisModel); return axisInfo && axisInfo.axisPointerModel; }; function isHandleTrigger(axisPointerModel) { return !!axisPointerModel.get('handle.show'); } /** * @param {module:echarts/model/Model} model * @return {string} unique key */ var makeKey = helper.makeKey = function (model) { return model.type + '||' + model.id; }; module.exports = helper; /***/ }), /* 141 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); var helper = {}; /** * @param {Object} opt {labelInside} * @return {Object} { * position, rotation, labelDirection, labelOffset, * tickDirection, labelRotate, labelInterval, z2 * } */ helper.layout = function (gridModel, axisModel, opt) { opt = opt || {}; var grid = gridModel.coordinateSystem; var axis = axisModel.axis; var layout = {}; var rawAxisPosition = axis.position; var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition; var axisDim = axis.dim; var rect = grid.getRect(); var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height]; var idx = {left: 0, right: 1, top: 0, bottom: 1, onZero: 2}; var axisOffset = axisModel.get('offset') || 0; var posBound = axisDim === 'x' ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset]; if (axis.onZero) { var otherAxis = grid.getAxis(axisDim === 'x' ? 'y' : 'x', axis.onZeroAxisIndex); var onZeroCoord = otherAxis.toGlobalCoord(otherAxis.dataToCoord(0)); posBound[idx['onZero']] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]); } // Axis position layout.position = [ axisDim === 'y' ? posBound[idx[axisPosition]] : rectBound[0], axisDim === 'x' ? posBound[idx[axisPosition]] : rectBound[3] ]; // Axis rotation layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1); // Tick and label direction, x y is axisDim var dirMap = {top: -1, bottom: 1, left: -1, right: 1}; layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition]; layout.labelOffset = axis.onZero ? posBound[idx[rawAxisPosition]] - posBound[idx['onZero']] : 0; if (axisModel.get('axisTick.inside')) { layout.tickDirection = -layout.tickDirection; } if (zrUtil.retrieve(opt.labelInside, axisModel.get('axisLabel.inside'))) { layout.labelDirection = -layout.labelDirection; } // Special label rotation var labelRotate = axisModel.get('axisLabel.rotate'); layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate; // label interval when auto mode. layout.labelInterval = axis.getLabelInterval(); // Over splitLine and splitArea layout.z2 = 1; return layout; }; module.exports = helper; /***/ }), /* 142 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); __webpack_require__(128); __webpack_require__(143); __webpack_require__(145); var barLayoutGrid = __webpack_require__(148); var echarts = __webpack_require__(1); echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar')); // Visual coding for legend echarts.registerVisual(function (ecModel) { ecModel.eachSeriesByType('bar', function (seriesModel) { var data = seriesModel.getData(); data.setVisual('legendSymbol', 'roundRect'); }); }); // In case developer forget to include grid component __webpack_require__(127); /***/ }), /* 143 */ /***/ (function(module, exports, __webpack_require__) { module.exports = __webpack_require__(144).extend({ type: 'series.bar', dependencies: ['grid', 'polar'], brushSelector: 'rect' }); /***/ }), /* 144 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var SeriesModel = __webpack_require__(83); var createListFromArray = __webpack_require__(112); module.exports = SeriesModel.extend({ type: 'series.__base_bar__', getInitialData: function (option, ecModel) { return createListFromArray(option.data, this, ecModel); }, getMarkerPosition: function (value) { var coordSys = this.coordinateSystem; if (coordSys) { // PENDING if clamp ? var pt = coordSys.dataToPoint(value, true); var data = this.getData(); var offset = data.getLayout('offset'); var size = data.getLayout('size'); var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1; pt[offsetIndex] += offset + size / 2; return pt; } return [NaN, NaN]; }, defaultOption: { zlevel: 0, // 一级层叠 z: 2, // 二级层叠 coordinateSystem: 'cartesian2d', legendHoverLink: true, // stack: null // Cartesian coordinate system // xAxisIndex: 0, // yAxisIndex: 0, // 最小高度改为0 barMinHeight: 0, // 最小角度为0，仅对极坐标系下的柱状图有效 barMinAngle: 0, // cursor: null, // barMaxWidth: null, // 默认自适应 // barWidth: null, // 柱间距离，默认为柱形宽度的30%，可设固定值 // barGap: '30%', // 类目间柱形距离，默认为类目间距的20%，可设固定值 // barCategoryGap: '20%', // label: { // normal: { // show: false // } // }, itemStyle: { // normal: { // color: '各异' // }, // emphasis: {} } } }); /***/ }), /* 145 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var zrUtil = __webpack_require__(4); var graphic = __webpack_require__(20); var helper = __webpack_require__(146); var BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'normal', 'barBorderWidth']; // FIXME // Just for compatible with ec2. zrUtil.extend(__webpack_require__(14).prototype, __webpack_require__(147)); var BarView = __webpack_require__(1).extendChartView({ type: 'bar', render: function (seriesModel, ecModel, api) { var coordinateSystemType = seriesModel.get('coordinateSystem'); if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar' ) { this._render(seriesModel, ecModel, api); } else if (true) { console.warn('Only cartesian2d and polar supported for bar.'); } return this.group; }, dispose: zrUtil.noop, _render: function (seriesModel, ecModel, api) { var group = this.group; var data = seriesModel.getData(); var oldData = this._data; var coord = seriesModel.coordinateSystem; var baseAxis = coord.getBaseAxis(); var isHorizontalOrRadial; if (coord.type === 'cartesian2d') { isHorizontalOrRadial = baseAxis.isHorizontal(); } else if (coord.type === 'polar') { isHorizontalOrRadial = baseAxis.dim === 'angle'; } var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null; data.diff(oldData) .add(function (dataIndex) { if (!data.hasValue(dataIndex)) { return; } var itemModel = data.getItemModel(dataIndex); var layout = getLayout[coord.type](data, dataIndex, itemModel); var el = elementCreator[coord.type]( data, dataIndex, itemModel, layout, isHorizontalOrRadial, animationModel ); data.setItemGraphicEl(dataIndex, el); group.add(el); updateStyle( el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar' ); }) .update(function (newIndex, oldIndex) { var el = oldData.getItemGraphicEl(oldIndex); if (!data.hasValue(newIndex)) { group.remove(el); return; } var itemModel = data.getItemModel(newIndex); var layout = getLayout[coord.type](data, newIndex, itemModel); if (el) { graphic.updateProps(el, {shape: layout}, animationModel, newIndex); } else { el = elementCreator[coord.type]( data, newIndex, itemModel, layout, isHorizontalOrRadial, animationModel, true ); } data.setItemGraphicEl(newIndex, el); // Add back group.add(el); updateStyle( el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar' ); }) .remove(function (dataIndex) { var el = oldData.getItemGraphicEl(dataIndex); if (coord.type === 'cartesian2d') { el && removeRect(dataIndex, animationModel, el); } else { el && removeSector(dataIndex, animationModel, el); } }) .execute(); this._data = data; }, remove: function (ecModel, api) { var group = this.group; var data = this._data; if (ecModel.get('animation')) { if (data) { data.eachItemGraphicEl(function (el) { if (el.type === 'sector') { removeSector(el.dataIndex, ecModel, el); } else { removeRect(el.dataIndex, ecModel, el); } }); } } else { group.removeAll(); } } }); var elementCreator = { cartesian2d: function ( data, dataIndex, itemModel, layout, isHorizontal, animationModel, isUpdate ) { var rect = new graphic.Rect({shape: zrUtil.extend({}, layout)}); // Animation if (animationModel) { var rectShape = rect.shape; var animateProperty = isHorizontal ? 'height' : 'width'; var animateTarget = {}; rectShape[animateProperty] = 0; animateTarget[animateProperty] = layout[animateProperty]; graphic[isUpdate ? 'updateProps' : 'initProps'](rect, { shape: animateTarget }, animationModel, dataIndex); } return rect; }, polar: function ( data, dataIndex, itemModel, layout, isRadial, animationModel, isUpdate ) { var sector = new graphic.Sector({shape: zrUtil.extend({}, layout)}); // Animation if (animationModel) { var sectorShape = sector.shape; var animateProperty = isRadial ? 'r' : 'endAngle'; var animateTarget = {}; sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle; animateTarget[animateProperty] = layout[animateProperty]; graphic[isUpdate ? 'updateProps' : 'initProps'](sector, { shape: animateTarget }, animationModel, dataIndex); } return sector; } }; function removeRect(dataIndex, animationModel, el) { // Not show text when animating el.style.text = null; graphic.updateProps(el, { shape: { width: 0 } }, animationModel, dataIndex, function () { el.parent && el.parent.remove(el); }); } function removeSector(dataIndex, animationModel, el) { // Not show text when animating el.style.text = null; graphic.updateProps(el, { shape: { r: el.shape.r0 } }, animationModel, dataIndex, function () { el.parent && el.parent.remove(el); }); } var getLayout = { cartesian2d: function (data, dataIndex, itemModel) { var layout = data.getItemLayout(dataIndex); var fixedLineWidth = getLineWidth(itemModel, layout); // fix layout with lineWidth var signX = layout.width > 0 ? 1 : -1; var signY = layout.height > 0 ? 1 : -1; return { x: layout.x + signX * fixedLineWidth / 2, y: layout.y + signY * fixedLineWidth / 2, width: layout.width - signX * fixedLineWidth, height: layout.height - signY * fixedLineWidth }; }, polar: function (data, dataIndex, itemModel) { var layout = data.getItemLayout(dataIndex); return { cx: layout.cx, cy: layout.cy, r0: layout.r0, r: layout.r, startAngle: layout.startAngle, endAngle: layout.endAngle }; } }; function updateStyle( el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar ) { var color = data.getItemVisual(dataIndex, 'color'); var opacity = data.getItemVisual(dataIndex, 'opacity'); var itemStyleModel = itemModel.getModel('itemStyle.normal'); var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle(); if (!isPolar) { el.setShape('r', itemStyleModel.get('barBorderRadius') || 0); } el.useStyle(zrUtil.defaults( { fill: color, opacity: opacity }, itemStyleModel.getBarItemStyle() )); var cursorStyle = itemModel.getShallow('cursor'); cursorStyle && el.attr('cursor', cursorStyle); var labelPositionOutside = isHorizontal ? (layout.height > 0 ? 'bottom' : 'top') : (layout.width > 0 ? 'left' : 'right'); if (!isPolar) { helper.setLabel( el.style, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside ); } graphic.setHoverStyle(el, hoverStyle); } // In case width or height are too small. function getLineWidth(itemModel, rawLayout) { var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0; return Math.min(lineWidth, Math.abs(rawLayout.width), Math.abs(rawLayout.height)); } module.exports = BarView; /***/ }), /* 146 */ /***/ (function(module, exports, __webpack_require__) { var graphic = __webpack_require__(20); var helper = {}; helper.setLabel = function ( normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside ) { var labelModel = itemModel.getModel('label.normal'); var hoverLabelModel = itemModel.getModel('label.emphasis'); graphic.setLabelStyle( normalStyle, hoverStyle, labelModel, hoverLabelModel, { labelFetcher: seriesModel, labelDataIndex: dataIndex, defaultText: seriesModel.getRawValue(dataIndex), isRectText: true, autoColor: color } ); fixPosition(normalStyle); fixPosition(hoverStyle); }; function fixPosition(style, labelPositionOutside) { if (style.textPosition === 'outside') { style.textPosition = labelPositionOutside; } } module.exports = helper; /***/ }), /* 147 */ /***/ (function(module, exports, __webpack_require__) { var getBarItemStyle = __webpack_require__(17)( [ ['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], // Compatitable with 2 ['stroke', 'barBorderColor'], ['lineWidth', 'barBorderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'] ] ); module.exports = { getBarItemStyle: function (excludes) { var style = getBarItemStyle.call(this, excludes); if (this.getBorderLineDash) { var lineDash = this.getBorderLineDash(); lineDash && (style.lineDash = lineDash); } return style; } }; /***/ }), /* 148 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var zrUtil = __webpack_require__(4); var numberUtil = __webpack_require__(7); var parsePercent = numberUtil.parsePercent; var STACK_PREFIX = '__ec_stack_'; function getSeriesStackId(seriesModel) { return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex; } function getAxisKey(axis) { return axis.dim + axis.index; } /** * @param {Object} opt * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently. * @param {number} opt.count Positive interger. * @param {number} [opt.barWidth] * @param {number} [opt.barMaxWidth] * @param {number} [opt.barGap] * @param {number} [opt.barCategoryGap] * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined. */ function getLayoutOnAxis(opt, api) { var params = []; var baseAxis = opt.axis; var axisKey = 'axis0'; if (baseAxis.type !== 'category') { return; } var bandWidth = baseAxis.getBandWidth(); for (var i = 0; i < opt.count || 0; i++) { params.push(zrUtil.defaults({ bandWidth: bandWidth, axisKey: axisKey, stackId: STACK_PREFIX + i }, opt)); } var widthAndOffsets = doCalBarWidthAndOffset(params, api); var result = []; for (var i = 0; i < opt.count; i++) { var item = widthAndOffsets[axisKey][STACK_PREFIX + i]; item.offsetCenter = item.offset + item.width / 2; result.push(item); } return result; } function calBarWidthAndOffset(barSeries, api) { var seriesInfoList = zrUtil.map(barSeries, function (seriesModel) { var data = seriesModel.getData(); var cartesian = seriesModel.coordinateSystem; var baseAxis = cartesian.getBaseAxis(); var axisExtent = baseAxis.getExtent(); var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : (Math.abs(axisExtent[1] - axisExtent[0]) / data.count()); var barWidth = parsePercent( seriesModel.get('barWidth'), bandWidth ); var barMaxWidth = parsePercent( seriesModel.get('barMaxWidth'), bandWidth ); var barGap = seriesModel.get('barGap'); var barCategoryGap = seriesModel.get('barCategoryGap'); return { bandWidth: bandWidth, barWidth: barWidth, barMaxWidth: barMaxWidth, barGap: barGap, barCategoryGap: barCategoryGap, axisKey: getAxisKey(baseAxis), stackId: getSeriesStackId(seriesModel) }; }); return doCalBarWidthAndOffset(seriesInfoList, api); } function doCalBarWidthAndOffset(seriesInfoList, api) { // Columns info on each category axis. Key is cartesian name var columnsMap = {}; zrUtil.each(seriesInfoList, function (seriesInfo, idx) { var axisKey = seriesInfo.axisKey; var bandWidth = seriesInfo.bandWidth; var columnsOnAxis = columnsMap[axisKey] || { bandWidth: bandWidth, remainedWidth: bandWidth, autoWidthCount: 0, categoryGap: '20%', gap: '30%', stacks: {} }; var stacks = columnsOnAxis.stacks; columnsMap[axisKey] = columnsOnAxis; var stackId = seriesInfo.stackId; if (!stacks[stackId]) { columnsOnAxis.autoWidthCount++; } stacks[stackId] = stacks[stackId] || { width: 0, maxWidth: 0 }; // Caution: In a single coordinate system, these barGrid attributes // will be shared by series. Consider that they have default values, // only the attributes set on the last series will work. // Do not change this fact unless there will be a break change. // TODO var barWidth = seriesInfo.barWidth; if (barWidth && !stacks[stackId].width) { // See #6312, do not restrict width. stacks[stackId].width = barWidth; barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth); columnsOnAxis.remainedWidth -= barWidth; } var barMaxWidth = seriesInfo.barMaxWidth; barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth); var barGap = seriesInfo.barGap; (barGap != null) && (columnsOnAxis.gap = barGap); var barCategoryGap = seriesInfo.barCategoryGap; (barCategoryGap != null) && (columnsOnAxis.categoryGap = barCategoryGap); }); var result = {}; zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) { result[coordSysName] = {}; var stacks = columnsOnAxis.stacks; var bandWidth = columnsOnAxis.bandWidth; var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth); var barGapPercent = parsePercent(columnsOnAxis.gap, 1); var remainedWidth = columnsOnAxis.remainedWidth; var autoWidthCount = columnsOnAxis.autoWidthCount; var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent); autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth zrUtil.each(stacks, function (column, stack) { var maxWidth = column.maxWidth; if (maxWidth && maxWidth < autoWidth) { maxWidth = Math.min(maxWidth, remainedWidth); if (column.width) { maxWidth = Math.min(maxWidth, column.width); } remainedWidth -= maxWidth; column.width = maxWidth; autoWidthCount--; } }); // Recalculate width again autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent); autoWidth = Math.max(autoWidth, 0); var widthSum = 0; var lastColumn; zrUtil.each(stacks, function (column, idx) { if (!column.width) { column.width = autoWidth; } lastColumn = column; widthSum += column.width * (1 + barGapPercent); }); if (lastColumn) { widthSum -= lastColumn.width * barGapPercent; } var offset = -widthSum / 2; zrUtil.each(stacks, function (column, stackId) { result[coordSysName][stackId] = result[coordSysName][stackId] || { offset: offset, width: column.width }; offset += column.width * (1 + barGapPercent); }); }); return result; } /** * @param {string} seriesType * @param {module:echarts/model/Global} ecModel * @param {module:echarts/ExtensionAPI} api */ function barLayoutGrid(seriesType, ecModel, api) { var barWidthAndOffset = calBarWidthAndOffset( zrUtil.filter( ecModel.getSeriesByType(seriesType), function (seriesModel) { return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d'; } ) ); var lastStackCoords = {}; var lastStackCoordsOrigin = {}; ecModel.eachSeriesByType(seriesType, function (seriesModel) { // Check series coordinate, do layout for cartesian2d only if (seriesModel.coordinateSystem.type !== 'cartesian2d') { return; } var data = seriesModel.getData(); var cartesian = seriesModel.coordinateSystem; var baseAxis = cartesian.getBaseAxis(); var stackId = getSeriesStackId(seriesModel); var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId]; var columnOffset = columnLayoutInfo.offset; var columnWidth = columnLayoutInfo.width; var valueAxis = cartesian.getOtherAxis(baseAxis); var barMinHeight = seriesModel.get('barMinHeight') || 0; var valueAxisStart = baseAxis.onZero ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)) : valueAxis.getGlobalExtent()[0]; var coordDims = [ seriesModel.coordDimToDataDim('x')[0], seriesModel.coordDimToDataDim('y')[0] ]; var coords = data.mapArray(coordDims, function (x, y) { return cartesian.dataToPoint([x, y]); }, true); lastStackCoords[stackId] = lastStackCoords[stackId] || []; lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243 data.setLayout({ offset: columnOffset, size: columnWidth }); data.each(seriesModel.coordDimToDataDim(valueAxis.dim)[0], function (value, idx) { if (isNaN(value)) { return; } if (!lastStackCoords[stackId][idx]) { lastStackCoords[stackId][idx] = { p: valueAxisStart, // Positive stack n: valueAxisStart // Negative stack }; lastStackCoordsOrigin[stackId][idx] = { p: valueAxisStart, // Positive stack n: valueAxisStart // Negative stack }; } var sign = value >= 0 ? 'p' : 'n'; var coord = coords[idx]; var lastCoord = lastStackCoords[stackId][idx][sign]; var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign]; var x; var y; var width; var height; if (valueAxis.isHorizontal()) { x = lastCoord; y = coord[1] + columnOffset; width = coord[0] - lastCoordOrigin; height = columnWidth; lastStackCoordsOrigin[stackId][idx][sign] += width; if (Math.abs(width) < barMinHeight) { width = (width < 0 ? -1 : 1) * barMinHeight; } lastStackCoords[stackId][idx][sign] += width; } else { x = coord[0] + columnOffset; y = lastCoord; width = columnWidth; height = coord[1] - lastCoordOrigin; lastStackCoordsOrigin[stackId][idx][sign] += height; if (Math.abs(height) < barMinHeight) { // Include zero to has a positive bar height = (height 0 // Default expansion animation && animationType !== 'scale' ) { var shape = data.getItemLayout(0); var r = Math.max(api.getWidth(), api.getHeight()) / 2; var removeClipPath = zrUtil.bind(group.removeClipPath, group); group.setClipPath(this._createClipPath( shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel )); } this._data = data; }, dispose: function () {}, _createClipPath: function ( cx, cy, r, startAngle, clockwise, cb, seriesModel ) { var clipPath = new graphic.Sector({ shape: { cx: cx, cy: cy, r0: 0, r: r, startAngle: startAngle, endAngle: startAngle, clockwise: clockwise } }); graphic.initProps(clipPath, { shape: { endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2 } }, seriesModel, cb); return clipPath; }, /** * @implement */ containPoint: function (point, seriesModel) { var data = seriesModel.getData(); var itemLayout = data.getItemLayout(0); if (itemLayout) { var dx = point[0] - itemLayout.cx; var dy = point[1] - itemLayout.cy; var radius = Math.sqrt(dx * dx + dy * dy); return radius = itemLayout.r0; } } }); module.exports = Pie; /***/ }), /* 153 */ /***/ (function(module, exports, __webpack_require__) { var echarts = __webpack_require__(1); var zrUtil = __webpack_require__(4); module.exports = function (seriesType, actionInfos) { zrUtil.each(actionInfos, function (actionInfo) { actionInfo.update = 'updateView'; /** * @payload * @property {string} seriesName * @property {string} name */ echarts.registerAction(actionInfo, function (payload, ecModel) { var selected = {}; ecModel.eachComponent( {mainType: 'series', subType: seriesType, query: payload}, function (seriesModel) { if (seriesModel[actionInfo.method]) { seriesModel[actionInfo.method]( payload.name, payload.dataIndex ); } var data = seriesModel.getData(); // Create selected map data.each(function (idx) { var name = data.getName(idx); selected[name] = seriesModel.isSelected(name) || false; }); } ); return { name: payload.name, selected: selected }; }); }); }; /***/ }), /* 154 */ /***/ (function(module, exports) { // Pick color from palette for each data item. // Applicable for charts that require applying color palette // in data level (like pie, funnel, chord). module.exports = function (seriesType, ecModel) { // Pie and funnel may use diferrent scope var paletteScope = {}; ecModel.eachRawSeriesByType(seriesType, function (seriesModel) { var dataAll = seriesModel.getRawData(); var idxMap = {}; if (!ecModel.isSeriesFiltered(seriesModel)) { var data = seriesModel.getData(); data.each(function (idx) { var rawIdx = data.getRawIndex(idx); idxMap[rawIdx] = idx; }); dataAll.each(function (rawIdx) { var filteredIdx = idxMap[rawIdx]; // If series.itemStyle.normal.color is a function. itemVisual may be encoded var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, 'color', true); if (!singleDataColor) { // FIXME Performance var itemModel = dataAll.getItemModel(rawIdx); var color = itemModel.get('itemStyle.normal.color') || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope); // Legend may use the visual info in data before processed dataAll.setItemVisual(rawIdx, 'color', color); // Data is not filtered if (filteredIdx != null) { data.setItemVisual(filteredIdx, 'color', color); } } else { // Set data all color for legend dataAll.setItemVisual(rawIdx, 'color', singleDataColor); } }); } }); }; /***/ }), /* 155 */ /***/ (function(module, exports, __webpack_require__) { var numberUtil = __webpack_require__(7); var parsePercent = numberUtil.parsePercent; var labelLayout = __webpack_require__(156); var zrUtil = __webpack_require__(4); var PI2 = Math.PI * 2; var RADIAN = Math.PI / 180; module.exports = function (seriesType, ecModel, api, payload) { ecModel.eachSeriesByType(seriesType, function (seriesModel) { var center = seriesModel.get('center'); var radius = seriesModel.get('radius'); if (!zrUtil.isArray(radius)) { radius = [0, radius]; } if (!zrUtil.isArray(center)) { center = [center, center]; } var width = api.getWidth(); var height = api.getHeight(); var size = Math.min(width, height); var cx = parsePercent(center[0], width); var cy = parsePercent(center[1], height); var r0 = parsePercent(radius[0], size / 2); var r = parsePercent(radius[1], size / 2); var data = seriesModel.getData(); var startAngle = -seriesModel.get('startAngle') * RADIAN; var minAngle = seriesModel.get('minAngle') * RADIAN; var validDataCount = 0; data.each('value', function (value) { !isNaN(value) && validDataCount++; }); var sum = data.getSum('value'); // Sum may be 0 var unitRadian = Math.PI / (sum || validDataCount) * 2; var clockwise = seriesModel.get('clockwise'); var roseType = seriesModel.get('roseType'); var stillShowZeroSum = seriesModel.get('stillShowZeroSum'); // [0...max] var extent = data.getDataExtent('value'); extent[0] = 0; // In the case some sector angle is smaller than minAngle var restAngle = PI2; var valueSumLargerThanMinAngle = 0; var currentAngle = startAngle; var dir = clockwise ? 1 : -1; data.each('value', function (value, idx) { var angle; if (isNaN(value)) { data.setItemLayout(idx, { angle: NaN, startAngle: NaN, endAngle: NaN, clockwise: clockwise, cx: cx, cy: cy, r0: r0, r: roseType ? NaN : r }); return; } // FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？ if (roseType !== 'area') { angle = (sum === 0 && stillShowZeroSum) ? unitRadian : (value * unitRadian); } else { angle = PI2 / validDataCount; } if (angle < minAngle) { angle = minAngle; restAngle -= minAngle; } else { valueSumLargerThanMinAngle += value; } var endAngle = currentAngle + dir * angle; data.setItemLayout(idx, { angle: angle, startAngle: currentAngle, endAngle: endAngle, clockwise: clockwise, cx: cx, cy: cy, r0: r0, r: roseType ? numberUtil.linearMap(value, extent, [r0, r]) : r }); currentAngle = endAngle; }, true); // Some sector is constrained by minAngle // Rest sectors needs recalculate angle if (restAngle < PI2 && validDataCount) { // Average the angle if rest angle is not enough after all angles is // Constrained by minAngle if (restAngle list[j].y + list[j].height ) { shiftUp(j, delta / 2); return; } } shiftUp(end - 1, delta / 2); } // 弹 function shiftUp(end, delta) { for (var j = end; j >= 0; j--) { list[j].y -= delta; if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height ) { break; } } } function changeX(list, isDownList, cx, cy, r, dir) { var lastDeltaX = dir > 0 ? isDownList // 右侧 ? Number.MAX_VALUE // 下 : 0 // 上 : isDownList // 左侧 ? Number.MAX_VALUE // 下 : 0; // 上 for (var i = 0, l = list.length; i < l; i++) { // Not change x for center label if (list[i].position === 'center') { continue; } var deltaY = Math.abs(list[i].y - cy); var length = list[i].len; var length2 = list[i].len2; var deltaX = (deltaY < r + length) ? Math.sqrt( (r + length + length2) * (r + length + length2) - deltaY * deltaY ) : Math.abs(list[i].x - cx); if (isDownList && deltaX >= lastDeltaX) { // 右下，左下 deltaX = lastDeltaX - 10; } if (!isDownList && deltaX 0 ? 'left' : 'right'); } var font = labelModel.getFont(); var labelRotate = labelModel.get('rotate') ? (dx < 0 ? -midAngle + Math.PI : -midAngle) : 0; var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx); var textRect = textContain.getBoundingRect( text, font, textAlign, 'top' ); hasLabelRotate = !!labelRotate; layout.label = { x: textX, y: textY, position: labelPosition, height: textRect.height, len: labelLineLen, len2: labelLineLen2, linePoints: linePoints, textAlign: textAlign, verticalAlign: 'middle', rotation: labelRotate, inside: isLabelInside }; // Not layout the inside label if (!isLabelInside) { labelLayoutList.push(layout.label); } }); if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) { avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight); } }; /***/ }), /* 157 */ /***/ (function(module, exports) { module.exports = function (seriesType, ecModel) { var legendModels = ecModel.findComponents({ mainType: 'legend' }); if (!legendModels || !legendModels.length) { return; } ecModel.eachSeriesByType(seriesType, function (series) { var data = series.getData(); data.filterSelf(function (idx) { var name = data.getName(idx); // If in any legend component the status is not selected. for (var i = 0; i < legendModels.length; i++) { if (!legendModels[i].isSelected(name)) { return false; } } return true; }, this); }, this); }; /***/ }), /* 158 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); var echarts = __webpack_require__(1); __webpack_require__(159); __webpack_require__(160); echarts.registerVisual(zrUtil.curry( __webpack_require__(124), 'scatter', 'circle', null )); echarts.registerLayout(zrUtil.curry( __webpack_require__(125), 'scatter' )); // In case developer forget to include grid component __webpack_require__(127); /***/ }), /* 159 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var createListFromArray = __webpack_require__(112); var SeriesModel = __webpack_require__(83); module.exports = SeriesModel.extend({ type: 'series.scatter', dependencies: ['grid', 'polar', 'geo', 'singleAxis', 'calendar'], getInitialData: function (option, ecModel) { return createListFromArray(option.data, this, ecModel); }, brushSelector: 'point', defaultOption: { coordinateSystem: 'cartesian2d', zlevel: 0, z: 2, legendHoverLink: true, hoverAnimation: true, // Cartesian coordinate system // xAxisIndex: 0, // yAxisIndex: 0, // Polar coordinate system // polarIndex: 0, // Geo coordinate system // geoIndex: 0, // symbol: null, // 图形类型 symbolSize: 10, // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2 // symbolRotate: null, // 图形旋转控制 large: false, // Available when large is true largeThreshold: 2000, // cursor: null, // label: { // normal: { // show: false // distance: 5, // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调 // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // 默认使用全局文本样式，详见TEXTSTYLE // } // }, itemStyle: { normal: { opacity: 0.8 // color: 各异 } } } }); /***/ }), /* 160 */ /***/ (function(module, exports, __webpack_require__) { var SymbolDraw = __webpack_require__(119); var LargeSymbolDraw = __webpack_require__(161); __webpack_require__(1).extendChartView({ type: 'scatter', init: function () { this._normalSymbolDraw = new SymbolDraw(); this._largeSymbolDraw = new LargeSymbolDraw(); }, render: function (seriesModel, ecModel, api) { var data = seriesModel.getData(); var largeSymbolDraw = this._largeSymbolDraw; var normalSymbolDraw = this._normalSymbolDraw; var group = this.group; var symbolDraw = seriesModel.get('large') && data.count() > seriesModel.get('largeThreshold') ? largeSymbolDraw : normalSymbolDraw; this._symbolDraw = symbolDraw; symbolDraw.updateData(data); group.add(symbolDraw.group); group.remove( symbolDraw === largeSymbolDraw ? normalSymbolDraw.group : largeSymbolDraw.group ); }, updateLayout: function (seriesModel) { this._symbolDraw.updateLayout(seriesModel); }, remove: function (ecModel, api) { this._symbolDraw && this._symbolDraw.remove(api, true); }, dispose: function () {} }); /***/ }), /* 161 */ /***/ (function(module, exports, __webpack_require__) { // TODO Batch by color var graphic = __webpack_require__(20); var symbolUtil = __webpack_require__(114); var LargeSymbolPath = graphic.extendShape({ shape: { points: null, sizes: null }, symbolProxy: null, buildPath: function (path, shape) { var points = shape.points; var sizes = shape.sizes; var symbolProxy = this.symbolProxy; var symbolProxyShape = symbolProxy.shape; for (var i = 0; i < points.length; i++) { var pt = points[i]; if (isNaN(pt[0]) || isNaN(pt[1])) { continue; } var size = sizes[i]; if (size[0] < 4) { // Optimize for small symbol path.rect( pt[0] - size[0] / 2, pt[1] - size[1] / 2, size[0], size[1] ); } else { symbolProxyShape.x = pt[0] - size[0] / 2; symbolProxyShape.y = pt[1] - size[1] / 2; symbolProxyShape.width = size[0]; symbolProxyShape.height = size[1]; symbolProxy.buildPath(path, symbolProxyShape, true); } } }, findDataIndex: function (x, y) { var shape = this.shape; var points = shape.points; var sizes = shape.sizes; // Not consider transform // Treat each element as a rect // top down traverse for (var i = points.length - 1; i >= 0; i--) { var pt = points[i]; var size = sizes[i]; var x0 = pt[0] - size[0] / 2; var y0 = pt[1] - size[1] / 2; if (x >= x0 && y >= y0 && x rawExtent[0] && isFinite(min) && isFinite(rawExtent[0])); } else { var nicedSplitNumber = scale.getTicks().length - 1; if (nicedSplitNumber > splitNumber) { interval = increaseInterval(interval); } // PENDING var center = Math.round((rawExtent[0] + rawExtent[1]) / 2 / interval) * interval; var halfSplitNumber = Math.round(splitNumber / 2); scale.setExtent( numberUtil.round(center - halfSplitNumber * interval), numberUtil.round(center + (splitNumber - halfSplitNumber) * interval) ); scale.setInterval(interval); } }); }; /** * Radar dimensions is based on the data * @type {Array} */ Radar.dimensions = []; Radar.create = function (ecModel, api) { var radarList = []; ecModel.eachComponent('radar', function (radarModel) { var radar = new Radar(radarModel, ecModel, api); radarList.push(radar); radarModel.coordinateSystem = radar; }); ecModel.eachSeriesByType('radar', function (radarSeries) { if (radarSeries.get('coordinateSystem') === 'radar') { // Inject coordinate system radarSeries.coordinateSystem = radarList[radarSeries.get('radarIndex') || 0]; } }); return radarList; }; __webpack_require__(79).register('radar', Radar); module.exports = Radar; /***/ }), /* 165 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); var Axis = __webpack_require__(103); function IndicatorAxis(dim, scale, radiusExtent) { Axis.call(this, dim, scale, radiusExtent); /** * Axis type * - 'category' * - 'value' * - 'time' * - 'log' * @type {string} */ this.type = 'value'; this.angle = 0; /** * Indicator name * @type {string} */ this.name = ''; /** * @type {module:echarts/model/Model} */ this.model; } zrUtil.inherits(IndicatorAxis, Axis); module.exports = IndicatorAxis; /***/ }), /* 166 */ /***/ (function(module, exports, __webpack_require__) { var axisDefault = __webpack_require__(135); var valueAxisDefault = axisDefault.valueAxis; var Model = __webpack_require__(14); var zrUtil = __webpack_require__(4); var axisModelCommonMixin = __webpack_require__(115); function defaultsShow(opt, show) { return zrUtil.defaults({ show: show }, opt); } var RadarModel = __webpack_require__(1).extendComponentModel({ type: 'radar', optionUpdated: function () { var boundaryGap = this.get('boundaryGap'); var splitNumber = this.get('splitNumber'); var scale = this.get('scale'); var axisLine = this.get('axisLine'); var axisTick = this.get('axisTick'); var axisLabel = this.get('axisLabel'); var nameTextStyle = this.get('name'); var showName = this.get('name.show'); var nameFormatter = this.get('name.formatter'); var nameGap = this.get('nameGap'); var triggerEvent = this.get('triggerEvent'); var indicatorModels = zrUtil.map(this.get('indicator') || [], function (indicatorOpt) { // PENDING if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) { indicatorOpt.min = 0; } else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) { indicatorOpt.max = 0; } var iNameTextStyle = nameTextStyle; if(indicatorOpt.color != null) { iNameTextStyle = zrUtil.defaults({color: indicatorOpt.color}, nameTextStyle); } // Use same configuration indicatorOpt = zrUtil.merge(zrUtil.clone(indicatorOpt), { boundaryGap: boundaryGap, splitNumber: splitNumber, scale: scale, axisLine: axisLine, axisTick: axisTick, axisLabel: axisLabel, // Competitable with 2 and use text name: indicatorOpt.text, nameLocation: 'end', nameGap: nameGap, // min: 0, nameTextStyle: iNameTextStyle, triggerEvent: triggerEvent }, false); if (!showName) { indicatorOpt.name = ''; } if (typeof nameFormatter === 'string') { var indName = indicatorOpt.name; indicatorOpt.name = nameFormatter.replace('{value}', indName != null ? indName : ''); } else if (typeof nameFormatter === 'function') { indicatorOpt.name = nameFormatter( indicatorOpt.name, indicatorOpt ); } var model = zrUtil.extend( new Model(indicatorOpt, null, this.ecModel), axisModelCommonMixin ); // For triggerEvent. model.mainType = 'radar'; model.componentIndex = this.componentIndex; return model; }, this); this.getIndicatorModels = function () { return indicatorModels; }; }, defaultOption: { zlevel: 0, z: 0, center: ['50%', '50%'], radius: '75%', startAngle: 90, name: { show: true // formatter: null // textStyle: {} }, boundaryGap: [0, 0], splitNumber: 5, nameGap: 15, scale: false, // Polygon or circle shape: 'polygon', axisLine: zrUtil.merge( { lineStyle: { color: '#bbb' } }, valueAxisDefault.axisLine ), axisLabel: defaultsShow(valueAxisDefault.axisLabel, false), axisTick: defaultsShow(valueAxisDefault.axisTick, false), splitLine: defaultsShow(valueAxisDefault.splitLine, true), splitArea: defaultsShow(valueAxisDefault.splitArea, true), // {text, min, max} indicator: [] } }); module.exports = RadarModel; /***/ }), /* 167 */ /***/ (function(module, exports, __webpack_require__) { var AxisBuilder = __webpack_require__(138); var zrUtil = __webpack_require__(4); var graphic = __webpack_require__(20); var axisBuilderAttrs = [ 'axisLine', 'axisTickLabel', 'axisName' ]; module.exports = __webpack_require__(1).extendComponentView({ type: 'radar', render: function (radarModel, ecModel, api) { var group = this.group; group.removeAll(); this._buildAxes(radarModel); this._buildSplitLineAndArea(radarModel); }, _buildAxes: function (radarModel) { var radar = radarModel.coordinateSystem; var indicatorAxes = radar.getIndicatorAxes(); var axisBuilders = zrUtil.map(indicatorAxes, function (indicatorAxis) { var axisBuilder = new AxisBuilder(indicatorAxis.model, { position: [radar.cx, radar.cy], rotation: indicatorAxis.angle, labelDirection: -1, tickDirection: -1, nameDirection: 1 }); return axisBuilder; }); zrUtil.each(axisBuilders, function (axisBuilder) { zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder); this.group.add(axisBuilder.getGroup()); }, this); }, _buildSplitLineAndArea: function (radarModel) { var radar = radarModel.coordinateSystem; var indicatorAxes = radar.getIndicatorAxes(); if (!indicatorAxes.length) { return; } var shape = radarModel.get('shape'); var splitLineModel = radarModel.getModel('splitLine'); var splitAreaModel = radarModel.getModel('splitArea'); var lineStyleModel = splitLineModel.getModel('lineStyle'); var areaStyleModel = splitAreaModel.getModel('areaStyle'); var showSplitLine = splitLineModel.get('show'); var showSplitArea = splitAreaModel.get('show'); var splitLineColors = lineStyleModel.get('color'); var splitAreaColors = areaStyleModel.get('color'); splitLineColors = zrUtil.isArray(splitLineColors) ? splitLineColors : [splitLineColors]; splitAreaColors = zrUtil.isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors]; var splitLines = []; var splitAreas = []; function getColorIndex(areaOrLine, areaOrLineColorList, idx) { var colorIndex = idx % areaOrLineColorList.length; areaOrLine[colorIndex] = areaOrLine[colorIndex] || []; return colorIndex; } if (shape === 'circle') { var ticksRadius = indicatorAxes[0].getTicksCoords(); var cx = radar.cx; var cy = radar.cy; for (var i = 0; i < ticksRadius.length; i++) { if (showSplitLine) { var colorIndex = getColorIndex(splitLines, splitLineColors, i); splitLines[colorIndex].push(new graphic.Circle({ shape: { cx: cx, cy: cy, r: ticksRadius[i] } })); } if (showSplitArea && i < ticksRadius.length - 1) { var colorIndex = getColorIndex(splitAreas, splitAreaColors, i); splitAreas[colorIndex].push(new graphic.Ring({ shape: { cx: cx, cy: cy, r0: ticksRadius[i], r: ticksRadius[i + 1] } })); } } } // Polyyon else { var realSplitNumber; var axesTicksPoints = zrUtil.map(indicatorAxes, function (indicatorAxis, idx) { var ticksCoords = indicatorAxis.getTicksCoords(); realSplitNumber = realSplitNumber == null ? ticksCoords.length - 1 : Math.min(ticksCoords.length - 1, realSplitNumber); return zrUtil.map(ticksCoords, function (tickCoord) { return radar.coordToPoint(tickCoord, idx); }); }); var prevPoints = []; for (var i = 0; i > 1) ^ (-(x & 1)); y = (y >> 1) ^ (-(y & 1)); // Delta deocding x += prevX; y += prevY; prevX = x; prevY = y; // Dequantize result.push([x / encodeScale, y / encodeScale]); } return result; } /** * @alias module:echarts/coord/geo/parseGeoJson * @param {Object} geoJson * @return {module:zrender/container/Group} */ module.exports = function (geoJson) { decode(geoJson); return zrUtil.map(zrUtil.filter(geoJson.features, function (featureObj) { // Output of mapshaper may have geometry null return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0; }), function (featureObj) { var properties = featureObj.properties; var geo = featureObj.geometry; var coordinates = geo.coordinates; var geometries = []; if (geo.type === 'Polygon') { geometries.push({ type: 'polygon', // According to the GeoJSON specification. // First must be exterior, and the rest are all interior(holes). exterior: coordinates[0], interiors: coordinates.slice(1) }); } if (geo.type === 'MultiPolygon') { zrUtil.each(coordinates, function (item) { if (item[0]) { geometries.push({ type: 'polygon', exterior: item[0], interiors: item.slice(1) }); } }); } var region = new Region( properties.name, geometries, properties.cp ); region.properties = properties; return region; }); }; /***/ }), /* 177 */ /***/ (function(module, exports, __webpack_require__) { /** * @module echarts/coord/geo/Region */ var polygonContain = __webpack_require__(178); var BoundingRect = __webpack_require__(9); var bbox = __webpack_require__(41); var vec2 = __webpack_require__(10); /** * @param {string} name * @param {Array} geometries * @param {Array.} cp */ function Region(name, geometries, cp) { /** * @type {string} * @readOnly */ this.name = name; /** * @type {Array.} * @readOnly */ this.geometries = geometries; if (!cp) { var rect = this.getBoundingRect(); cp = [ rect.x + rect.width / 2, rect.y + rect.height / 2 ]; } else { cp = [cp[0], cp[1]]; } /** * @type {Array.} */ this.center = cp; } Region.prototype = { constructor: Region, properties: null, /** * @return {module:zrender/core/BoundingRect} */ getBoundingRect: function () { var rect = this._rect; if (rect) { return rect; } var MAX_NUMBER = Number.MAX_VALUE; var min = [MAX_NUMBER, MAX_NUMBER]; var max = [-MAX_NUMBER, -MAX_NUMBER]; var min2 = []; var max2 = []; var geometries = this.geometries; for (var i = 0; i < geometries.length; i++) { // Only support polygon if (geometries[i].type !== 'polygon') { continue; } // Doesn't consider hole var exterior = geometries[i].exterior; bbox.fromPoints(exterior, min2, max2); vec2.min(min, min, min2); vec2.max(max, max, max2); } // No data if (i === 0) { min[0] = min[1] = max[0] = max[1] = 0; } return (this._rect = new BoundingRect( min[0], min[1], max[0] - min[0], max[1] - min[1] )); }, /** * @param { 0 ? 1.1 : 1 / 1.1; zoom.call(this, e, zoomDelta, e.offsetX, e.offsetY); } function pinch(e) { if (interactionMutex.isTaken(this._zr, 'globalPan')) { return; } var zoomDelta = e.pinchScale > 1 ? 1.1 : 1 / 1.1; zoom.call(this, e, zoomDelta, e.pinchX, e.pinchY); } function zoom(e, zoomDelta, zoomX, zoomY) { if (this.pointerChecker && this.pointerChecker(e, zoomX, zoomY)) { // When mouse is out of roamController rect, // default befavoius should not be be disabled, otherwise // page sliding is disabled, contrary to expectation. eventTool.stop(e.event); this.trigger('zoom', zoomDelta, zoomX, zoomY); } } function checkKeyBinding(roamController, prop, e) { var setting = roamController._opt[prop]; return setting && (!zrUtil.isString(setting) || e.event[setting + 'Key']); } module.exports = RoamController; /***/ }), /* 187 */ /***/ (function(module, exports, __webpack_require__) { var ATTR = '\\0_ec_interaction_mutex'; var interactionMutex = { take: function (zr, resourceKey, userKey) { var store = getStore(zr); store[resourceKey] = userKey; }, release: function (zr, resourceKey, userKey) { var store = getStore(zr); var uKey = store[resourceKey]; if (uKey === userKey) { store[resourceKey] = null; } }, isTaken: function (zr, resourceKey) { return !!getStore(zr)[resourceKey]; } }; function getStore(zr) { return zr[ATTR] || (zr[ATTR] = {}); } /** * payload: { * type: 'takeGlobalCursor', * key: 'dataZoomSelect', or 'brush', or ..., * If no userKey, release global cursor. * } */ __webpack_require__(1).registerAction( {type: 'takeGlobalCursor', event: 'globalCursorTaken', update: 'update'}, function () {} ); module.exports = interactionMutex; /***/ }), /* 188 */ /***/ (function(module, exports) { var helper = {}; /** * For geo and graph. * * @param {Object} controllerHost * @param {module:zrender/Element} controllerHost.target */ helper.updateViewOnPan = function (controllerHost, dx, dy) { var target = controllerHost.target; var pos = target.position; pos[0] += dx; pos[1] += dy; target.dirty(); }; /** * For geo and graph. * * @param {Object} controllerHost * @param {module:zrender/Element} controllerHost.target * @param {number} controllerHost.zoom * @param {number} controllerHost.zoomLimit like: {min: 1, max: 2} */ helper.updateViewOnZoom = function (controllerHost, zoomDelta, zoomX, zoomY) { var target = controllerHost.target; var zoomLimit = controllerHost.zoomLimit; var pos = target.position; var scale = target.scale; var newZoom = controllerHost.zoom = controllerHost.zoom || 1; newZoom *= zoomDelta; if (zoomLimit) { var zoomMin = zoomLimit.min || 0; var zoomMax = zoomLimit.max || Infinity; newZoom = Math.max( Math.min(zoomMax, newZoom), zoomMin ); } var zoomScale = newZoom / controllerHost.zoom; controllerHost.zoom = newZoom; // Keep the mouse center when scaling pos[0] -= (zoomX - pos[0]) * (zoomScale - 1); pos[1] -= (zoomY - pos[1]) * (zoomScale - 1); scale[0] *= zoomScale; scale[1] *= zoomScale; target.dirty(); }; module.exports = helper; /***/ }), /* 189 */ /***/ (function(module, exports) { var helper = {}; var IRRELEVANT_EXCLUDES = {'axisPointer': 1, 'tooltip': 1, 'brush': 1}; /** * Avoid that: mouse click on a elements that is over geo or graph, * but roam is triggered. */ helper.onIrrelevantElement = function (e, api, targetCoordSysModel) { var model = api.getComponentByElement(e.topTarget); // If model is axisModel, it works only if it is injected with coordinateSystem. var coordSys = model && model.coordinateSystem; return model && model !== targetCoordSysModel && !IRRELEVANT_EXCLUDES[model.mainType] && (coordSys && coordSys.model !== targetCoordSysModel); }; module.exports = helper; /***/ }), /* 190 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); var roamHelper = __webpack_require__(191); var echarts = __webpack_require__(1); /** * @payload * @property {string} [componentType=series] * @property {number} [dx] * @property {number} [dy] * @property {number} [zoom] * @property {number} [originX] * @property {number} [originY] */ echarts.registerAction({ type: 'geoRoam', event: 'geoRoam', update: 'updateLayout' }, function (payload, ecModel) { var componentType = payload.componentType || 'series'; ecModel.eachComponent( { mainType: componentType, query: payload }, function (componentModel) { var geo = componentModel.coordinateSystem; if (geo.type !== 'geo') { return; } var res = roamHelper.updateCenterAndZoom( geo, payload, componentModel.get('scaleLimit') ); componentModel.setCenter && componentModel.setCenter(res.center); componentModel.setZoom && componentModel.setZoom(res.zoom); // All map series with same `map` use the same geo coordinate system // So the center and zoom must be in sync. Include the series not selected by legend if (componentType === 'series') { zrUtil.each(componentModel.seriesGroup, function (seriesModel) { seriesModel.setCenter(res.center); seriesModel.setZoom(res.zoom); }); } } ); }); /***/ }), /* 191 */ /***/ (function(module, exports) { var roamHelper = {}; /** * @param {module:echarts/coord/View} view * @param {Object} payload * @param {Object} [zoomLimit] */ roamHelper.updateCenterAndZoom = function ( view, payload, zoomLimit ) { var previousZoom = view.getZoom(); var center = view.getCenter(); var zoom = payload.zoom; var point = view.dataToPoint(center); if (payload.dx != null && payload.dy != null) { point[0] -= payload.dx; point[1] -= payload.dy; var center = view.pointToData(point); view.setCenter(center); } if (zoom != null) { if (zoomLimit) { var zoomMin = zoomLimit.min || 0; var zoomMax = zoomLimit.max || Infinity; zoom = Math.max( Math.min(previousZoom * zoom, zoomMax), zoomMin ) / previousZoom; } // Zoom on given point(originX, originY) view.scale[0] *= zoom; view.scale[1] *= zoom; var position = view.position; var fixX = (payload.originX - position[0]) * (zoom - 1); var fixY = (payload.originY - position[1]) * (zoom - 1); position[0] -= fixX; position[1] -= fixY; view.updateTransform(); // Get the new center var center = view.pointToData(point); view.setCenter(center); view.setZoom(zoom * previousZoom); } return { center: view.getCenter(), zoom: view.getZoom() }; }; module.exports = roamHelper; /***/ }), /* 192 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); module.exports = function (ecModel) { var processedMapType = {}; ecModel.eachSeriesByType('map', function (mapSeries) { var mapType = mapSeries.getMapType(); if (mapSeries.getHostGeoModel() || processedMapType[mapType]) { return; } var mapSymbolOffsets = {}; zrUtil.each(mapSeries.seriesGroup, function (subMapSeries) { var geo = subMapSeries.coordinateSystem; var data = subMapSeries.originalData; if (subMapSeries.get('showLegendSymbol') && ecModel.getComponent('legend')) { data.each('value', function (value, idx) { var name = data.getName(idx); var region = geo.getRegion(name); // If input series.data is [11, 22, '-'/null/undefined, 44], // it will be filled with NaN: [11, 22, NaN, 44] and NaN will // not be drawn. So here must validate if value is NaN. if (!region || isNaN(value)) { return; } var offset = mapSymbolOffsets[name] || 0; var point = geo.dataToPoint(region.center); mapSymbolOffsets[name] = offset + 1; data.setItemLayout(idx, { point: point, offset: offset }); }); } }); // Show label of those region not has legendSymbol(which is offset 0) var data = mapSeries.getData(); data.each(function (idx) { var name = data.getName(idx); var layout = data.getItemLayout(idx) || {}; layout.showLabel = !mapSymbolOffsets[name]; data.setItemLayout(idx, layout); }); processedMapType[mapType] = true; }); }; /***/ }), /* 193 */ /***/ (function(module, exports) { module.exports = function (ecModel) { ecModel.eachSeriesByType('map', function (seriesModel) { var colorList = seriesModel.get('color'); var itemStyleModel = seriesModel.getModel('itemStyle.normal'); var areaColor = itemStyleModel.get('areaColor'); var color = itemStyleModel.get('color') || colorList[seriesModel.seriesIndex % colorList.length]; seriesModel.getData().setVisual({ 'areaColor': areaColor, 'color': color }); }); }; /***/ }), /* 194 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); // FIXME 公用？ /** * @param {Array.} datas * @param {string} statisticType 'average' 'sum' * @inner */ function dataStatistics(datas, statisticType) { var dataNameMap = {}; var dims = ['value']; zrUtil.each(datas, function (data) { data.each(dims, function (value, idx) { // Add prefix to avoid conflict with Object.prototype. var mapKey = 'ec-' + data.getName(idx); dataNameMap[mapKey] = dataNameMap[mapKey] || []; if (!isNaN(value)) { dataNameMap[mapKey].push(value); } }); }); return datas[0].map(dims, function (value, idx) { var mapKey = 'ec-' + datas[0].getName(idx); var sum = 0; var min = Infinity; var max = -Infinity; var len = dataNameMap[mapKey].length; for (var i = 0; i < len; i++) { min = Math.min(min, dataNameMap[mapKey][i]); max = Math.max(max, dataNameMap[mapKey][i]); sum += dataNameMap[mapKey][i]; } var result; if (statisticType === 'min') { result = min; } else if (statisticType === 'max') { result = max; } else if (statisticType === 'average') { result = sum / len; } else { result = sum; } return len === 0 ? NaN : result; }); } module.exports = function (ecModel) { var seriesGroups = {}; ecModel.eachSeriesByType('map', function (seriesModel) { var hostGeoModel = seriesModel.getHostGeoModel(); var key = hostGeoModel ? 'o' + hostGeoModel.id : 'i' + seriesModel.getMapType(); (seriesGroups[key] = seriesGroups[key] || []).push(seriesModel); }); zrUtil.each(seriesGroups, function (seriesList, key) { var data = dataStatistics( zrUtil.map(seriesList, function (seriesModel) { return seriesModel.getData(); }), seriesList[0].get('mapValueCalculation') ); for (var i = 0; i < seriesList.length; i++) { seriesList[i].originalData = seriesList[i].getData(); } // FIXME Put where? for (var i = 0; i < seriesList.length; i++) { seriesList[i].seriesGroup = seriesList; seriesList[i].needsDrawMap = i === 0 && !seriesList[i].getHostGeoModel(); seriesList[i].setData(data.cloneShallow()); seriesList[i].mainSeries = seriesList[0]; } }); }; /***/ }), /* 195 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); module.exports = function (option) { // Save geoCoord var mapSeries = []; zrUtil.each(option.series, function (seriesOpt) { if (seriesOpt.type === 'map') { mapSeries.push(seriesOpt); } }); zrUtil.each(mapSeries, function (seriesOpt) { seriesOpt.map = seriesOpt.map || seriesOpt.mapType; // Put x, y, width, height, x2, y2 in the top level zrUtil.defaults(seriesOpt, seriesOpt.mapLocation); }); }; /***/ }), /* 196 */ /***/ (function(module, exports, __webpack_require__) { var echarts = __webpack_require__(1); __webpack_require__(197); __webpack_require__(201); __webpack_require__(204); echarts.registerVisual(__webpack_require__(205)); echarts.registerLayout(__webpack_require__(207)); /***/ }), /* 197 */ /***/ (function(module, exports, __webpack_require__) { var SeriesModel = __webpack_require__(83); var Tree = __webpack_require__(198); var zrUtil = __webpack_require__(4); var Model = __webpack_require__(14); var formatUtil = __webpack_require__(6); var helper = __webpack_require__(200); var encodeHTML = formatUtil.encodeHTML; var addCommas = formatUtil.addCommas; module.exports = SeriesModel.extend({ type: 'series.treemap', layoutMode: 'box', dependencies: ['grid', 'polar'], /** * @type {module:echarts/data/Tree~Node} */ _viewRoot: null, defaultOption: { // Disable progressive rendering progressive: 0, hoverLayerThreshold: Infinity, // center: ['50%', '50%'], // not supported in ec3. // size: ['80%', '80%'], // deprecated, compatible with ec2. left: 'center', top: 'middle', right: null, bottom: null, width: '80%', height: '80%', sort: true, // Can be null or false or true // (order by desc default, asc not supported yet (strange effect)) clipWindow: 'origin', // Size of clipped window when zooming. 'origin' or 'fullscreen' squareRatio: 0.5 * (1 + Math.sqrt(5)), // golden ratio leafDepth: null, // Nodes on depth from root are regarded as leaves. // Count from zero (zero represents only view root). drillDownIcon: '▶', // Use html character temporarily because it is complicated // to align specialized icon. ▷▶❒❐▼✚ zoomToNodeRatio: 0.32 * 0.32, // Be effective when using zoomToNode. Specify the proportion of the // target node area in the view area. roam: true, // true, false, 'scale' or 'zoom', 'move'. nodeClick: 'zoomToNode', // Leaf node click behaviour: 'zoomToNode', 'link', false. // If leafDepth is set and clicking a node which has children but // be on left depth, the behaviour would be changing root. Otherwise // use behavious defined above. animation: true, animationDurationUpdate: 900, animationEasing: 'quinticInOut', breadcrumb: { show: true, height: 22, left: 'center', top: 'bottom', // right // bottom emptyItemWidth: 25, // Width of empty node. itemStyle: { normal: { color: 'rgba(0,0,0,0.7)', //'#5793f3', borderColor: 'rgba(255,255,255,0.7)', borderWidth: 1, shadowColor: 'rgba(150,150,150,1)', shadowBlur: 3, shadowOffsetX: 0, shadowOffsetY: 0, textStyle: { color: '#fff' } }, emphasis: { textStyle: {} } } }, label: { normal: { show: true, // Do not use textDistance, for ellipsis rect just the same as treemap node rect. distance: 0, padding: 5, position: 'inside', // Can be [5, '5%'] or position stirng like 'insideTopLeft', ... // formatter: null, color: '#fff', ellipsis: true // align // verticalAlign } }, upperLabel: { // Label when node is parent. normal: { show: false, position: [0, '50%'], height: 20, // formatter: null, color: '#fff', ellipsis: true, // align: null, verticalAlign: 'middle' }, emphasis: { show: true, position: [0, '50%'], color: '#fff', ellipsis: true, verticalAlign: 'middle' } }, itemStyle: { normal: { color: null, // Can be 'none' if not necessary. colorAlpha: null, // Can be 'none' if not necessary. colorSaturation: null, // Can be 'none' if not necessary. borderWidth: 0, gapWidth: 0, borderColor: '#fff', borderColorSaturation: null // If specified, borderColor will be ineffective, and the // border color is evaluated by color of current node and // borderColorSaturation. }, emphasis: { } }, visualDimension: 0, // Can be 0, 1, 2, 3. visualMin: null, visualMax: null, color: [], // + treemapSeries.color should not be modified. Please only modified // level[n].color (if necessary). // + Specify color list of each level. level[0].color would be global // color list if not specified. (see method `setDefault`). // + But set as a empty array to forbid fetch color from global palette // when using nodeModel.get('color'), otherwise nodes on deep level // will always has color palette set and are not able to inherit color // from parent node. // + TreemapSeries.color can not be set as 'none', otherwise effect // legend color fetching (see seriesColor.js). colorAlpha: null, // Array. Specify color alpha range of each level, like [0.2, 0.8] colorSaturation: null, // Array. Specify color saturation of each level, like [0.2, 0.5] colorMappingBy: 'index', // 'value' or 'index' or 'id'. visibleMin: 10, // If area less than this threshold (unit: pixel^2), node will not // be rendered. Only works when sort is 'asc' or 'desc'. childrenVisibleMin: null, // If area of a node less than this threshold (unit: pixel^2), // grandchildren will not show. // Why grandchildren? If not grandchildren but children, // some siblings show children and some not, // the appearance may be mess and not consistent, levels: [] // Each item: { // visibleMin, itemStyle, visualDimension, label // } // data: { // value: [], // children: [], // link: 'http://xxx.xxx.xxx', // target: 'blank' or 'self' // } }, /** * @override */ getInitialData: function (option, ecModel) { // Create a virtual root. var root = {name: option.name, children: option.data}; completeTreeValue(root); var levels = option.levels || []; levels = option.levels = setDefault(levels, ecModel); // Make sure always a new tree is created when setOption, // in TreemapView, we check whether oldTree === newTree // to choose mappings approach among old shapes and new shapes. return Tree.createTree(root, this, levels).data; }, optionUpdated: function () { this.resetViewRoot(); }, /** * @override * @param {number} dataIndex * @param {boolean} [mutipleSeries=false] */ formatTooltip: function (dataIndex) { var data = this.getData(); var value = this.getRawValue(dataIndex); var formattedValue = zrUtil.isArray(value) ? addCommas(value[0]) : addCommas(value); var name = data.getName(dataIndex); return encodeHTML(name + ': ' + formattedValue); }, /** * Add tree path to tooltip param * * @override * @param {number} dataIndex * @return {Object} */ getDataParams: function (dataIndex) { var params = SeriesModel.prototype.getDataParams.apply(this, arguments); var node = this.getData().tree.getNodeByDataIndex(dataIndex); params.treePathInfo = helper.wrapTreePathInfo(node, this); return params; }, /** * @public * @param {Object} layoutInfo { * x: containerGroup x * y: containerGroup y * width: containerGroup width * height: containerGroup height * } */ setLayoutInfo: function (layoutInfo) { /** * @readOnly * @type {Object} */ this.layoutInfo = this.layoutInfo || {}; zrUtil.extend(this.layoutInfo, layoutInfo); }, /** * @param {string} id * @return {number} index */ mapIdToIndex: function (id) { // A feature is implemented: // index is monotone increasing with the sequence of // input id at the first time. // This feature can make sure that each data item and its // mapped color have the same index between data list and // color list at the beginning, which is useful for user // to adjust data-color mapping. /** * @private * @type {Object} */ var idIndexMap = this._idIndexMap; if (!idIndexMap) { idIndexMap = this._idIndexMap = zrUtil.createHashMap(); /** * @private * @type {number} */ this._idIndexMapCount = 0; } var index = idIndexMap.get(id); if (index == null) { idIndexMap.set(id, index = this._idIndexMapCount++); } return index; }, getViewRoot: function () { return this._viewRoot; }, /** * @param {module:echarts/data/Tree~Node} [viewRoot] */ resetViewRoot: function (viewRoot) { viewRoot ? (this._viewRoot = viewRoot) : (viewRoot = this._viewRoot); var root = this.getData().tree.root; if (!viewRoot || (viewRoot !== root && !root.contains(viewRoot)) ) { this._viewRoot = root; } } }); /** * @param {Object} dataNode */ function completeTreeValue(dataNode) { // Postorder travel tree. // If value of none-leaf node is not set, // calculate it by suming up the value of all children. var sum = 0; zrUtil.each(dataNode.children, function (child) { completeTreeValue(child); var childValue = child.value; zrUtil.isArray(childValue) && (childValue = childValue[0]); sum += childValue; }); var thisValue = dataNode.value; if (zrUtil.isArray(thisValue)) { thisValue = thisValue[0]; } if (thisValue == null || isNaN(thisValue)) { thisValue = sum; } // Value should not less than 0. if (thisValue < 0) { thisValue = 0; } zrUtil.isArray(dataNode.value) ? (dataNode.value[0] = thisValue) : (dataNode.value = thisValue); } /** * set default to level configuration */ function setDefault(levels, ecModel) { var globalColorList = ecModel.get('color'); if (!globalColorList) { return; } levels = levels || []; var hasColorDefine; zrUtil.each(levels, function (levelDefine) { var model = new Model(levelDefine); var modelColor = model.get('color'); if (model.get('itemStyle.normal.color') || (modelColor && modelColor !== 'none') ) { hasColorDefine = true; } }); if (!hasColorDefine) { var level0 = levels[0] || (levels[0] = {}); level0.color = globalColorList.slice(); } return levels; } /***/ }), /* 198 */ /***/ (function(module, exports, __webpack_require__) { /** * Tree data structure * * @module echarts/data/Tree */ var zrUtil = __webpack_require__(4); var Model = __webpack_require__(14); var List = __webpack_require__(101); var linkList = __webpack_require__(199); var completeDimensions = __webpack_require__(113); /** * @constructor module:echarts/data/Tree~TreeNode * @param {string} name * @param {module:echarts/data/Tree} hostTree */ var TreeNode = function (name, hostTree) { /** * @type {string} */ this.name = name || ''; /** * Depth of node * * @type {number} * @readOnly */ this.depth = 0; /** * Height of the subtree rooted at this node. * @type {number} * @readOnly */ this.height = 0; /** * @type {module:echarts/data/Tree~TreeNode} * @readOnly */ this.parentNode = null; /** * Reference to list item. * Do not persistent dataIndex outside, * besause it may be changed by list. * If dataIndex -1, * this node is logical deleted (filtered) in list. * * @type {Object} * @readOnly */ this.dataIndex = -1; /** * @type {Array.} * @readOnly */ this.children = []; /** * @type {Array.} * @pubilc */ this.viewChildren = []; /** * @type {moduel:echarts/data/Tree} * @readOnly */ this.hostTree = hostTree; }; TreeNode.prototype = { constructor: TreeNode, /** * The node is removed. * @return {boolean} is removed. */ isRemoved: function () { return this.dataIndex < 0; }, /** * Travel this subtree (include this node). * Usage: * node.eachNode(function () { ... }); // preorder * node.eachNode('preorder', function () { ... }); // preorder * node.eachNode('postorder', function () { ... }); // postorder * node.eachNode( * {order: 'postorder', attr: 'viewChildren'}, * function () { ... } * ); // postorder * * @param {(Object|string)} options If string, means order. * @param {string=} options.order 'preorder' or 'postorder' * @param {string=} options.attr 'children' or 'viewChildren' * @param {Function} cb If in preorder and return false, * its subtree will not be visited. * @param {Object} [context] */ eachNode: function (options, cb, context) { if (typeof options === 'function') { context = cb; cb = options; options = null; } options = options || {}; if (zrUtil.isString(options)) { options = {order: options}; } var order = options.order || 'preorder'; var children = this[options.attr || 'children']; var suppressVisitSub; order === 'preorder' && (suppressVisitSub = cb.call(context, this)); for (var i = 0; !suppressVisitSub && i < children.length; i++) { children[i].eachNode(options, cb, context); } order === 'postorder' && cb.call(context, this); }, /** * Update depth and height of this subtree. * * @param {number} depth */ updateDepthAndHeight: function (depth) { var height = 0; this.depth = depth; for (var i = 0; i < this.children.length; i++) { var child = this.children[i]; child.updateDepthAndHeight(depth + 1); if (child.height > height) { height = child.height; } } this.height = height + 1; }, /** * @param {string} id * @return {module:echarts/data/Tree~TreeNode} */ getNodeById: function (id) { if (this.getId() === id) { return this; } for (var i = 0, children = this.children, len = children.length; i < len; i++) { var res = children[i].getNodeById(id); if (res) { return res; } } }, /** * @param {module:echarts/data/Tree~TreeNode} node * @return {boolean} */ contains: function (node) { if (node === this) { return true; } for (var i = 0, children = this.children, len = children.length; i < len; i++) { var res = children[i].contains(node); if (res) { return res; } } }, /** * @param {boolean} includeSelf Default false. * @return {Array.} order: [root, child, grandchild, ...] */ getAncestors: function (includeSelf) { var ancestors = []; var node = includeSelf ? this : this.parentNode; while (node) { ancestors.push(node); node = node.parentNode; } ancestors.reverse(); return ancestors; }, /** * @param {string|Array=} [dimension='value'] Default 'value'. can be 0, 1, 2, 3 * @return {number} Value. */ getValue: function (dimension) { var data = this.hostTree.data; return data.get(data.getDimension(dimension || 'value'), this.dataIndex); }, /** * @param {Object} layout * @param {boolean=} [merge=false] */ setLayout: function (layout, merge) { this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, layout, merge); }, /** * @return {Object} layout */ getLayout: function () { return this.hostTree.data.getItemLayout(this.dataIndex); }, /** * @param {string} [path] * @return {module:echarts/model/Model} */ getModel: function (path) { if (this.dataIndex < 0) { return; } var hostTree = this.hostTree; var itemModel = hostTree.data.getItemModel(this.dataIndex); var levelModel = this.getLevelModel(); return itemModel.getModel(path, (levelModel || hostTree.hostModel).getModel(path)); }, /** * @return {module:echarts/model/Model} */ getLevelModel: function () { return (this.hostTree.levelModels || [])[this.depth]; }, /** * @example * setItemVisual('color', color); * setItemVisual({ * 'color': color * }); */ setVisual: function (key, value) { this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, key, value); }, /** * Get item visual */ getVisual: function (key, ignoreParent) { return this.hostTree.data.getItemVisual(this.dataIndex, key, ignoreParent); }, /** * @public * @return {number} */ getRawIndex: function () { return this.hostTree.data.getRawIndex(this.dataIndex); }, /** * @public * @return {string} */ getId: function () { return this.hostTree.data.getId(this.dataIndex); } }; /** * @constructor * @alias module:echarts/data/Tree * @param {module:echarts/model/Model} hostModel * @param {Array.} levelOptions */ function Tree(hostModel, levelOptions) { /** * @type {module:echarts/data/Tree~TreeNode} * @readOnly */ this.root; /** * @type {module:echarts/data/List} * @readOnly */ this.data; /** * Index of each item is the same as the raw index of coresponding list item. * @private * @type {Array. DRAG_THRESHOLD) ) { // These param must not be cached. var root = this.seriesModel.getData().tree.root; if (!root) { return; } var rootLayout = root.getLayout(); if (!rootLayout) { return; } this.api.dispatchAction({ type: 'treemapMove', from: this.uid, seriesId: this.seriesModel.id, rootRect: { x: rootLayout.x + dx, y: rootLayout.y + dy, width: rootLayout.width, height: rootLayout.height } }); } }, /** * @private */ _onZoom: function (scale, mouseX, mouseY) { if (this._state !== 'animating') { // These param must not be cached. var root = this.seriesModel.getData().tree.root; if (!root) { return; } var rootLayout = root.getLayout(); if (!rootLayout) { return; } var rect = new BoundingRect( rootLayout.x, rootLayout.y, rootLayout.width, rootLayout.height ); var layoutInfo = this.seriesModel.layoutInfo; // Transform mouse coord from global to containerGroup. mouseX -= layoutInfo.x; mouseY -= layoutInfo.y; // Scale root bounding rect. var m = matrix.create(); matrix.translate(m, m, [-mouseX, -mouseY]); matrix.scale(m, m, [scale, scale]); matrix.translate(m, m, [mouseX, mouseY]); rect.applyTransform(m); this.api.dispatchAction({ type: 'treemapRender', from: this.uid, seriesId: this.seriesModel.id, rootRect: { x: rect.x, y: rect.y, width: rect.width, height: rect.height } }); } }, /** * @private */ _initEvents: function (containerGroup) { containerGroup.on('click', function (e) { if (this._state !== 'ready') { return; } var nodeClick = this.seriesModel.get('nodeClick', true); if (!nodeClick) { return; } var targetInfo = this.findTarget(e.offsetX, e.offsetY); if (!targetInfo) { return; } var node = targetInfo.node; if (node.getLayout().isLeafRoot) { this._rootToNode(targetInfo); } else { if (nodeClick === 'zoomToNode') { this._zoomToNode(targetInfo); } else if (nodeClick === 'link') { var itemModel = node.hostTree.data.getItemModel(node.dataIndex); var link = itemModel.get('link', true); var linkTarget = itemModel.get('target', true) || 'blank'; link && window.open(link, linkTarget); } } }, this); }, /** * @private */ _renderBreadcrumb: function (seriesModel, api, targetInfo) { if (!targetInfo) { targetInfo = seriesModel.get('leafDepth', true) != null ? {node: seriesModel.getViewRoot()} // FIXME // better way? // Find breadcrumb tail on center of containerGroup. : this.findTarget(api.getWidth() / 2, api.getHeight() / 2); if (!targetInfo) { targetInfo = {node: seriesModel.getData().tree.root}; } } (this._breadcrumb || (this._breadcrumb = new Breadcrumb(this.group))) .render(seriesModel, api, targetInfo.node, bind(onSelect, this)); function onSelect(node) { if (this._state !== 'animating') { helper.aboveViewRoot(seriesModel.getViewRoot(), node) ? this._rootToNode({node: node}) : this._zoomToNode({node: node}); } } }, /** * @override */ remove: function () { this._clearController(); this._containerGroup && this._containerGroup.removeAll(); this._storage = createStorage(); this._state = 'ready'; this._breadcrumb && this._breadcrumb.remove(); }, dispose: function () { this._clearController(); }, /** * @private */ _zoomToNode: function (targetInfo) { this.api.dispatchAction({ type: 'treemapZoomToNode', from: this.uid, seriesId: this.seriesModel.id, targetNode: targetInfo.node }); }, /** * @private */ _rootToNode: function (targetInfo) { this.api.dispatchAction({ type: 'treemapRootToNode', from: this.uid, seriesId: this.seriesModel.id, targetNode: targetInfo.node }); }, /** * @public * @param {number} x Global coord x. * @param {number} y Global coord y. * @return {Object} info If not found, return undefined; * @return {number} info.node Target node. * @return {number} info.offsetX x refer to target node. * @return {number} info.offsetY y refer to target node. */ findTarget: function (x, y) { var targetInfo; var viewRoot = this.seriesModel.getViewRoot(); viewRoot.eachNode({attr: 'viewChildren', order: 'preorder'}, function (node) { var bgEl = this._storage.background[node.getRawIndex()]; // If invisible, there might be no element. if (bgEl) { var point = bgEl.transformCoordToLocal(x, y); var shape = bgEl.shape; // For performance consideration, dont use 'getBoundingRect'. if (shape.x ')); if (params.value) { html += ' : ' + formatUtil.encodeHTML(params.value); } return html; } else { // dataType === 'node' or empty return GraphSeries.superApply(this, 'formatTooltip', arguments); } }, _updateCategoriesData: function () { var categories = zrUtil.map(this.option.categories || [], function (category) { // Data must has value return category.value != null ? category : zrUtil.extend({ value: 0 }, category); }); var categoriesData = new List(['value'], this); categoriesData.initData(categories); this._categoriesData = categoriesData; this._categoriesModels = categoriesData.mapArray(function (idx) { return categoriesData.getItemModel(idx, true); }); }, setZoom: function (zoom) { this.option.zoom = zoom; }, setCenter: function (center) { this.option.center = center; }, isAnimationEnabled: function () { return GraphSeries.superCall(this, 'isAnimationEnabled') // Not enable animation when do force layout && !(this.get('layout') === 'force' && this.get('force.layoutAnimation')); }, defaultOption: { zlevel: 0, z: 2, coordinateSystem: 'view', // Default option for all coordinate systems // xAxisIndex: 0, // yAxisIndex: 0, // polarIndex: 0, // geoIndex: 0, legendHoverLink: true, hoverAnimation: true, layout: null, focusNodeAdjacency: false, // Configuration of circular layout circular: { rotateLabel: false }, // Configuration of force directed layout force: { initLayout: null, // Node repulsion. Can be an array to represent range. repulsion: [0, 50], gravity: 0.1, // Edge length. Can be an array to represent range. edgeLength: 30, layoutAnimation: true }, left: 'center', top: 'center', // right: null, // bottom: null, // width: '80%', // height: '80%', symbol: 'circle', symbolSize: 10, edgeSymbol: ['none', 'none'], edgeSymbolSize: 10, edgeLabel: { normal: { position: 'middle' }, emphasis: {} }, draggable: false, roam: false, // Default on center of graph center: null, zoom: 1, // Symbol size scale ratio in roam nodeScaleRatio: 0.6, // cursor: null, // categories: [], // data: [] // Or // nodes: [] // // links: [] // Or // edges: [] label: { normal: { show: false, formatter: '{b}' }, emphasis: { show: true } }, itemStyle: { normal: {}, emphasis: {} }, lineStyle: { normal: { color: '#aaa', width: 1, curveness: 0, opacity: 0.5 }, emphasis: {} } } }); module.exports = GraphSeries; /***/ }), /* 210 */ /***/ (function(module, exports, __webpack_require__) { var List = __webpack_require__(101); var Graph = __webpack_require__(211); var linkList = __webpack_require__(199); var completeDimensions = __webpack_require__(113); var CoordinateSystem = __webpack_require__(79); var zrUtil = __webpack_require__(4); var createListFromArray = __webpack_require__(112); module.exports = function (nodes, edges, hostModel, directed, beforeLink) { var graph = new Graph(directed); for (var i = 0; i < nodes.length; i++) { graph.addNode(zrUtil.retrieve( // Id, name, dataIndex nodes[i].id, nodes[i].name, i ), i); } var linkNameList = []; var validEdges = []; var linkCount = 0; for (var i = 0; i < edges.length; i++) { var link = edges[i]; var source = link.source; var target = link.target; // addEdge may fail when source or target not exists if (graph.addEdge(source, target, linkCount)) { validEdges.push(link); linkNameList.push(zrUtil.retrieve(link.id, source + ' > ' + target)); linkCount++; } } var coordSys = hostModel.get('coordinateSystem'); var nodeData; if (coordSys === 'cartesian2d' || coordSys === 'polar') { nodeData = createListFromArray(nodes, hostModel, hostModel.ecModel); } else { // FIXME var coordSysCtor = CoordinateSystem.get(coordSys); // FIXME var dimensionNames = completeDimensions( ((coordSysCtor && coordSysCtor.type !== 'view') ? (coordSysCtor.dimensions || []) : []).concat(['value']), nodes ); nodeData = new List(dimensionNames, hostModel); nodeData.initData(nodes); } var edgeData = new List(['value'], hostModel); edgeData.initData(validEdges, linkNameList); beforeLink && beforeLink(nodeData, edgeData); linkList({ mainData: nodeData, struct: graph, structAttr: 'graph', datas: {node: nodeData, edge: edgeData}, datasAttr: {node: 'data', edge: 'edgeData'} }); // Update dataIndex of nodes and edges because invalid edge may be removed graph.update(); return graph; }; /***/ }), /* 211 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; /** * Graph data structure * * @module echarts/data/Graph * @author Yi Shen(https://www.github.com/pissang) */ var zrUtil = __webpack_require__(4); // id may be function name of Object, add a prefix to avoid this problem. function generateNodeKey (id) { return '_EC_' + id; } /** * @alias module:echarts/data/Graph * @constructor * @param {boolean} directed */ var Graph = function(directed) { /** * 是否是有向图 * @type {boolean} * @private */ this._directed = directed || false; /** * @type {Array.} * @readOnly */ this.nodes = []; /** * @type {Array.} * @readOnly */ this.edges = []; /** * @type {Object.} * @private */ this._nodesMap = {}; /** * @type {Object.} * @private */ this._edgesMap = {}; /** * @type {module:echarts/data/List} * @readOnly */ this.data; /** * @type {module:echarts/data/List} * @readOnly */ this.edgeData; }; var graphProto = Graph.prototype; /** * @type {string} */ graphProto.type = 'graph'; /** * If is directed graph * @return {boolean} */ graphProto.isDirected = function () { return this._directed; }; /** * Add a new node * @param {string} id * @param {number} [dataIndex] */ graphProto.addNode = function (id, dataIndex) { id = id || ('' + dataIndex); var nodesMap = this._nodesMap; if (nodesMap[generateNodeKey(id)]) { if (true) { console.error('Graph nodes have duplicate name or id'); } return; } var node = new Node(id, dataIndex); node.hostGraph = this; this.nodes.push(node); nodesMap[generateNodeKey(id)] = node; return node; }; /** * Get node by data index * @param {number} dataIndex * @return {module:echarts/data/Graph~Node} */ graphProto.getNodeByIndex = function (dataIndex) { var rawIdx = this.data.getRawIndex(dataIndex); return this.nodes[rawIdx]; }; /** * Get node by id * @param {string} id * @return {module:echarts/data/Graph.Node} */ graphProto.getNodeById = function (id) { return this._nodesMap[generateNodeKey(id)]; }; /** * Add a new edge * @param {number|string|module:echarts/data/Graph.Node} n1 * @param {number|string|module:echarts/data/Graph.Node} n2 * @param {number} [dataIndex=-1] * @return {module:echarts/data/Graph.Edge} */ graphProto.addEdge = function (n1, n2, dataIndex) { var nodesMap = this._nodesMap; var edgesMap = this._edgesMap; // PNEDING if (typeof n1 === 'number') { n1 = this.nodes[n1]; } if (typeof n2 === 'number') { n2 = this.nodes[n2]; } if (!(n1 instanceof Node)) { n1 = nodesMap[generateNodeKey(n1)]; } if (!(n2 instanceof Node)) { n2 = nodesMap[generateNodeKey(n2)]; } if (!n1 || !n2) { return; } var key = n1.id + '-' + n2.id; // PENDING if (edgesMap[key]) { return; } var edge = new Edge(n1, n2, dataIndex); edge.hostGraph = this; if (this._directed) { n1.outEdges.push(edge); n2.inEdges.push(edge); } n1.edges.push(edge); if (n1 !== n2) { n2.edges.push(edge); } this.edges.push(edge); edgesMap[key] = edge; return edge; }; /** * Get edge by data index * @param {number} dataIndex * @return {module:echarts/data/Graph~Node} */ graphProto.getEdgeByIndex = function (dataIndex) { var rawIdx = this.edgeData.getRawIndex(dataIndex); return this.edges[rawIdx]; }; /** * Get edge by two linked nodes * @param {module:echarts/data/Graph.Node|string} n1 * @param {module:echarts/data/Graph.Node|string} n2 * @return {module:echarts/data/Graph.Edge} */ graphProto.getEdge = function (n1, n2) { if (n1 instanceof Node) { n1 = n1.id; } if (n2 instanceof Node) { n2 = n2.id; } var edgesMap = this._edgesMap; if (this._directed) { return edgesMap[n1 + '-' + n2]; } else { return edgesMap[n1 + '-' + n2] || edgesMap[n2 + '-' + n1]; } }; /** * Iterate all nodes * @param {Function} cb * @param {*} [context] */ graphProto.eachNode = function (cb, context) { var nodes = this.nodes; var len = nodes.length; for (var i = 0; i < len; i++) { if (nodes[i].dataIndex >= 0) { cb.call(context, nodes[i], i); } } }; /** * Iterate all edges * @param {Function} cb * @param {*} [context] */ graphProto.eachEdge = function (cb, context) { var edges = this.edges; var len = edges.length; for (var i = 0; i < len; i++) { if (edges[i].dataIndex >= 0 && edges[i].node1.dataIndex >= 0 && edges[i].node2.dataIndex >= 0 ) { cb.call(context, edges[i], i); } } }; /** * Breadth first traverse * @param {Function} cb * @param {module:echarts/data/Graph.Node} startNode * @param {string} [direction='none'] 'none'|'in'|'out' * @param {*} [context] */ graphProto.breadthFirstTraverse = function ( cb, startNode, direction, context ) { if (!(startNode instanceof Node)) { startNode = this._nodesMap[generateNodeKey(startNode)]; } if (!startNode) { return; } var edgeType = direction === 'out' ? 'outEdges' : (direction === 'in' ? 'inEdges' : 'edges'); for (var i = 0; i < this.nodes.length; i++) { this.nodes[i].__visited = false; } if (cb.call(context, startNode, null)) { return; } var queue = [startNode]; while (queue.length) { var currentNode = queue.shift(); var edges = currentNode[edgeType]; for (var i = 0; i < edges.length; i++) { var e = edges[i]; var otherNode = e.node1 === currentNode ? e.node2 : e.node1; if (!otherNode.__visited) { if (cb.call(context, otherNode, currentNode)) { // Stop traversing return; } queue.push(otherNode); otherNode.__visited = true; } } } }; // TODO // graphProto.depthFirstTraverse = function ( // cb, startNode, direction, context // ) { // }; // Filter update graphProto.update = function () { var data = this.data; var edgeData = this.edgeData; var nodes = this.nodes; var edges = this.edges; for (var i = 0, len = nodes.length; i < len; i++) { nodes[i].dataIndex = -1; } for (var i = 0, len = data.count(); i < len; i++) { nodes[data.getRawIndex(i)].dataIndex = i; } edgeData.filterSelf(function (idx) { var edge = edges[edgeData.getRawIndex(idx)]; return edge.node1.dataIndex >= 0 && edge.node2.dataIndex >= 0; }); // Update edge for (var i = 0, len = edges.length; i < len; i++) { edges[i].dataIndex = -1; } for (var i = 0, len = edgeData.count(); i < len; i++) { edges[edgeData.getRawIndex(i)].dataIndex = i; } }; /** * @return {module:echarts/data/Graph} */ graphProto.clone = function () { var graph = new Graph(this._directed); var nodes = this.nodes; var edges = this.edges; for (var i = 0; i < nodes.length; i++) { graph.addNode(nodes[i].id, nodes[i].dataIndex); } for (var i = 0; i < edges.length; i++) { var e = edges[i]; graph.addEdge(e.node1.id, e.node2.id, e.dataIndex); } return graph; }; /** * @alias module:echarts/data/Graph.Node */ function Node(id, dataIndex) { /** * @type {string} */ this.id = id == null ? '' : id; /** * @type {Array.} */ this.inEdges = []; /** * @type {Array.} */ this.outEdges = []; /** * @type {Array.} */ this.edges = []; /** * @type {module:echarts/data/Graph} */ this.hostGraph; /** * @type {number} */ this.dataIndex = dataIndex == null ? -1 : dataIndex; } Node.prototype = { constructor: Node, /** * @return {number} */ degree: function () { return this.edges.length; }, /** * @return {number} */ inDegree: function () { return this.inEdges.length; }, /** * @return {number} */ outDegree: function () { return this.outEdges.length; }, /** * @param {string} [path] * @return {module:echarts/model/Model} */ getModel: function (path) { if (this.dataIndex < 0) { return; } var graph = this.hostGraph; var itemModel = graph.data.getItemModel(this.dataIndex); return itemModel.getModel(path); } }; /** * 图边 * @alias module:echarts/data/Graph.Edge * @param {module:echarts/data/Graph.Node} n1 * @param {module:echarts/data/Graph.Node} n2 * @param {number} [dataIndex=-1] */ function Edge(n1, n2, dataIndex) { /** * 节点1，如果是有向图则为源节点 * @type {module:echarts/data/Graph.Node} */ this.node1 = n1; /** * 节点2，如果是有向图则为目标节点 * @type {module:echarts/data/Graph.Node} */ this.node2 = n2; this.dataIndex = dataIndex == null ? -1 : dataIndex; } /** * @param {string} [path] * @return {module:echarts/model/Model} */ Edge.prototype.getModel = function (path) { if (this.dataIndex < 0) { return; } var graph = this.hostGraph; var itemModel = graph.edgeData.getItemModel(this.dataIndex); return itemModel.getModel(path); }; var createGraphDataProxyMixin = function (hostName, dataName) { return { /** * @param {string=} [dimension='value'] Default 'value'. can be 'a', 'b', 'c', 'd', 'e'. * @return {number} */ getValue: function (dimension) { var data = this[hostName][dataName]; return data.get(data.getDimension(dimension || 'value'), this.dataIndex); }, /** * @param {Object|string} key * @param {*} [value] */ setVisual: function (key, value) { this.dataIndex >= 0 && this[hostName][dataName].setItemVisual(this.dataIndex, key, value); }, /** * @param {string} key * @return {boolean} */ getVisual: function (key, ignoreParent) { return this[hostName][dataName].getItemVisual(this.dataIndex, key, ignoreParent); }, /** * @param {Object} layout * @return {boolean} [merge=false] */ setLayout: function (layout, merge) { this.dataIndex >= 0 && this[hostName][dataName].setItemLayout(this.dataIndex, layout, merge); }, /** * @return {Object} */ getLayout: function () { return this[hostName][dataName].getItemLayout(this.dataIndex); }, /** * @return {module:zrender/Element} */ getGraphicEl: function () { return this[hostName][dataName].getItemGraphicEl(this.dataIndex); }, /** * @return {number} */ getRawIndex: function () { return this[hostName][dataName].getRawIndex(this.dataIndex); } }; }; zrUtil.mixin(Node, createGraphDataProxyMixin('hostGraph', 'data')); zrUtil.mixin(Edge, createGraphDataProxyMixin('hostGraph', 'edgeData')); Graph.Node = Node; Graph.Edge = Edge; module.exports = Graph; /***/ }), /* 212 */ /***/ (function(module, exports, __webpack_require__) { var SymbolDraw = __webpack_require__(119); var LineDraw = __webpack_require__(213); var RoamController = __webpack_require__(186); var roamHelper = __webpack_require__(188); var cursorHelper = __webpack_require__(189); var graphic = __webpack_require__(20); var adjustEdge = __webpack_require__(216); var zrUtil = __webpack_require__(4); var nodeOpacityPath = ['itemStyle', 'normal', 'opacity']; var lineOpacityPath = ['lineStyle', 'normal', 'opacity']; function getItemOpacity(item, opacityPath) { return item.getVisual('opacity') || item.getModel().get(opacityPath); } function fadeOutItem(item, opacityPath, opacityRatio) { var el = item.getGraphicEl(); var opacity = getItemOpacity(item, opacityPath); if (opacityRatio != null) { opacity == null && (opacity = 1); opacity *= opacityRatio; } el.downplay && el.downplay(); el.traverse(function (child) { if (child.type !== 'group') { child.setStyle('opacity', opacity); } }); } function fadeInItem(item, opacityPath) { var opacity = getItemOpacity(item, opacityPath); var el = item.getGraphicEl(); el.highlight && el.highlight(); el.traverse(function (child) { if (child.type !== 'group') { child.setStyle('opacity', opacity); } }); } __webpack_require__(1).extendChartView({ type: 'graph', init: function (ecModel, api) { var symbolDraw = new SymbolDraw(); var lineDraw = new LineDraw(); var group = this.group; this._controller = new RoamController(api.getZr()); this._controllerHost = {target: group}; group.add(symbolDraw.group); group.add(lineDraw.group); this._symbolDraw = symbolDraw; this._lineDraw = lineDraw; this._firstRender = true; }, render: function (seriesModel, ecModel, api) { var coordSys = seriesModel.coordinateSystem; this._model = seriesModel; this._nodeScaleRatio = seriesModel.get('nodeScaleRatio'); var symbolDraw = this._symbolDraw; var lineDraw = this._lineDraw; var group = this.group; if (coordSys.type === 'view') { var groupNewProp = { position: coordSys.position, scale: coordSys.scale }; if (this._firstRender) { group.attr(groupNewProp); } else { graphic.updateProps(group, groupNewProp, seriesModel); } } // Fix edge contact point with node adjustEdge(seriesModel.getGraph(), this._getNodeGlobalScale(seriesModel)); var data = seriesModel.getData(); symbolDraw.updateData(data); var edgeData = seriesModel.getEdgeData(); lineDraw.updateData(edgeData); this._updateNodeAndLinkScale(); this._updateController(seriesModel, ecModel, api); clearTimeout(this._layoutTimeout); var forceLayout = seriesModel.forceLayout; var layoutAnimation = seriesModel.get('force.layoutAnimation'); if (forceLayout) { this._startForceLayoutIteration(forceLayout, layoutAnimation); } data.eachItemGraphicEl(function (el, idx) { var itemModel = data.getItemModel(idx); // Update draggable el.off('drag').off('dragend'); var draggable = data.getItemModel(idx).get('draggable'); if (draggable) { el.on('drag', function () { if (forceLayout) { forceLayout.warmUp(); !this._layouting && this._startForceLayoutIteration(forceLayout, layoutAnimation); forceLayout.setFixed(idx); // Write position back to layout data.setItemLayout(idx, el.position); } }, this).on('dragend', function () { if (forceLayout) { forceLayout.setUnfixed(idx); } }, this); } el.setDraggable(draggable && forceLayout); el.off('mouseover', el.__focusNodeAdjacency); el.off('mouseout', el.__unfocusNodeAdjacency); if (itemModel.get('focusNodeAdjacency')) { el.on('mouseover', el.__focusNodeAdjacency = function () { api.dispatchAction({ type: 'focusNodeAdjacency', seriesId: seriesModel.id, dataIndex: el.dataIndex }); }); el.on('mouseout', el.__unfocusNodeAdjacency = function () { api.dispatchAction({ type: 'unfocusNodeAdjacency', seriesId: seriesModel.id }); }); } }, this); var circularRotateLabel = seriesModel.get('layout') === 'circular' && seriesModel.get('circular.rotateLabel'); var cx = data.getLayout('cx'); var cy = data.getLayout('cy'); data.eachItemGraphicEl(function (el, idx) { var symbolPath = el.getSymbolPath(); if (circularRotateLabel) { var pos = data.getItemLayout(idx); var rad = Math.atan2(pos[1] - cy, pos[0] - cx); if (rad < 0) { rad = Math.PI * 2 + rad; } var isLeft = pos[0] < cx; if (isLeft) { rad = rad - Math.PI; } var textPosition = isLeft ? 'left' : 'right'; symbolPath.setStyle({ textRotation: -rad, textPosition: textPosition, textOrigin: 'center' }); symbolPath.hoverStyle && (symbolPath.hoverStyle.textPosition = textPosition); } else { symbolPath.setStyle({ textRotation: 0 }); } }); this._firstRender = false; }, dispose: function () { this._controller && this._controller.dispose(); this._controllerHost = {}; }, focusNodeAdjacency: function (seriesModel, ecModel, api, payload) { var data = this._model.getData(); var dataIndex = payload.dataIndex; var el = data.getItemGraphicEl(dataIndex); if (!el) { return; } var graph = data.graph; var dataType = el.dataType; if (dataIndex !== null && dataType !== 'edge') { graph.eachNode(function (node) { fadeOutItem(node, nodeOpacityPath, 0.1); }); graph.eachEdge(function (edge) { fadeOutItem(edge, lineOpacityPath, 0.1); }); var node = graph.getNodeByIndex(dataIndex); fadeInItem(node, nodeOpacityPath); zrUtil.each(node.edges, function (edge) { if (edge.dataIndex < 0) { return; } fadeInItem(edge, lineOpacityPath); fadeInItem(edge.node1, nodeOpacityPath); fadeInItem(edge.node2, nodeOpacityPath); }); } }, unfocusNodeAdjacency: function (seriesModel, ecModel, api, payload) { var graph = this._model.getData().graph; graph.eachNode(function (node) { fadeOutItem(node, nodeOpacityPath); }); graph.eachEdge(function (edge) { fadeOutItem(edge, lineOpacityPath); }); }, _startForceLayoutIteration: function (forceLayout, layoutAnimation) { var self = this; (function step() { forceLayout.step(function (stopped) { self.updateLayout(self._model); (self._layouting = !stopped) && ( layoutAnimation ? (self._layoutTimeout = setTimeout(step, 16)) : step() ); }); })(); }, _updateController: function (seriesModel, ecModel, api) { var controller = this._controller; var controllerHost = this._controllerHost; var group = this.group; controller.setPointerChecker(function (e, x, y) { var rect = group.getBoundingRect(); rect.applyTransform(group.transform); return rect.contain(x, y) && !cursorHelper.onIrrelevantElement(e, api, seriesModel); }); if (seriesModel.coordinateSystem.type !== 'view') { controller.disable(); return; } controller.enable(seriesModel.get('roam')); controllerHost.zoomLimit = seriesModel.get('scaleLimit'); controllerHost.zoom = seriesModel.coordinateSystem.getZoom(); controller .off('pan') .off('zoom') .on('pan', function (dx, dy) { roamHelper.updateViewOnPan(controllerHost, dx, dy); api.dispatchAction({ seriesId: seriesModel.id, type: 'graphRoam', dx: dx, dy: dy }); }) .on('zoom', function (zoom, mouseX, mouseY) { roamHelper.updateViewOnZoom(controllerHost, zoom, mouseX, mouseY); api.dispatchAction({ seriesId: seriesModel.id, type: 'graphRoam', zoom: zoom, originX: mouseX, originY: mouseY }); this._updateNodeAndLinkScale(); adjustEdge(seriesModel.getGraph(), this._getNodeGlobalScale(seriesModel)); this._lineDraw.updateLayout(); }, this); }, _updateNodeAndLinkScale: function () { var seriesModel = this._model; var data = seriesModel.getData(); var nodeScale = this._getNodeGlobalScale(seriesModel); var invScale = [nodeScale, nodeScale]; data.eachItemGraphicEl(function (el, idx) { el.attr('scale', invScale); }); }, _getNodeGlobalScale: function (seriesModel) { var coordSys = seriesModel.coordinateSystem; if (coordSys.type !== 'view') { return 1; } var nodeScaleRatio = this._nodeScaleRatio; var groupScale = coordSys.scale; var groupZoom = (groupScale && groupScale[0]) || 1; // Scale node when zoom changes var roamZoom = coordSys.getZoom(); var nodeScale = (roamZoom - 1) * nodeScaleRatio + 1; return nodeScale / groupZoom; }, updateLayout: function (seriesModel) { adjustEdge(seriesModel.getGraph(), this._getNodeGlobalScale(seriesModel)); this._symbolDraw.updateLayout(); this._lineDraw.updateLayout(); }, remove: function (ecModel, api) { this._symbolDraw && this._symbolDraw.remove(); this._lineDraw && this._lineDraw.remove(); } }); /***/ }), /* 213 */ /***/ (function(module, exports, __webpack_require__) { /** * @module echarts/chart/helper/LineDraw */ var graphic = __webpack_require__(20); var LineGroup = __webpack_require__(214); function isPointNaN(pt) { return isNaN(pt[0]) || isNaN(pt[1]); } function lineNeedsDraw(pts) { return !isPointNaN(pts[0]) && !isPointNaN(pts[1]); } /** * @alias module:echarts/component/marker/LineDraw * @constructor */ function LineDraw(ctor) { this._ctor = ctor || LineGroup; this.group = new graphic.Group(); } var lineDrawProto = LineDraw.prototype; /** * @param {module:echarts/data/List} lineData */ lineDrawProto.updateData = function (lineData) { var oldLineData = this._lineData; var group = this.group; var LineCtor = this._ctor; var hostModel = lineData.hostModel; var seriesScope = { lineStyle: hostModel.getModel('lineStyle.normal').getLineStyle(), hoverLineStyle: hostModel.getModel('lineStyle.emphasis').getLineStyle(), labelModel: hostModel.getModel('label.normal'), hoverLabelModel: hostModel.getModel('label.emphasis') }; lineData.diff(oldLineData) .add(function (idx) { if (!lineNeedsDraw(lineData.getItemLayout(idx))) { return; } var lineGroup = new LineCtor(lineData, idx, seriesScope); lineData.setItemGraphicEl(idx, lineGroup); group.add(lineGroup); }) .update(function (newIdx, oldIdx) { var lineGroup = oldLineData.getItemGraphicEl(oldIdx); if (!lineNeedsDraw(lineData.getItemLayout(newIdx))) { group.remove(lineGroup); return; } if (!lineGroup) { lineGroup = new LineCtor(lineData, newIdx, seriesScope); } else { lineGroup.updateData(lineData, newIdx, seriesScope); } lineData.setItemGraphicEl(newIdx, lineGroup); group.add(lineGroup); }) .remove(function (idx) { group.remove(oldLineData.getItemGraphicEl(idx)); }) .execute(); this._lineData = lineData; }; lineDrawProto.updateLayout = function () { var lineData = this._lineData; lineData.eachItemGraphicEl(function (el, idx) { el.updateLayout(lineData, idx); }, this); }; lineDrawProto.remove = function () { this.group.removeAll(); }; module.exports = LineDraw; /***/ }), /* 214 */ /***/ (function(module, exports, __webpack_require__) { /** * @module echarts/chart/helper/Line */ var symbolUtil = __webpack_require__(114); var vector = __webpack_require__(10); // var matrix = require('zrender/lib/core/matrix'); var LinePath = __webpack_require__(215); var graphic = __webpack_require__(20); var zrUtil = __webpack_require__(4); var numberUtil = __webpack_require__(7); var SYMBOL_CATEGORIES = ['fromSymbol', 'toSymbol']; function makeSymbolTypeKey(symbolCategory) { return '_' + symbolCategory + 'Type'; } /** * @inner */ function createSymbol(name, lineData, idx) { var color = lineData.getItemVisual(idx, 'color'); var symbolType = lineData.getItemVisual(idx, name); var symbolSize = lineData.getItemVisual(idx, name + 'Size'); if (!symbolType || symbolType === 'none') { return; } if (!zrUtil.isArray(symbolSize)) { symbolSize = [symbolSize, symbolSize]; } var symbolPath = symbolUtil.createSymbol( symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2, symbolSize[0], symbolSize[1], color ); symbolPath.name = name; return symbolPath; } function createLine(points) { var line = new LinePath({ name: 'line' }); setLinePoints(line.shape, points); return line; } function setLinePoints(targetShape, points) { var p1 = points[0]; var p2 = points[1]; var cp1 = points[2]; targetShape.x1 = p1[0]; targetShape.y1 = p1[1]; targetShape.x2 = p2[0]; targetShape.y2 = p2[1]; targetShape.percent = 1; if (cp1) { targetShape.cpx1 = cp1[0]; targetShape.cpy1 = cp1[1]; } else { targetShape.cpx1 = NaN; targetShape.cpy1 = NaN; } } function updateSymbolAndLabelBeforeLineUpdate () { var lineGroup = this; var symbolFrom = lineGroup.childOfName('fromSymbol'); var symbolTo = lineGroup.childOfName('toSymbol'); var label = lineGroup.childOfName('label'); // Quick reject if (!symbolFrom && !symbolTo && label.ignore) { return; } var invScale = 1; var parentNode = this.parent; while (parentNode) { if (parentNode.scale) { invScale /= parentNode.scale[0]; } parentNode = parentNode.parent; } var line = lineGroup.childOfName('line'); // If line not changed // FIXME Parent scale changed if (!this.__dirty && !line.__dirty) { return; } var percent = line.shape.percent; var fromPos = line.pointAt(0); var toPos = line.pointAt(percent); var d = vector.sub([], toPos, fromPos); vector.normalize(d, d); if (symbolFrom) { symbolFrom.attr('position', fromPos); var tangent = line.tangentAt(0); symbolFrom.attr('rotation', Math.PI / 2 - Math.atan2( tangent[1], tangent[0] )); symbolFrom.attr('scale', [invScale * percent, invScale * percent]); } if (symbolTo) { symbolTo.attr('position', toPos); var tangent = line.tangentAt(1); symbolTo.attr('rotation', -Math.PI / 2 - Math.atan2( tangent[1], tangent[0] )); symbolTo.attr('scale', [invScale * percent, invScale * percent]); } if (!label.ignore) { label.attr('position', toPos); var textPosition; var textAlign; var textVerticalAlign; var distance = 5 * invScale; // End if (label.__position === 'end') { textPosition = [d[0] * distance + toPos[0], d[1] * distance + toPos[1]]; textAlign = d[0] > 0.8 ? 'left' : (d[0] < -0.8 ? 'right' : 'center'); textVerticalAlign = d[1] > 0.8 ? 'top' : (d[1] < -0.8 ? 'bottom' : 'middle'); } // Middle else if (label.__position === 'middle') { var halfPercent = percent / 2; var tangent = line.tangentAt(halfPercent); var n = [tangent[1], -tangent[0]]; var cp = line.pointAt(halfPercent); if (n[1] > 0) { n[0] = -n[0]; n[1] = -n[1]; } textPosition = [cp[0] + n[0] * distance, cp[1] + n[1] * distance]; textAlign = 'center'; textVerticalAlign = 'bottom'; var rotation = -Math.atan2(tangent[1], tangent[0]); if (toPos[0] < fromPos[0]) { rotation = Math.PI + rotation; } label.attr('rotation', rotation); } // Start else { textPosition = [-d[0] * distance + fromPos[0], -d[1] * distance + fromPos[1]]; textAlign = d[0] > 0.8 ? 'right' : (d[0] < -0.8 ? 'left' : 'center'); textVerticalAlign = d[1] > 0.8 ? 'bottom' : (d[1] < -0.8 ? 'top' : 'middle'); } label.attr({ style: { // Use the user specified text align and baseline first textVerticalAlign: label.__verticalAlign || textVerticalAlign, textAlign: label.__textAlign || textAlign }, position: textPosition, scale: [invScale, invScale] }); } } /** * @constructor * @extends {module:zrender/graphic/Group} * @alias {module:echarts/chart/helper/Line} */ function Line(lineData, idx, seriesScope) { graphic.Group.call(this); this._createLine(lineData, idx, seriesScope); } var lineProto = Line.prototype; // Update symbol position and rotation lineProto.beforeUpdate = updateSymbolAndLabelBeforeLineUpdate; lineProto._createLine = function (lineData, idx, seriesScope) { var seriesModel = lineData.hostModel; var linePoints = lineData.getItemLayout(idx); var line = createLine(linePoints); line.shape.percent = 0; graphic.initProps(line, { shape: { percent: 1 } }, seriesModel, idx); this.add(line); var label = new graphic.Text({ name: 'label' }); this.add(label); zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) { var symbol = createSymbol(symbolCategory, lineData, idx); // symbols must added after line to make sure // it will be updated after line#update. // Or symbol position and rotation update in line#beforeUpdate will be one frame slow this.add(symbol); this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory); }, this); this._updateCommonStl(lineData, idx, seriesScope); }; lineProto.updateData = function (lineData, idx, seriesScope) { var seriesModel = lineData.hostModel; var line = this.childOfName('line'); var linePoints = lineData.getItemLayout(idx); var target = { shape: {} }; setLinePoints(target.shape, linePoints); graphic.updateProps(line, target, seriesModel, idx); zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) { var symbolType = lineData.getItemVisual(idx, symbolCategory); var key = makeSymbolTypeKey(symbolCategory); // Symbol changed if (this[key] !== symbolType) { this.remove(this.childOfName(symbolCategory)); var symbol = createSymbol(symbolCategory, lineData, idx); this.add(symbol); } this[key] = symbolType; }, this); this._updateCommonStl(lineData, idx, seriesScope); }; lineProto._updateCommonStl = function (lineData, idx, seriesScope) { var seriesModel = lineData.hostModel; var line = this.childOfName('line'); var lineStyle = seriesScope && seriesScope.lineStyle; var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle; var labelModel = seriesScope && seriesScope.labelModel; var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel; // Optimization for large dataset if (!seriesScope || lineData.hasItemOption) { var itemModel = lineData.getItemModel(idx); lineStyle = itemModel.getModel('lineStyle.normal').getLineStyle(); hoverLineStyle = itemModel.getModel('lineStyle.emphasis').getLineStyle(); labelModel = itemModel.getModel('label.normal'); hoverLabelModel = itemModel.getModel('label.emphasis'); } var visualColor = lineData.getItemVisual(idx, 'color'); var visualOpacity = zrUtil.retrieve3( lineData.getItemVisual(idx, 'opacity'), lineStyle.opacity, 1 ); line.useStyle(zrUtil.defaults( { strokeNoScale: true, fill: 'none', stroke: visualColor, opacity: visualOpacity }, lineStyle )); line.hoverStyle = hoverLineStyle; // Update symbol zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) { var symbol = this.childOfName(symbolCategory); if (symbol) { symbol.setColor(visualColor); symbol.setStyle({ opacity: visualOpacity }); } }, this); var showLabel = labelModel.getShallow('show'); var hoverShowLabel = hoverLabelModel.getShallow('show'); var label = this.childOfName('label'); var defaultLabelColor; var defaultText; var normalText; var emphasisText; if (showLabel || hoverShowLabel) { var rawVal = seriesModel.getRawValue(idx); defaultText = rawVal == null ? defaultText = lineData.getName(idx) : isFinite(rawVal) ? numberUtil.round(rawVal) : rawVal; defaultLabelColor = visualColor || '#000'; normalText = zrUtil.retrieve2( seriesModel.getFormattedLabel(idx, 'normal', lineData.dataType), defaultText ); emphasisText = zrUtil.retrieve2( seriesModel.getFormattedLabel(idx, 'emphasis', lineData.dataType), normalText ); } // label.afterUpdate = lineAfterUpdate; if (showLabel) { var labelStyle = graphic.setTextStyle(label.style, labelModel, { text: normalText }, { autoColor: defaultLabelColor }); label.__textAlign = labelStyle.textAlign; label.__verticalAlign = labelStyle.textVerticalAlign; // 'start', 'middle', 'end' label.__position = labelModel.get('position') || 'middle'; } else { label.setStyle('text', null); } if (hoverShowLabel) { // Only these properties supported in this emphasis style here. label.hoverStyle = { text: emphasisText, textFill: hoverLabelModel.getTextColor(true), // For merging hover style to normal style, do not use // `hoverLabelModel.getFont()` here. fontStyle: hoverLabelModel.getShallow('fontStyle'), fontWeight: hoverLabelModel.getShallow('fontWeight'), fontSize: hoverLabelModel.getShallow('fontSize'), fontFamily: hoverLabelModel.getShallow('fontFamily') }; } else { label.hoverStyle = { text: null }; } label.ignore = !showLabel && !hoverShowLabel; graphic.setHoverStyle(this); }; lineProto.highlight = function () { this.trigger('emphasis'); }; lineProto.downplay = function () { this.trigger('normal'); }; lineProto.updateLayout = function (lineData, idx) { this.setLinePoints(lineData.getItemLayout(idx)); }; lineProto.setLinePoints = function (points) { var linePath = this.childOfName('line'); setLinePoints(linePath.shape, points); linePath.dirty(); }; zrUtil.inherits(Line, graphic.Group); module.exports = Line; /***/ }), /* 215 */ /***/ (function(module, exports, __webpack_require__) { /** * Line path for bezier and straight line draw */ var graphic = __webpack_require__(20); var vec2 = __webpack_require__(10); var straightLineProto = graphic.Line.prototype; var bezierCurveProto = graphic.BezierCurve.prototype; function isLine(shape) { return isNaN(+shape.cpx1) || isNaN(+shape.cpy1); } module.exports = graphic.extendShape({ type: 'ec-line', style: { stroke: '#000', fill: null }, shape: { x1: 0, y1: 0, x2: 0, y2: 0, percent: 1, cpx1: null, cpy1: null }, buildPath: function (ctx, shape) { (isLine(shape) ? straightLineProto : bezierCurveProto).buildPath(ctx, shape); }, pointAt: function (t) { return isLine(this.shape) ? straightLineProto.pointAt.call(this, t) : bezierCurveProto.pointAt.call(this, t); }, tangentAt: function (t) { var shape = this.shape; var p = isLine(shape) ? [shape.x2 - shape.x1, shape.y2 - shape.y1] : bezierCurveProto.tangentAt.call(this, t); return vec2.normalize(p, p); } }); /***/ }), /* 216 */ /***/ (function(module, exports, __webpack_require__) { var curveTool = __webpack_require__(40); var vec2 = __webpack_require__(10); var v1 = []; var v2 = []; var v3 = []; var quadraticAt = curveTool.quadraticAt; var v2DistSquare = vec2.distSquare; var mathAbs = Math.abs; function intersectCurveCircle(curvePoints, center, radius) { var p0 = curvePoints[0]; var p1 = curvePoints[1]; var p2 = curvePoints[2]; var d = Infinity; var t; var radiusSquare = radius * radius; var interval = 0.1; for (var _t = 0.1; _t = 0) { t = t - interval; } else { t = t + interval; } } } return t; } // Adjust edge to avoid module.exports = function (graph, scale) { var tmp0 = []; var quadraticSubdivide = curveTool.quadraticSubdivide; var pts = [[], [], []]; var pts2 = [[], []]; var v = []; scale /= 2; function getSymbolSize(node) { var symbolSize = node.getVisual('symbolSize'); if (symbolSize instanceof Array) { symbolSize = (symbolSize[0] + symbolSize[1]) / 2; } return symbolSize; } graph.eachEdge(function (edge, idx) { var linePoints = edge.getLayout(); var fromSymbol = edge.getVisual('fromSymbol'); var toSymbol = edge.getVisual('toSymbol'); if (!linePoints.__original) { linePoints.__original = [ vec2.clone(linePoints[0]), vec2.clone(linePoints[1]) ]; if (linePoints[2]) { linePoints.__original.push(vec2.clone(linePoints[2])); } } var originalPoints = linePoints.__original; // Quadratic curve if (linePoints[2] != null) { vec2.copy(pts[0], originalPoints[0]); vec2.copy(pts[1], originalPoints[2]); vec2.copy(pts[2], originalPoints[1]); if (fromSymbol && fromSymbol != 'none') { var symbolSize = getSymbolSize(edge.node1); var t = intersectCurveCircle(pts, originalPoints[0], symbolSize * scale); // Subdivide and get the second quadraticSubdivide(pts[0][0], pts[1][0], pts[2][0], t, tmp0); pts[0][0] = tmp0[3]; pts[1][0] = tmp0[4]; quadraticSubdivide(pts[0][1], pts[1][1], pts[2][1], t, tmp0); pts[0][1] = tmp0[3]; pts[1][1] = tmp0[4]; } if (toSymbol && toSymbol != 'none') { var symbolSize = getSymbolSize(edge.node2); var t = intersectCurveCircle(pts, originalPoints[1], symbolSize * scale); // Subdivide and get the first quadraticSubdivide(pts[0][0], pts[1][0], pts[2][0], t, tmp0); pts[1][0] = tmp0[1]; pts[2][0] = tmp0[2]; quadraticSubdivide(pts[0][1], pts[1][1], pts[2][1], t, tmp0); pts[1][1] = tmp0[1]; pts[2][1] = tmp0[2]; } // Copy back to layout vec2.copy(linePoints[0], pts[0]); vec2.copy(linePoints[1], pts[2]); vec2.copy(linePoints[2], pts[1]); } // Line else { vec2.copy(pts2[0], originalPoints[0]); vec2.copy(pts2[1], originalPoints[1]); vec2.sub(v, pts2[1], pts2[0]); vec2.normalize(v, v); if (fromSymbol && fromSymbol != 'none') { var symbolSize = getSymbolSize(edge.node1); vec2.scaleAndAdd(pts2[0], pts2[0], v, symbolSize * scale); } if (toSymbol && toSymbol != 'none') { var symbolSize = getSymbolSize(edge.node2); vec2.scaleAndAdd(pts2[1], pts2[1], v, -symbolSize * scale); } vec2.copy(linePoints[0], pts2[0]); vec2.copy(linePoints[1], pts2[1]); } }); }; /***/ }), /* 217 */ /***/ (function(module, exports, __webpack_require__) { var echarts = __webpack_require__(1); var roamHelper = __webpack_require__(191); var actionInfo = { type: 'graphRoam', event: 'graphRoam', update: 'none' }; /** * @payload * @property {string} name Series name * @property {number} [dx] * @property {number} [dy] * @property {number} [zoom] * @property {number} [originX] * @property {number} [originY] */ echarts.registerAction(actionInfo, function (payload, ecModel) { ecModel.eachComponent({mainType: 'series', query: payload}, function (seriesModel) { var coordSys = seriesModel.coordinateSystem; var res = roamHelper.updateCenterAndZoom(coordSys, payload); seriesModel.setCenter && seriesModel.setCenter(res.center); seriesModel.setZoom && seriesModel.setZoom(res.zoom); }); }); /** * @payload * @property {number} [seriesIndex] * @property {string} [seriesId] * @property {string} [seriesName] * @property {number} [dataIndex] */ echarts.registerAction({ type: 'focusNodeAdjacency', event: 'focusNodeAdjacency', update: 'series.graph:focusNodeAdjacency' }, function () {}); /** * @payload * @property {number} [seriesIndex] * @property {string} [seriesId] * @property {string} [seriesName] */ echarts.registerAction({ type: 'unfocusNodeAdjacency', event: 'unfocusNodeAdjacency', update: 'series.graph:unfocusNodeAdjacency' }, function () {}); /***/ }), /* 218 */ /***/ (function(module, exports) { module.exports = function (ecModel) { var legendModels = ecModel.findComponents({ mainType: 'legend' }); if (!legendModels || !legendModels.length) { return; } ecModel.eachSeriesByType('graph', function (graphSeries) { var categoriesData = graphSeries.getCategoriesData(); var graph = graphSeries.getGraph(); var data = graph.data; var categoryNames = categoriesData.mapArray(categoriesData.getName); data.filterSelf(function (idx) { var model = data.getItemModel(idx); var category = model.getShallow('category'); if (category != null) { if (typeof category === 'number') { category = categoryNames[category]; } // If in any legend component the status is not selected. for (var i = 0; i < legendModels.length; i++) { if (!legendModels[i].isSelected(category)) { return false; } } } return true; }); }, this); }; /***/ }), /* 219 */ /***/ (function(module, exports) { module.exports = function (ecModel) { var paletteScope = {}; ecModel.eachSeriesByType('graph', function (seriesModel) { var categoriesData = seriesModel.getCategoriesData(); var data = seriesModel.getData(); var categoryNameIdxMap = {}; categoriesData.each(function (idx) { var name = categoriesData.getName(idx); // Add prefix to avoid conflict with Object.prototype. categoryNameIdxMap['ec-' + name] = idx; var itemModel = categoriesData.getItemModel(idx); var color = itemModel.get('itemStyle.normal.color') || seriesModel.getColorFromPalette(name, paletteScope); categoriesData.setItemVisual(idx, 'color', color); }); // Assign category color to visual if (categoriesData.count()) { data.each(function (idx) { var model = data.getItemModel(idx); var category = model.getShallow('category'); if (category != null) { if (typeof category === 'string') { category = categoryNameIdxMap['ec-' + category]; } if (!data.getItemVisual(idx, 'color', true)) { data.setItemVisual( idx, 'color', categoriesData.getItemVisual(category, 'color') ); } } }); } }); }; /***/ }), /* 220 */ /***/ (function(module, exports) { function normalize(a) { if (!(a instanceof Array)) { a = [a, a]; } return a; } module.exports = function (ecModel) { ecModel.eachSeriesByType('graph', function (seriesModel) { var graph = seriesModel.getGraph(); var edgeData = seriesModel.getEdgeData(); var symbolType = normalize(seriesModel.get('edgeSymbol')); var symbolSize = normalize(seriesModel.get('edgeSymbolSize')); var colorQuery = 'lineStyle.normal.color'.split('.'); var opacityQuery = 'lineStyle.normal.opacity'.split('.'); edgeData.setVisual('fromSymbol', symbolType && symbolType[0]); edgeData.setVisual('toSymbol', symbolType && symbolType[1]); edgeData.setVisual('fromSymbolSize', symbolSize && symbolSize[0]); edgeData.setVisual('toSymbolSize', symbolSize && symbolSize[1]); edgeData.setVisual('color', seriesModel.get(colorQuery)); edgeData.setVisual('opacity', seriesModel.get(opacityQuery)); edgeData.each(function (idx) { var itemModel = edgeData.getItemModel(idx); var edge = graph.getEdgeByIndex(idx); var symbolType = normalize(itemModel.getShallow('symbol', true)); var symbolSize = normalize(itemModel.getShallow('symbolSize', true)); // Edge visual must after node visual var color = itemModel.get(colorQuery); var opacity = itemModel.get(opacityQuery); switch (color) { case 'source': color = edge.node1.getVisual('color'); break; case 'target': color = edge.node2.getVisual('color'); break; } symbolType[0] && edge.setVisual('fromSymbol', symbolType[0]); symbolType[1] && edge.setVisual('toSymbol', symbolType[1]); symbolSize[0] && edge.setVisual('fromSymbolSize', symbolSize[0]); symbolSize[1] && edge.setVisual('toSymbolSize', symbolSize[1]); edge.setVisual('color', color); edge.setVisual('opacity', opacity); }); }); }; /***/ }), /* 221 */ /***/ (function(module, exports, __webpack_require__) { var simpleLayoutHelper = __webpack_require__(222); var simpleLayoutEdge = __webpack_require__(223); module.exports = function (ecModel, api) { ecModel.eachSeriesByType('graph', function (seriesModel) { var layout = seriesModel.get('layout'); var coordSys = seriesModel.coordinateSystem; if (coordSys && coordSys.type !== 'view') { var data = seriesModel.getData(); var dimensions = coordSys.dimensions; data.each(dimensions, function () { var hasValue; var args = arguments; var value = []; for (var i = 0; i < dimensions.length; i++) { if (!isNaN(args[i])) { hasValue = true; } value.push(args[i]); } var idx = args[args.length - 1]; if (hasValue) { data.setItemLayout(idx, coordSys.dataToPoint(value)); } else { // Also {Array.}, not undefined to avoid if...else... statement data.setItemLayout(idx, [NaN, NaN]); } }); simpleLayoutEdge(data.graph); } else if (!layout || layout === 'none') { simpleLayoutHelper(seriesModel); } }); }; /***/ }), /* 222 */ /***/ (function(module, exports, __webpack_require__) { var simpleLayoutEdge = __webpack_require__(223); module.exports = function (seriesModel) { var coordSys = seriesModel.coordinateSystem; if (coordSys && coordSys.type !== 'view') { return; } var graph = seriesModel.getGraph(); graph.eachNode(function (node) { var model = node.getModel(); node.setLayout([+model.get('x'), +model.get('y')]); }); simpleLayoutEdge(graph); }; /***/ }), /* 223 */ /***/ (function(module, exports, __webpack_require__) { var vec2 = __webpack_require__(10); module.exports = function (graph) { graph.eachEdge(function (edge) { var curveness = edge.getModel().get('lineStyle.normal.curveness') || 0; var p1 = vec2.clone(edge.node1.getLayout()); var p2 = vec2.clone(edge.node2.getLayout()); var points = [p1, p2]; if (+curveness) { points.push([ (p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * curveness, (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * curveness ]); } edge.setLayout(points); }); }; /***/ }), /* 224 */ /***/ (function(module, exports, __webpack_require__) { var circularLayoutHelper = __webpack_require__(225); module.exports = function (ecModel) { ecModel.eachSeriesByType('graph', function (seriesModel) { if (seriesModel.get('layout') === 'circular') { circularLayoutHelper(seriesModel); } }); }; /***/ }), /* 225 */ /***/ (function(module, exports, __webpack_require__) { var vec2 = __webpack_require__(10); module.exports = function (seriesModel) { var coordSys = seriesModel.coordinateSystem; if (coordSys && coordSys.type !== 'view') { return; } var rect = coordSys.getBoundingRect(); var nodeData = seriesModel.getData(); var graph = nodeData.graph; var angle = 0; var sum = nodeData.getSum('value'); var unitAngle = Math.PI * 2 / (sum || nodeData.count()); var cx = rect.width / 2 + rect.x; var cy = rect.height / 2 + rect.y; var r = Math.min(rect.width, rect.height) / 2; graph.eachNode(function (node) { var value = node.getValue('value'); angle += unitAngle * (sum ? value : 1) / 2; node.setLayout([ r * Math.cos(angle) + cx, r * Math.sin(angle) + cy ]); angle += unitAngle * (sum ? value : 1) / 2; }); nodeData.setLayout({ cx: cx, cy: cy }); graph.eachEdge(function (edge) { var curveness = edge.getModel().get('lineStyle.normal.curveness') || 0; var p1 = vec2.clone(edge.node1.getLayout()); var p2 = vec2.clone(edge.node2.getLayout()); var cp1; var x12 = (p1[0] + p2[0]) / 2; var y12 = (p1[1] + p2[1]) / 2; if (+curveness) { curveness *= 3; cp1 = [ cx * curveness + x12 * (1 - curveness), cy * curveness + y12 * (1 - curveness) ]; } edge.setLayout([p1, p2, cp1]); }); }; /***/ }), /* 226 */ /***/ (function(module, exports, __webpack_require__) { var forceHelper = __webpack_require__(227); var numberUtil = __webpack_require__(7); var simpleLayoutHelper = __webpack_require__(222); var circularLayoutHelper = __webpack_require__(225); var vec2 = __webpack_require__(10); var zrUtil = __webpack_require__(4); module.exports = function (ecModel) { ecModel.eachSeriesByType('graph', function (graphSeries) { var coordSys = graphSeries.coordinateSystem; if (coordSys && coordSys.type !== 'view') { return; } if (graphSeries.get('layout') === 'force') { var preservedPoints = graphSeries.preservedPoints || {}; var graph = graphSeries.getGraph(); var nodeData = graph.data; var edgeData = graph.edgeData; var forceModel = graphSeries.getModel('force'); var initLayout = forceModel.get('initLayout'); if (graphSeries.preservedPoints) { nodeData.each(function (idx) { var id = nodeData.getId(idx); nodeData.setItemLayout(idx, preservedPoints[id] || [NaN, NaN]); }); } else if (!initLayout || initLayout === 'none') { simpleLayoutHelper(graphSeries); } else if (initLayout === 'circular') { circularLayoutHelper(graphSeries); } var nodeDataExtent = nodeData.getDataExtent('value'); var edgeDataExtent = edgeData.getDataExtent('value'); // var edgeDataExtent = edgeData.getDataExtent('value'); var repulsion = forceModel.get('repulsion'); var edgeLength = forceModel.get('edgeLength'); if (!zrUtil.isArray(repulsion)) { repulsion = [repulsion, repulsion]; } if (!zrUtil.isArray(edgeLength)) { edgeLength = [edgeLength, edgeLength]; } // Larger value has smaller length edgeLength = [edgeLength[1], edgeLength[0]]; var nodes = nodeData.mapArray('value', function (value, idx) { var point = nodeData.getItemLayout(idx); // var w = numberUtil.linearMap(value, nodeDataExtent, [0, 50]); var rep = numberUtil.linearMap(value, nodeDataExtent, repulsion); if (isNaN(rep)) { rep = (repulsion[0] + repulsion[1]) / 2; } return { w: rep, rep: rep, fixed: nodeData.getItemModel(idx).get('fixed'), p: (!point || isNaN(point[0]) || isNaN(point[1])) ? null : point }; }); var edges = edgeData.mapArray('value', function (value, idx) { var edge = graph.getEdgeByIndex(idx); var d = numberUtil.linearMap(value, edgeDataExtent, edgeLength); if (isNaN(d)) { d = (edgeLength[0] + edgeLength[1]) / 2; } return { n1: nodes[edge.node1.dataIndex], n2: nodes[edge.node2.dataIndex], d: d, curveness: edge.getModel().get('lineStyle.normal.curveness') || 0 }; }); var coordSys = graphSeries.coordinateSystem; var rect = coordSys.getBoundingRect(); var forceInstance = forceHelper(nodes, edges, { rect: rect, gravity: forceModel.get('gravity') }); var oldStep = forceInstance.step; forceInstance.step = function (cb) { for (var i = 0, l = nodes.length; i < l; i++) { if (nodes[i].fixed) { // Write back to layout instance vec2.copy(nodes[i].p, graph.getNodeByIndex(i).getLayout()); } } oldStep(function (nodes, edges, stopped) { for (var i = 0, l = nodes.length; i < l; i++) { if (!nodes[i].fixed) { graph.getNodeByIndex(i).setLayout(nodes[i].p); } preservedPoints[nodeData.getId(i)] = nodes[i].p; } for (var i = 0, l = edges.length; i < l; i++) { var e = edges[i]; var edge = graph.getEdgeByIndex(i); var p1 = e.n1.p; var p2 = e.n2.p; var points = edge.getLayout(); points = points ? points.slice() : []; points[0] = points[0] || []; points[1] = points[1] || []; vec2.copy(points[0], p1); vec2.copy(points[1], p2); if (+e.curveness) { points[2] = [ (p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * e.curveness, (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * e.curveness ]; } edge.setLayout(points); } // Update layout cb && cb(stopped); }); }; graphSeries.forceLayout = forceInstance; graphSeries.preservedPoints = preservedPoints; // Step to get the layout forceInstance.step(); } else { // Remove prev injected forceLayout instance graphSeries.forceLayout = null; } }); }; /***/ }), /* 227 */ /***/ (function(module, exports, __webpack_require__) { var vec2 = __webpack_require__(10); var scaleAndAdd = vec2.scaleAndAdd; // function adjacentNode(n, e) { // return e.n1 === n ? e.n2 : e.n1; // } module.exports = function (nodes, edges, opts) { var rect = opts.rect; var width = rect.width; var height = rect.height; var center = [rect.x + width / 2, rect.y + height / 2]; // var scale = opts.scale || 1; var gravity = opts.gravity == null ? 0.1 : opts.gravity; // for (var i = 0; i < edges.length; i++) { // var e = edges[i]; // var n1 = e.n1; // var n2 = e.n2; // n1.edges = n1.edges || []; // n2.edges = n2.edges || []; // n1.edges.push(e); // n2.edges.push(e); // } // Init position for (var i = 0; i < nodes.length; i++) { var n = nodes[i]; if (!n.p) { // Use the position from first adjecent node with defined position // Or use a random position // From d3 // if (n.edges) { // var j = -1; // while (++j < n.edges.length) { // var e = n.edges[j]; // var other = adjacentNode(n, e); // if (other.p) { // n.p = vec2.clone(other.p); // break; // } // } // } // if (!n.p) { n.p = vec2.create( width * (Math.random() - 0.5) + center[0], height * (Math.random() - 0.5) + center[1] ); // } } n.pp = vec2.clone(n.p); n.edges = null; } // Formula in 'Graph Drawing by Force-directed Placement' // var k = scale * Math.sqrt(width * height / nodes.length); // var k2 = k * k; var friction = 0.6; return { warmUp: function () { friction = 0.5; }, setFixed: function (idx) { nodes[idx].fixed = true; }, setUnfixed: function (idx) { nodes[idx].fixed = false; }, step: function (cb) { var v12 = []; var nLen = nodes.length; for (var i = 0; i < edges.length; i++) { var e = edges[i]; var n1 = e.n1; var n2 = e.n2; vec2.sub(v12, n2.p, n1.p); var d = vec2.len(v12) - e.d; var w = n2.w / (n1.w + n2.w); vec2.normalize(v12, v12); !n1.fixed && scaleAndAdd(n1.p, n1.p, v12, w * d * friction); !n2.fixed && scaleAndAdd(n2.p, n2.p, v12, -(1 - w) * d * friction); } // Gravity for (var i = 0; i < nLen; i++) { var n = nodes[i]; if (!n.fixed) { vec2.sub(v12, center, n.p); // var d = vec2.len(v12); // vec2.scale(v12, v12, 1 / d); // var gravityFactor = gravity; vec2.scaleAndAdd(n.p, n.p, v12, gravity * friction); } } // Repulsive // PENDING for (var i = 0; i < nLen; i++) { var n1 = nodes[i]; for (var j = i + 1; j < nLen; j++) { var n2 = nodes[j]; vec2.sub(v12, n2.p, n1.p); var d = vec2.len(v12); if (d === 0) { // Random repulse vec2.set(v12, Math.random() - 0.5, Math.random() - 0.5); d = 1; } var repFact = (n1.rep + n2.rep) / d / d; !n1.fixed && scaleAndAdd(n1.pp, n1.pp, v12, repFact); !n2.fixed && scaleAndAdd(n2.pp, n2.pp, v12, -repFact); } } var v = []; for (var i = 0; i < nLen; i++) { var n = nodes[i]; if (!n.fixed) { vec2.sub(v, n.p, n.pp); vec2.scaleAndAdd(n.p, n.p, v, friction); vec2.copy(n.pp, n.p); } } friction = friction * 0.992; cb && cb(nodes, edges, friction < 0.01); } }; }; /***/ }), /* 228 */ /***/ (function(module, exports, __webpack_require__) { // FIXME Where to create the simple view coordinate system var View = __webpack_require__(179); var layout = __webpack_require__(74); var bbox = __webpack_require__(41); function getViewRect(seriesModel, api, aspect) { var option = seriesModel.getBoxLayoutParams(); option.aspect = aspect; return layout.getLayoutRect(option, { width: api.getWidth(), height: api.getHeight() }); } module.exports = function (ecModel, api) { var viewList = []; ecModel.eachSeriesByType('graph', function (seriesModel) { var coordSysType = seriesModel.get('coordinateSystem'); if (!coordSysType || coordSysType === 'view') { var data = seriesModel.getData(); var positions = data.mapArray(function (idx) { var itemModel = data.getItemModel(idx); return [+itemModel.get('x'), +itemModel.get('y')]; }); var min = []; var max = []; bbox.fromPoints(positions, min, max); // If width or height is 0 if (max[0] - min[0] === 0) { max[0] += 1; min[0] -= 1; } if (max[1] - min[1] === 0) { max[1] += 1; min[1] -= 1; } var aspect = (max[0] - min[0]) / (max[1] - min[1]); // FIXME If get view rect after data processed? var viewRect = getViewRect(seriesModel, api, aspect); // Position may be NaN, use view rect instead if (isNaN(aspect)) { min = [viewRect.x, viewRect.y]; max = [viewRect.x + viewRect.width, viewRect.y + viewRect.height]; } var bbWidth = max[0] - min[0]; var bbHeight = max[1] - min[1]; var viewWidth = viewRect.width; var viewHeight = viewRect.height; var viewCoordSys = seriesModel.coordinateSystem = new View(); viewCoordSys.zoomLimit = seriesModel.get('scaleLimit'); viewCoordSys.setBoundingRect( min[0], min[1], bbWidth, bbHeight ); viewCoordSys.setViewRect( viewRect.x, viewRect.y, viewWidth, viewHeight ); // Update roam info viewCoordSys.setCenter(seriesModel.get('center')); viewCoordSys.setZoom(seriesModel.get('zoom')); viewList.push(viewCoordSys); } }); return viewList; }; /***/ }), /* 229 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(230); __webpack_require__(231); /***/ }), /* 230 */ /***/ (function(module, exports, __webpack_require__) { var List = __webpack_require__(101); var SeriesModel = __webpack_require__(83); var zrUtil = __webpack_require__(4); var GaugeSeries = SeriesModel.extend({ type: 'series.gauge', getInitialData: function (option, ecModel) { var list = new List(['value'], this); var dataOpt = option.data || []; if (!zrUtil.isArray(dataOpt)) { dataOpt = [dataOpt]; } // Only use the first data item list.initData(dataOpt); return list; }, defaultOption: { zlevel: 0, z: 2, // 默认全局居中 center: ['50%', '50%'], legendHoverLink: true, radius: '75%', startAngle: 225, endAngle: -45, clockwise: true, // 最小值 min: 0, // 最大值 max: 100, // 分割段数，默认为10 splitNumber: 10, // 坐标轴线 axisLine: { // 默认显示，属性show控制显示与否 show: true, lineStyle: { // 属性lineStyle控制线条样式 color: [[0.2, '#91c7ae'], [0.8, '#63869e'], [1, '#c23531']], width: 30 } }, // 分隔线 splitLine: { // 默认显示，属性show控制显示与否 show: true, // 属性length控制线长 length: 30, // 属性lineStyle（详见lineStyle）控制线条样式 lineStyle: { color: '#eee', width: 2, type: 'solid' } }, // 坐标轴小标记 axisTick: { // 属性show控制显示与否，默认不显示 show: true, // 每份split细分多少段 splitNumber: 5, // 属性length控制线长 length: 8, // 属性lineStyle控制线条样式 lineStyle: { color: '#eee', width: 1, type: 'solid' } }, axisLabel: { show: true, distance: 5, // formatter: null, color: 'auto' }, pointer: { show: true, length: '80%', width: 8 }, itemStyle: { normal: { color: 'auto' } }, title: { show: true, // x, y，单位px offsetCenter: [0, '-40%'], // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#333', fontSize: 15 }, detail: { show: true, backgroundColor: 'rgba(0,0,0,0)', borderWidth: 0, borderColor: '#ccc', width: 100, height: null, // self-adaption padding: [5, 10], // x, y，单位px offsetCenter: [0, '40%'], // formatter: null, // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: 'auto', fontSize: 30 } } }); module.exports = GaugeSeries; /***/ }), /* 231 */ /***/ (function(module, exports, __webpack_require__) { var PointerPath = __webpack_require__(232); var graphic = __webpack_require__(20); var numberUtil = __webpack_require__(7); var parsePercent = numberUtil.parsePercent; function parsePosition(seriesModel, api) { var center = seriesModel.get('center'); var width = api.getWidth(); var height = api.getHeight(); var size = Math.min(width, height); var cx = parsePercent(center[0], api.getWidth()); var cy = parsePercent(center[1], api.getHeight()); var r = parsePercent(seriesModel.get('radius'), size / 2); return { cx: cx, cy: cy, r: r }; } function formatLabel(label, labelFormatter) { if (labelFormatter) { if (typeof labelFormatter === 'string') { label = labelFormatter.replace('{value}', label != null ? label : ''); } else if (typeof labelFormatter === 'function') { label = labelFormatter(label); } } return label; } var PI2 = Math.PI * 2; var GaugeView = __webpack_require__(85).extend({ type: 'gauge', render: function (seriesModel, ecModel, api) { this.group.removeAll(); var colorList = seriesModel.get('axisLine.lineStyle.color'); var posInfo = parsePosition(seriesModel, api); this._renderMain( seriesModel, ecModel, api, colorList, posInfo ); }, dispose: function () {}, _renderMain: function (seriesModel, ecModel, api, colorList, posInfo) { var group = this.group; var axisLineModel = seriesModel.getModel('axisLine'); var lineStyleModel = axisLineModel.getModel('lineStyle'); var clockwise = seriesModel.get('clockwise'); var startAngle = -seriesModel.get('startAngle') / 180 * Math.PI; var endAngle = -seriesModel.get('endAngle') / 180 * Math.PI; var angleRangeSpan = (endAngle - startAngle) % PI2; var prevEndAngle = startAngle; var axisLineWidth = lineStyleModel.get('width'); for (var i = 0; i < colorList.length; i++) { // Clamp var percent = Math.min(Math.max(colorList[i][0], 0), 1); var endAngle = startAngle + angleRangeSpan * percent; var sector = new graphic.Sector({ shape: { startAngle: prevEndAngle, endAngle: endAngle, cx: posInfo.cx, cy: posInfo.cy, clockwise: clockwise, r0: posInfo.r - axisLineWidth, r: posInfo.r }, silent: true }); sector.setStyle({ fill: colorList[i][1] }); sector.setStyle(lineStyleModel.getLineStyle( // Because we use sector to simulate arc // so the properties for stroking are useless ['color', 'borderWidth', 'borderColor'] )); group.add(sector); prevEndAngle = endAngle; } var getColor = function (percent) { // Less than 0 if (percent = r / 3 ? 1 : 2); angle = shape.angle - Math.PI / 2; ctx.moveTo(x, y); ctx.lineTo( shape.x + mathCos(angle) * width, shape.y + mathSin(angle) * width ); ctx.lineTo( shape.x + mathCos(shape.angle) * r, shape.y + mathSin(shape.angle) * r ); ctx.lineTo( shape.x - mathCos(angle) * width, shape.y - mathSin(angle) * width ); ctx.lineTo(x, y); return; } }); /***/ }), /* 233 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); var echarts = __webpack_require__(1); __webpack_require__(234); __webpack_require__(235); echarts.registerVisual(zrUtil.curry(__webpack_require__(154), 'funnel')); echarts.registerLayout(__webpack_require__(236)); echarts.registerProcessor(zrUtil.curry(__webpack_require__(157), 'funnel')); /***/ }), /* 234 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var List = __webpack_require__(101); var modelUtil = __webpack_require__(5); var completeDimensions = __webpack_require__(113); var FunnelSeries = __webpack_require__(1).extendSeriesModel({ type: 'series.funnel', init: function (option) { FunnelSeries.superApply(this, 'init', arguments); // Enable legend selection for each data item // Use a function instead of direct access because data reference may changed this.legendDataProvider = function () { return this.getRawData(); }; // Extend labelLine emphasis this._defaultLabelLine(option); }, getInitialData: function (option, ecModel) { var dimensions = completeDimensions(['value'], option.data); var list = new List(dimensions, this); list.initData(option.data); return list; }, _defaultLabelLine: function (option) { // Extend labelLine emphasis modelUtil.defaultEmphasis(option.labelLine, ['show']); var labelLineNormalOpt = option.labelLine.normal; var labelLineEmphasisOpt = option.labelLine.emphasis; // Not show label line if `label.normal.show = false` labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.normal.show; labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.label.emphasis.show; }, // Overwrite getDataParams: function (dataIndex) { var data = this.getData(); var params = FunnelSeries.superCall(this, 'getDataParams', dataIndex); var sum = data.getSum('value'); // Percent is 0 if sum is 0 params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2); params.$vars.push('percent'); return params; }, defaultOption: { zlevel: 0, // 一级层叠 z: 2, // 二级层叠 legendHoverLink: true, left: 80, top: 60, right: 80, bottom: 60, // width: {totalWidth} - left - right, // height: {totalHeight} - top - bottom, // 默认取数据最小最大值 // min: 0, // max: 100, minSize: '0%', maxSize: '100%', sort: 'descending', // 'ascending', 'descending' gap: 0, funnelAlign: 'center', label: { normal: { show: true, position: 'outer' // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调 }, emphasis: { show: true } }, labelLine: { normal: { show: true, length: 20, lineStyle: { // color: 各异, width: 1, type: 'solid' } }, emphasis: {} }, itemStyle: { normal: { // color: 各异, borderColor: '#fff', borderWidth: 1 }, emphasis: { // color: 各异, } } } }); module.exports = FunnelSeries; /***/ }), /* 235 */ /***/ (function(module, exports, __webpack_require__) { var graphic = __webpack_require__(20); var zrUtil = __webpack_require__(4); /** * Piece of pie including Sector, Label, LabelLine * @constructor * @extends {module:zrender/graphic/Group} */ function FunnelPiece(data, idx) { graphic.Group.call(this); var polygon = new graphic.Polygon(); var labelLine = new graphic.Polyline(); var text = new graphic.Text(); this.add(polygon); this.add(labelLine); this.add(text); this.updateData(data, idx, true); // Hover to change label and labelLine function onEmphasis() { labelLine.ignore = labelLine.hoverIgnore; text.ignore = text.hoverIgnore; } function onNormal() { labelLine.ignore = labelLine.normalIgnore; text.ignore = text.normalIgnore; } this.on('emphasis', onEmphasis) .on('normal', onNormal) .on('mouseover', onEmphasis) .on('mouseout', onNormal); } var funnelPieceProto = FunnelPiece.prototype; var opacityAccessPath = ['itemStyle', 'normal', 'opacity']; funnelPieceProto.updateData = function (data, idx, firstCreate) { var polygon = this.childAt(0); var seriesModel = data.hostModel; var itemModel = data.getItemModel(idx); var layout = data.getItemLayout(idx); var opacity = data.getItemModel(idx).get(opacityAccessPath); opacity = opacity == null ? 1 : opacity; // Reset style polygon.useStyle({}); if (firstCreate) { polygon.setShape({ points: layout.points }); polygon.setStyle({ opacity : 0 }); graphic.initProps(polygon, { style: { opacity: opacity } }, seriesModel, idx); } else { graphic.updateProps(polygon, { style: { opacity: opacity }, shape: { points: layout.points } }, seriesModel, idx); } // Update common style var itemStyleModel = itemModel.getModel('itemStyle'); var visualColor = data.getItemVisual(idx, 'color'); polygon.setStyle( zrUtil.defaults( { lineJoin: 'round', fill: visualColor }, itemStyleModel.getModel('normal').getItemStyle(['opacity']) ) ); polygon.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle(); this._updateLabel(data, idx); graphic.setHoverStyle(this); }; funnelPieceProto._updateLabel = function (data, idx) { var labelLine = this.childAt(1); var labelText = this.childAt(2); var seriesModel = data.hostModel; var itemModel = data.getItemModel(idx); var layout = data.getItemLayout(idx); var labelLayout = layout.label; var visualColor = data.getItemVisual(idx, 'color'); graphic.updateProps(labelLine, { shape: { points: labelLayout.linePoints || labelLayout.linePoints } }, seriesModel, idx); graphic.updateProps(labelText, { style: { x: labelLayout.x, y: labelLayout.y } }, seriesModel, idx); labelText.attr({ rotation: labelLayout.rotation, origin: [labelLayout.x, labelLayout.y], z2: 10 }); var labelModel = itemModel.getModel('label.normal'); var labelHoverModel = itemModel.getModel('label.emphasis'); var labelLineModel = itemModel.getModel('labelLine.normal'); var labelLineHoverModel = itemModel.getModel('labelLine.emphasis'); var visualColor = data.getItemVisual(idx, 'color'); graphic.setLabelStyle( labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, { labelFetcher: data.hostModel, labelDataIndex: idx, defaultText: data.getName(idx), autoColor: visualColor, useInsideStyle: !!labelLayout.inside }, { textAlign: labelLayout.textAlign, textVerticalAlign: labelLayout.verticalAlign } ); labelText.ignore = labelText.normalIgnore = !labelModel.get('show'); labelText.hoverIgnore = !labelHoverModel.get('show'); labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show'); labelLine.hoverIgnore = !labelLineHoverModel.get('show'); // Default use item visual color labelLine.setStyle({ stroke: visualColor }); labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle()); labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle(); }; zrUtil.inherits(FunnelPiece, graphic.Group); var Funnel = __webpack_require__(85).extend({ type: 'funnel', render: function (seriesModel, ecModel, api) { var data = seriesModel.getData(); var oldData = this._data; var group = this.group; data.diff(oldData) .add(function (idx) { var funnelPiece = new FunnelPiece(data, idx); data.setItemGraphicEl(idx, funnelPiece); group.add(funnelPiece); }) .update(function (newIdx, oldIdx) { var piePiece = oldData.getItemGraphicEl(oldIdx); piePiece.updateData(data, newIdx); group.add(piePiece); data.setItemGraphicEl(newIdx, piePiece); }) .remove(function (idx) { var piePiece = oldData.getItemGraphicEl(idx); group.remove(piePiece); }) .execute(); this._data = data; }, remove: function () { this.group.removeAll(); this._data = null; }, dispose: function () {} }); module.exports = Funnel; /***/ }), /* 236 */ /***/ (function(module, exports, __webpack_require__) { var layout = __webpack_require__(74); var number = __webpack_require__(7); var parsePercent = number.parsePercent; function getViewRect(seriesModel, api) { return layout.getLayoutRect( seriesModel.getBoxLayoutParams(), { width: api.getWidth(), height: api.getHeight() } ); } function getSortedIndices(data, sort) { var valueArr = data.mapArray('value', function (val) { return val; }); var indices = []; var isAscending = sort === 'ascending'; for (var i = 0, len = data.count(); i < len; i++) { indices[i] = i; } // Add custom sortable function & none sortable opetion by \"options.sort\" if (typeof sort === 'function') { indices.sort(sort); } else if (sort !== 'none') { indices.sort(function (a, b) { return isAscending ? valueArr[a] - valueArr[b] : valueArr[b] - valueArr[a]; }); } return indices; } function labelLayout(data) { data.each(function (idx) { var itemModel = data.getItemModel(idx); var labelModel = itemModel.getModel('label.normal'); var labelPosition = labelModel.get('position'); var labelLineModel = itemModel.getModel('labelLine.normal'); var layout = data.getItemLayout(idx); var points = layout.points; var isLabelInside = labelPosition === 'inner' || labelPosition === 'inside' || labelPosition === 'center'; var textAlign; var textX; var textY; var linePoints; if (isLabelInside) { textX = (points[0][0] + points[1][0] + points[2][0] + points[3][0]) / 4; textY = (points[0][1] + points[1][1] + points[2][1] + points[3][1]) / 4; textAlign = 'center'; linePoints = [ [textX, textY], [textX, textY] ]; } else { var x1; var y1; var x2; var labelLineLen = labelLineModel.get('length'); if (labelPosition === 'left') { // Left side x1 = (points[3][0] + points[0][0]) / 2; y1 = (points[3][1] + points[0][1]) / 2; x2 = x1 - labelLineLen; textX = x2 - 5; textAlign = 'right'; } else { // Right side x1 = (points[1][0] + points[2][0]) / 2; y1 = (points[1][1] + points[2][1]) / 2; x2 = x1 + labelLineLen; textX = x2 + 5; textAlign = 'left'; } var y2 = y1; linePoints = [[x1, y1], [x2, y2]]; textY = y2; } layout.label = { linePoints: linePoints, x: textX, y: textY, verticalAlign: 'middle', textAlign: textAlign, inside: isLabelInside }; }); } module.exports = function (ecModel, api, payload) { ecModel.eachSeriesByType('funnel', function (seriesModel) { var data = seriesModel.getData(); var sort = seriesModel.get('sort'); var viewRect = getViewRect(seriesModel, api); var indices = getSortedIndices(data, sort); var sizeExtent = [ parsePercent(seriesModel.get('minSize'), viewRect.width), parsePercent(seriesModel.get('maxSize'), viewRect.width) ]; var dataExtent = data.getDataExtent('value'); var min = seriesModel.get('min'); var max = seriesModel.get('max'); if (min == null) { min = Math.min(dataExtent[0], 0); } if (max == null) { max = dataExtent[1]; } var funnelAlign = seriesModel.get('funnelAlign'); var gap = seriesModel.get('gap'); var itemHeight = (viewRect.height - gap * (data.count() - 1)) / data.count(); var y = viewRect.y; var getLinePoints = function (idx, offY) { // End point index is data.count() and we assign it 0 var val = data.get('value', idx) || 0; var itemWidth = number.linearMap(val, [min, max], sizeExtent, true); var x0; switch (funnelAlign) { case 'left': x0 = viewRect.x; break; case 'center': x0 = viewRect.x + (viewRect.width - itemWidth) / 2; break; case 'right': x0 = viewRect.x + viewRect.width - itemWidth; break; } return [ [x0, offY], [x0 + itemWidth, offY] ]; }; if (sort === 'ascending') { // From bottom to top itemHeight = -itemHeight; gap = -gap; y += viewRect.height; indices = indices.reverse(); } for (var i = 0; i < indices.length; i++) { var idx = indices[i]; var nextIdx = indices[i + 1]; var start = getLinePoints(idx, y); var end = getLinePoints(nextIdx, y + itemHeight); y += itemHeight + gap; data.setItemLayout(idx, { points: start.concat(end.slice().reverse()) }); } labelLayout(data); }); }; /***/ }), /* 237 */ /***/ (function(module, exports, __webpack_require__) { var echarts = __webpack_require__(1); __webpack_require__(238); __webpack_require__(251); __webpack_require__(252); echarts.registerVisual(__webpack_require__(253)); /***/ }), /* 238 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(239); __webpack_require__(243); __webpack_require__(245); var echarts = __webpack_require__(1); var zrUtil = __webpack_require__(4); var throttle = __webpack_require__(86); var CLICK_THRESHOLD = 5; // > 4 // Parallel view echarts.extendComponentView({ type: 'parallel', render: function (parallelModel, ecModel, api) { this._model = parallelModel; this._api = api; if (!this._handlers) { this._handlers = {}; zrUtil.each(handlers, function (handler, eventName) { api.getZr().on(eventName, this._handlers[eventName] = zrUtil.bind(handler, this)); }, this); } throttle.createOrUpdate( this, '_throttledDispatchExpand', parallelModel.get('axisExpandRate'), 'fixRate' ); }, dispose: function (ecModel, api) { zrUtil.each(this._handlers, function (handler, eventName) { api.getZr().off(eventName, handler); }); this._handlers = null; }, /** * @param {Object} [opt] If null, cancle the last action triggering for debounce. */ _throttledDispatchExpand: function (opt) { this._dispatchExpand(opt); }, _dispatchExpand: function (opt) { opt && this._api.dispatchAction( zrUtil.extend({type: 'parallelAxisExpand'}, opt) ); } }); var handlers = { mousedown: function (e) { if (checkTrigger(this, 'click')) { this._mouseDownPoint = [e.offsetX, e.offsetY]; } }, mouseup: function (e) { var mouseDownPoint = this._mouseDownPoint; if (checkTrigger(this, 'click') && mouseDownPoint) { var point = [e.offsetX, e.offsetY]; var dist = Math.pow(mouseDownPoint[0] - point[0], 2) + Math.pow(mouseDownPoint[1] - point[1], 2); if (dist > CLICK_THRESHOLD) { return; } var result = this._model.coordinateSystem.getSlidedAxisExpandWindow( [e.offsetX, e.offsetY] ); result.behavior !== 'none' && this._dispatchExpand({ axisExpandWindow: result.axisExpandWindow }); } this._mouseDownPoint = null; }, mousemove: function (e) { // Should do nothing when brushing. if (this._mouseDownPoint || !checkTrigger(this, 'mousemove')) { return; } var model = this._model; var result = model.coordinateSystem.getSlidedAxisExpandWindow( [e.offsetX, e.offsetY] ); var behavior = result.behavior; behavior === 'jump' && this._throttledDispatchExpand.debounceNextCall(model.get('axisExpandDebounce')); this._throttledDispatchExpand( behavior === 'none' ? null // Cancle the last trigger, in case that mouse slide out of the area quickly. : { axisExpandWindow: result.axisExpandWindow, // Jumping uses animation, and sliding suppresses animation. animation: behavior === 'jump' ? null : false } ); } }; function checkTrigger(view, triggerOn) { var model = view._model; return model.get('axisExpandable') && model.get('axisExpandTriggerOn') === triggerOn; } echarts.registerPreprocessor( __webpack_require__(250) ); /***/ }), /* 239 */ /***/ (function(module, exports, __webpack_require__) { /** * Parallel coordinate system creater. */ var Parallel = __webpack_require__(240); function create(ecModel, api) { var coordSysList = []; ecModel.eachComponent('parallel', function (parallelModel, idx) { var coordSys = new Parallel(parallelModel, ecModel, api); coordSys.name = 'parallel_' + idx; coordSys.resize(parallelModel, api); parallelModel.coordinateSystem = coordSys; coordSys.model = parallelModel; coordSysList.push(coordSys); }); // Inject the coordinateSystems into seriesModel ecModel.eachSeries(function (seriesModel) { if (seriesModel.get('coordinateSystem') === 'parallel') { var parallelModel = ecModel.queryComponents({ mainType: 'parallel', index: seriesModel.get('parallelIndex'), id: seriesModel.get('parallelId') })[0]; seriesModel.coordinateSystem = parallelModel.coordinateSystem; } }); return coordSysList; } __webpack_require__(79).register('parallel', {create: create}); /***/ }), /* 240 */ /***/ (function(module, exports, __webpack_require__) { /** * Parallel Coordinates * */ var layoutUtil = __webpack_require__(74); var axisHelper = __webpack_require__(104); var zrUtil = __webpack_require__(4); var ParallelAxis = __webpack_require__(241); var graphic = __webpack_require__(20); var matrix = __webpack_require__(11); var numberUtil = __webpack_require__(7); var sliderMove = __webpack_require__(242); var each = zrUtil.each; var mathMin = Math.min; var mathMax = Math.max; var mathFloor = Math.floor; var mathCeil = Math.ceil; var round = numberUtil.round; var PI = Math.PI; function Parallel(parallelModel, ecModel, api) { /** * key: dimension * @type {Object.} * @private */ this._axesMap = zrUtil.createHashMap(); /** * key: dimension * value: {position: [], rotation, } * @type {Object.} * @private */ this._axesLayout = {}; /** * Always follow axis order. * @type {Array.} * @readOnly */ this.dimensions = parallelModel.dimensions; /** * @type {module:zrender/core/BoundingRect} */ this._rect; /** * @type {module:echarts/coord/parallel/ParallelModel} */ this._model = parallelModel; this._init(parallelModel, ecModel, api); } Parallel.prototype = { type: 'parallel', constructor: Parallel, /** * Initialize cartesian coordinate systems * @private */ _init: function (parallelModel, ecModel, api) { var dimensions = parallelModel.dimensions; var parallelAxisIndex = parallelModel.parallelAxisIndex; each(dimensions, function (dim, idx) { var axisIndex = parallelAxisIndex[idx]; var axisModel = ecModel.getComponent('parallelAxis', axisIndex); var axis = this._axesMap.set(dim, new ParallelAxis( dim, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisIndex )); var isCategory = axis.type === 'category'; axis.onBand = isCategory && axisModel.get('boundaryGap'); axis.inverse = axisModel.get('inverse'); // Injection axisModel.axis = axis; axis.model = axisModel; axis.coordinateSystem = axisModel.coordinateSystem = this; }, this); }, /** * Update axis scale after data processed * @param {module:echarts/model/Global} ecModel * @param {module:echarts/ExtensionAPI} api */ update: function (ecModel, api) { this._updateAxesFromSeries(this._model, ecModel); }, /** * @override */ containPoint: function (point) { var layoutInfo = this._makeLayoutInfo(); var axisBase = layoutInfo.axisBase; var layoutBase = layoutInfo.layoutBase; var pixelDimIndex = layoutInfo.pixelDimIndex; var pAxis = point[1 - pixelDimIndex]; var pLayout = point[pixelDimIndex]; return pAxis >= axisBase && pAxis = layoutBase && pLayout 3 && axisCount > axisExpandCount && axisExpandCount > 1 && axisExpandWidth > 0 && layoutLength > 0; // `axisExpandWindow` is According to the coordinates of [0, axisExpandLength], // for sake of consider the case that axisCollapseWidth is 0 (when screen is narrow), // where collapsed axes should be overlapped. var axisExpandWindow = parallelModel.get('axisExpandWindow'); var winSize; if (!axisExpandWindow) { winSize = restrict(axisExpandWidth * (axisExpandCount - 1), layoutExtent); var axisExpandCenter = parallelModel.get('axisExpandCenter') || mathFloor(axisCount / 2); axisExpandWindow = [axisExpandWidth * axisExpandCenter - winSize / 2]; axisExpandWindow[1] = axisExpandWindow[0] + winSize; } else { winSize = restrict(axisExpandWindow[1] - axisExpandWindow[0], layoutExtent); axisExpandWindow[1] = axisExpandWindow[0] + winSize; } var axisCollapseWidth = (layoutLength - winSize) / (axisCount - axisExpandCount); // Avoid axisCollapseWidth is too small. axisCollapseWidth < 3 && (axisCollapseWidth = 0); // Find the first and last indices > ewin[0] and < ewin[1]. var winInnerIndices = [ mathFloor(round(axisExpandWindow[0] / axisExpandWidth, 1)) + 1, mathCeil(round(axisExpandWindow[1] / axisExpandWidth, 1)) - 1 ]; // Pos in ec coordinates. var axisExpandWindow0Pos = axisCollapseWidth / axisExpandWidth * axisExpandWindow[0]; return { layout: layout, pixelDimIndex: pixelDimIndex, layoutBase: rect[xy[pixelDimIndex]], layoutLength: layoutLength, axisBase: rect[xy[1 - pixelDimIndex]], axisLength: rect[wh[1 - pixelDimIndex]], axisExpandable: axisExpandable, axisExpandWidth: axisExpandWidth, axisCollapseWidth: axisCollapseWidth, axisExpandWindow: axisExpandWindow, axisCount: axisCount, winInnerIndices: winInnerIndices, axisExpandWindow0Pos: axisExpandWindow0Pos }; }, /** * @private */ _layoutAxes: function () { var rect = this._rect; var axes = this._axesMap; var dimensions = this.dimensions; var layoutInfo = this._makeLayoutInfo(); var layout = layoutInfo.layout; axes.each(function (axis) { var axisExtent = [0, layoutInfo.axisLength]; var idx = axis.inverse ? 1 : 0; axis.setExtent(axisExtent[idx], axisExtent[1 - idx]); }); each(dimensions, function (dim, idx) { var posInfo = (layoutInfo.axisExpandable ? layoutAxisWithExpand : layoutAxisWithoutExpand )(idx, layoutInfo); var positionTable = { horizontal: { x: posInfo.position, y: layoutInfo.axisLength }, vertical: { x: 0, y: posInfo.position } }; var rotationTable = { horizontal: PI / 2, vertical: 0 }; var position = [ positionTable[layout].x + rect.x, positionTable[layout].y + rect.y ]; var rotation = rotationTable[layout]; var transform = matrix.create(); matrix.rotate(transform, transform, rotation); matrix.translate(transform, transform, position); // TODO // tick等排布信息。 // TODO // 根据axis order 更新 dimensions顺序。 this._axesLayout[dim] = { position: position, rotation: rotation, transform: transform, axisNameAvailableWidth: posInfo.axisNameAvailableWidth, axisLabelShow: posInfo.axisLabelShow, nameTruncateMaxWidth: posInfo.nameTruncateMaxWidth, tickDirection: 1, labelDirection: 1, labelInterval: axes.get(dim).getLabelInterval() }; }, this); }, /** * Get axis by dim. * @param {string} dim * @return {module:echarts/coord/parallel/ParallelAxis} [description] */ getAxis: function (dim) { return this._axesMap.get(dim); }, /** * Convert a dim value of a single item of series data to Point. * @param {*} value * @param {string} dim * @return {Array} */ dataToPoint: function (value, dim) { return this.axisCoordToPoint( this._axesMap.get(dim).dataToCoord(value), dim ); }, /** * Travel data for one time, get activeState of each data item. * @param {module:echarts/data/List} data * @param {Functio} cb param: {string} activeState 'active' or 'inactive' or 'normal' * {number} dataIndex * @param {Object} context */ eachActiveState: function (data, callback, context) { var dimensions = this.dimensions; var axesMap = this._axesMap; var hasActiveSet = this.hasAxisBrushed(); for (var i = 0, len = data.count(); i < len; i++) { var values = data.getValues(dimensions, i); var activeState; if (!hasActiveSet) { activeState = 'normal'; } else { activeState = 'active'; for (var j = 0, lenj = dimensions.length; j < lenj; j++) { var dimName = dimensions[j]; var state = axesMap.get(dimName).model.getActiveState(values[j], j); if (state === 'inactive') { activeState = 'inactive'; break; } } } callback.call(context, activeState, i); } }, /** * Whether has any activeSet. * @return {boolean} */ hasAxisBrushed: function () { var dimensions = this.dimensions; var axesMap = this._axesMap; var hasActiveSet = false; for (var j = 0, lenj = dimensions.length; j < lenj; j++) { if (axesMap.get(dimensions[j]).model.getActiveState() !== 'normal') { hasActiveSet = true; } } return hasActiveSet; }, /** * Convert coords of each axis to Point. * Return point. For example: [10, 20] * @param {Array.} coords * @param {string} dim * @return {Array.} */ axisCoordToPoint: function (coord, dim) { var axisLayout = this._axesLayout[dim]; return graphic.applyTransform([coord, 0], axisLayout.transform); }, /** * Get axis layout. */ getAxisLayout: function (dim) { return zrUtil.clone(this._axesLayout[dim]); }, /** * @param {Array.} point * @return {Object} {axisExpandWindow, delta, behavior: 'jump' | 'slide' | 'none'}. */ getSlidedAxisExpandWindow: function (point) { var layoutInfo = this._makeLayoutInfo(); var pixelDimIndex = layoutInfo.pixelDimIndex; var axisExpandWindow = layoutInfo.axisExpandWindow.slice(); var winSize = axisExpandWindow[1] - axisExpandWindow[0]; var extent = [0, layoutInfo.axisExpandWidth * (layoutInfo.axisCount - 1)]; // Out of the area of coordinate system. if (!this.containPoint(point)) { return {behavior: 'none', axisExpandWindow: axisExpandWindow}; } // Conver the point from global to expand coordinates. var pointCoord = point[pixelDimIndex] - layoutInfo.layoutBase - layoutInfo.axisExpandWindow0Pos; // For dragging operation convenience, the window should not be // slided when mouse is the center area of the window. var delta; var behavior = 'slide'; var axisCollapseWidth = layoutInfo.axisCollapseWidth; var triggerArea = this._model.get('axisExpandSlideTriggerArea'); // But consider touch device, jump is necessary. var useJump = triggerArea[0] != null; if (axisCollapseWidth) { if (useJump && axisCollapseWidth && pointCoord < winSize * triggerArea[0]) { behavior = 'jump'; delta = pointCoord - winSize * triggerArea[2]; } else if (useJump && axisCollapseWidth && pointCoord > winSize * (1 - triggerArea[0])) { behavior = 'jump'; delta = pointCoord - winSize * (1 - triggerArea[2]); } else { (delta = pointCoord - winSize * triggerArea[1]) >= 0 && (delta = pointCoord - winSize * (1 - triggerArea[1])) 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1}; } function restrict(value, extend) { return Math.min(extend[1], Math.max(extend[0], value)); } /***/ }), /* 243 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); var Component = __webpack_require__(72); __webpack_require__(244); Component.extend({ type: 'parallel', dependencies: ['parallelAxis'], /** * @type {module:echarts/coord/parallel/Parallel} */ coordinateSystem: null, /** * Each item like: 'dim0', 'dim1', 'dim2', ... * @type {Array.} * @readOnly */ dimensions: null, /** * Coresponding to dimensions. * @type {Array.} * @readOnly */ parallelAxisIndex: null, layoutMode: 'box', defaultOption: { zlevel: 0, z: 0, left: 80, top: 60, right: 80, bottom: 60, // width: {totalWidth} - left - right, // height: {totalHeight} - top - bottom, layout: 'horizontal', // 'horizontal' or 'vertical' // FIXME // naming? axisExpandable: false, axisExpandCenter: null, axisExpandCount: 0, axisExpandWidth: 50, // FIXME '10%' ? axisExpandRate: 17, axisExpandDebounce: 50, // [out, in, jumpTarget]. In percentage. If use [null, 0.05], null means full. // Do not doc to user until necessary. axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4], axisExpandTriggerOn: 'click', // 'mousemove' or 'click' parallelAxisDefault: null }, /** * @override */ init: function () { Component.prototype.init.apply(this, arguments); this.mergeOption({}); }, /** * @override */ mergeOption: function (newOption) { var thisOption = this.option; newOption && zrUtil.merge(thisOption, newOption, true); this._initDimensions(); }, /** * Whether series or axis is in this coordinate system. * @param {module:echarts/model/Series|module:echarts/coord/parallel/AxisModel} model * @param {module:echarts/model/Global} ecModel */ contains: function (model, ecModel) { var parallelIndex = model.get('parallelIndex'); return parallelIndex != null && ecModel.getComponent('parallel', parallelIndex) === this; }, setAxisExpand: function (opt) { zrUtil.each( ['axisExpandable', 'axisExpandCenter', 'axisExpandCount', 'axisExpandWidth', 'axisExpandWindow'], function (name) { if (opt.hasOwnProperty(name)) { this.option[name] = opt[name]; } }, this ); }, /** * @private */ _initDimensions: function () { var dimensions = this.dimensions = []; var parallelAxisIndex = this.parallelAxisIndex = []; var axisModels = zrUtil.filter(this.dependentModels.parallelAxis, function (axisModel) { // Can not use this.contains here, because // initialization has not been completed yet. return axisModel.get('parallelIndex') === this.componentIndex; }); zrUtil.each(axisModels, function (axisModel) { dimensions.push('dim' + axisModel.get('dim')); parallelAxisIndex.push(axisModel.componentIndex); }); } }); /***/ }), /* 244 */ /***/ (function(module, exports, __webpack_require__) { var ComponentModel = __webpack_require__(72); var zrUtil = __webpack_require__(4); var makeStyleMapper = __webpack_require__(17); var axisModelCreator = __webpack_require__(134); var numberUtil = __webpack_require__(7); var AxisModel = ComponentModel.extend({ type: 'baseParallelAxis', /** * @type {module:echarts/coord/parallel/Axis} */ axis: null, /** * @type {Array.= 0; i--) { numberUtil.asc(activeIntervals[i]); } } }, /** * @param {number|string} [value] When attempting to detect 'no activeIntervals set', * value can not be input. * @return {string} 'normal': no activeIntervals set, * 'active', * 'inactive'. * @public */ getActiveState: function (value) { var activeIntervals = this.activeIntervals; if (!activeIntervals.length) { return 'normal'; } if (value == null) { return 'inactive'; } for (var i = 0, len = activeIntervals.length; i < len; i++) { if (activeIntervals[i][0] 1) { localDirection = localDirection.split(''); var globalDir = [ getGlobalDirection(controller, localDirection[0]), getGlobalDirection(controller, localDirection[1]) ]; (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse(); return globalDir.join(''); } else { var map = {w: 'left', e: 'right', n: 'top', s: 'bottom'}; var inverseMap = {left: 'w', right: 'e', top: 'n', bottom: 's'}; var globalDir = graphic.transformDirection( map[localDirection], getTransform(controller) ); return inverseMap[globalDir]; } } function driftRect(toRectRange, fromRectRange, controller, cover, name, dx, dy, e) { var brushOption = cover.__brushOption; var rectRange = toRectRange(brushOption.range); var localDelta = toLocalDelta(controller, dx, dy); each(name.split(''), function (namePart) { var ind = DIRECTION_MAP[namePart]; rectRange[ind[0]][ind[1]] += localDelta[ind[0]]; }); brushOption.range = fromRectRange(formatRectRange( rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1] )); updateCoverAfterCreation(controller, cover); trigger(controller, {isEnd: false}); } function driftPolygon(controller, cover, dx, dy, e) { var range = cover.__brushOption.range; var localDelta = toLocalDelta(controller, dx, dy); each(range, function (point) { point[0] += localDelta[0]; point[1] += localDelta[1]; }); updateCoverAfterCreation(controller, cover); trigger(controller, {isEnd: false}); } function toLocalDelta(controller, dx, dy) { var thisGroup = controller.group; var localD = thisGroup.transformCoordToLocal(dx, dy); var localZero = thisGroup.transformCoordToLocal(0, 0); return [localD[0] - localZero[0], localD[1] - localZero[1]]; } function clipByPanel(controller, cover, data) { var panel = getPanelByCover(controller, cover); return (panel && panel !== true) ? panel.clipPath(data, controller._transform) : zrUtil.clone(data); } function pointsToRect(points) { var xmin = mathMin(points[0][0], points[1][0]); var ymin = mathMin(points[0][1], points[1][1]); var xmax = mathMax(points[0][0], points[1][0]); var ymax = mathMax(points[0][1], points[1][1]); return { x: xmin, y: ymin, width: xmax - xmin, height: ymax - ymin }; } function resetCursor(controller, e, localCursorPoint) { // Check active if (!controller._brushType) { return; } var zr = controller._zr; var covers = controller._covers; var currPanel = getPanelByPoint(controller, e, localCursorPoint); // Check whether in covers. if (!controller._dragging) { for (var i = 0; i < covers.length; i++) { var brushOption = covers[i].__brushOption; if (currPanel && (currPanel === true || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain( covers[i], localCursorPoint[0], localCursorPoint[1] ) ) { // Use cursor style set on cover. return; } } } currPanel && zr.setCursorStyle('crosshair'); } function preventDefault(e) { var rawE = e.event; rawE.preventDefault && rawE.preventDefault(); } function mainShapeContain(cover, x, y) { return cover.childOfName('main').contain(x, y); } function updateCoverByMouse(controller, e, localCursorPoint, isEnd) { var creatingCover = controller._creatingCover; var panel = controller._creatingPanel; var thisBrushOption = controller._brushOption; var eventParams; controller._track.push(localCursorPoint.slice()); if (shouldShowCover(controller) || creatingCover) { if (panel && !creatingCover) { thisBrushOption.brushMode === 'single' && clearCovers(controller); var brushOption = zrUtil.clone(thisBrushOption); brushOption.brushType = determineBrushType(brushOption.brushType, panel); brushOption.panelId = panel === true ? null : panel.panelId; creatingCover = controller._creatingCover = createCover(controller, brushOption); controller._covers.push(creatingCover); } if (creatingCover) { var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)]; var coverBrushOption = creatingCover.__brushOption; coverBrushOption.range = coverRenderer.getCreatingRange( clipByPanel(controller, creatingCover, controller._track) ); if (isEnd) { endCreating(controller, creatingCover); coverRenderer.updateCommon(controller, creatingCover); } updateCoverShape(controller, creatingCover); eventParams = {isEnd: isEnd}; } } else if ( isEnd && thisBrushOption.brushMode === 'single' && thisBrushOption.removeOnClick ) { // Help user to remove covers easily, only by a tiny drag, in 'single' mode. // But a single click do not clear covers, because user may have casual // clicks (for example, click on other component and do not expect covers // disappear). // Only some cover removed, trigger action, but not every click trigger action. if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) { eventParams = {isEnd: isEnd, removeOnClick: true}; } } return eventParams; } function determineBrushType(brushType, panel) { if (brushType === 'auto') { if (true) { zrUtil.assert( panel && panel.defaultBrushType, 'MUST have defaultBrushType when brushType is \"atuo\"' ); } return panel.defaultBrushType; } return brushType; } var mouseHandlers = { mousedown: function (e) { if (this._dragging) { // In case some browser do not support globalOut, // and release mose out side the browser. handleDragEnd.call(this, e); } else if (!e.target || !e.target.draggable) { preventDefault(e); var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY); this._creatingCover = null; var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint); if (panel) { this._dragging = true; this._track = [localCursorPoint.slice()]; } } }, mousemove: function (e) { var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY); resetCursor(this, e, localCursorPoint); if (this._dragging) { preventDefault(e); var eventParams = updateCoverByMouse(this, e, localCursorPoint, false); eventParams && trigger(this, eventParams); } }, mouseup: handleDragEnd //, // FIXME // in tooltip, globalout should not be triggered. // globalout: handleDragEnd }; function handleDragEnd(e) { if (this._dragging) { preventDefault(e); var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY); var eventParams = updateCoverByMouse(this, e, localCursorPoint, true); this._dragging = false; this._track = []; this._creatingCover = null; // trigger event shoule be at final, after procedure will be nested. eventParams && trigger(this, eventParams); } } /** * key: brushType * @type {Object} */ var coverRenderers = { lineX: getLineRenderer(0), lineY: getLineRenderer(1), rect: { createCover: function (controller, brushOption) { return createBaseRectCover( curry( driftRect, function (range) { return range; }, function (range) { return range; } ), controller, brushOption, ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'] ); }, getCreatingRange: function (localTrack) { var ends = getTrackEnds(localTrack); return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]); }, updateCoverShape: function (controller, cover, localRange, brushOption) { updateBaseRect(controller, cover, localRange, brushOption); }, updateCommon: updateCommon, contain: mainShapeContain }, polygon: { createCover: function (controller, brushOption) { var cover = new graphic.Group(); // Do not use graphic.Polygon because graphic.Polyline do not close the // border of the shape when drawing, which is a better experience for user. cover.add(new graphic.Polyline({ name: 'main', style: makeStyle(brushOption), silent: true })); return cover; }, getCreatingRange: function (localTrack) { return localTrack; }, endCreating: function (controller, cover) { cover.remove(cover.childAt(0)); // Use graphic.Polygon close the shape. cover.add(new graphic.Polygon({ name: 'main', draggable: true, drift: curry(driftPolygon, controller, cover), ondragend: curry(trigger, controller, {isEnd: true}) })); }, updateCoverShape: function (controller, cover, localRange, brushOption) { cover.childAt(0).setShape({ points: clipByPanel(controller, cover, localRange) }); }, updateCommon: updateCommon, contain: mainShapeContain } }; function getLineRenderer(xyIndex) { return { createCover: function (controller, brushOption) { return createBaseRectCover( curry( driftRect, function (range) { var rectRange = [range, [0, 100]]; xyIndex && rectRange.reverse(); return rectRange; }, function (rectRange) { return rectRange[xyIndex]; } ), controller, brushOption, [['w', 'e'], ['n', 's']][xyIndex] ); }, getCreatingRange: function (localTrack) { var ends = getTrackEnds(localTrack); var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]); var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]); return [min, max]; }, updateCoverShape: function (controller, cover, localRange, brushOption) { var otherExtent; // If brushWidth not specified, fit the panel. var panel = getPanelByCover(controller, cover); if (panel !== true && panel.getLinearBrushOtherExtent) { otherExtent = panel.getLinearBrushOtherExtent( xyIndex, controller._transform ); } else { var zr = controller._zr; otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]]; } var rectRange = [localRange, otherExtent]; xyIndex && rectRange.reverse(); updateBaseRect(controller, cover, rectRange, brushOption); }, updateCommon: updateCommon, contain: mainShapeContain }; } module.exports = BrushController; /***/ }), /* 249 */ /***/ (function(module, exports, __webpack_require__) { var cursorHelper = __webpack_require__(189); var BoundingRect = __webpack_require__(9); var graphicUtil = __webpack_require__(20); var helper = {}; helper.makeRectPanelClipPath = function (rect) { rect = normalizeRect(rect); return function (localPoints, transform) { return graphicUtil.clipPointsByRect(localPoints, rect); }; }; helper.makeLinearBrushOtherExtent = function (rect, specifiedXYIndex) { rect = normalizeRect(rect); return function (xyIndex) { var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex; var brushWidth = idx ? rect.width : rect.height; var base = idx ? rect.x : rect.y; return [base, base + (brushWidth || 0)]; }; }; helper.makeRectIsTargetByCursor = function (rect, api, targetModel) { rect = normalizeRect(rect); return function (e, localCursorPoint, transform) { return rect.contain(localCursorPoint[0], localCursorPoint[1]) && !cursorHelper.onIrrelevantElement(e, api, targetModel); }; }; // Consider width/height is negative. function normalizeRect(rect) { return BoundingRect.create(rect); } module.exports = helper; /***/ }), /* 250 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); var modelUtil = __webpack_require__(5); module.exports = function (option) { createParallelIfNeeded(option); mergeAxisOptionFromParallel(option); }; /** * Create a parallel coordinate if not exists. * @inner */ function createParallelIfNeeded(option) { if (option.parallel) { return; } var hasParallelSeries = false; zrUtil.each(option.series, function (seriesOpt) { if (seriesOpt && seriesOpt.type === 'parallel') { hasParallelSeries = true; } }); if (hasParallelSeries) { option.parallel = [{}]; } } /** * Merge aixs definition from parallel option (if exists) to axis option. * @inner */ function mergeAxisOptionFromParallel(option) { var axes = modelUtil.normalizeToArray(option.parallelAxis); zrUtil.each(axes, function (axisOption) { if (!zrUtil.isObject(axisOption)) { return; } var parallelIndex = axisOption.parallelIndex || 0; var parallelOption = modelUtil.normalizeToArray(option.parallel)[parallelIndex]; if (parallelOption && parallelOption.parallelAxisDefault) { zrUtil.merge(axisOption, parallelOption.parallelAxisDefault, false); } }); } /***/ }), /* 251 */ /***/ (function(module, exports, __webpack_require__) { var List = __webpack_require__(101); var zrUtil = __webpack_require__(4); var SeriesModel = __webpack_require__(83); var completeDimensions = __webpack_require__(113); module.exports = SeriesModel.extend({ type: 'series.parallel', dependencies: ['parallel'], visualColorAccessPath: 'lineStyle.normal.color', getInitialData: function (option, ecModel) { var parallelModel = ecModel.getComponent( 'parallel', this.get('parallelIndex') ); var parallelAxisIndices = parallelModel.parallelAxisIndex; var rawData = option.data; var modelDims = parallelModel.dimensions; var dataDims = generateDataDims(modelDims, rawData); var dataDimsInfo = zrUtil.map(dataDims, function (dim, dimIndex) { var modelDimsIndex = zrUtil.indexOf(modelDims, dim); var axisModel = modelDimsIndex >= 0 && ecModel.getComponent( 'parallelAxis', parallelAxisIndices[modelDimsIndex] ); if (axisModel && axisModel.get('type') === 'category') { translateCategoryValue(axisModel, dim, rawData); return {name: dim, type: 'ordinal'}; } else if (modelDimsIndex < 0) { return completeDimensions.guessOrdinal(rawData, dimIndex) ? {name: dim, type: 'ordinal'} : dim; } else { return dim; } }); var list = new List(dataDimsInfo, this); list.initData(rawData); // Anication is forbiden in progressive data mode. if (this.option.progressive) { this.option.animation = false; } return list; }, /** * User can get data raw indices on 'axisAreaSelected' event received. * * @public * @param {string} activeState 'active' or 'inactive' or 'normal' * @return {Array.} Raw indices */ getRawIndicesByActiveState: function (activeState) { var coordSys = this.coordinateSystem; var data = this.getData(); var indices = []; coordSys.eachActiveState(data, function (theActiveState, dataIndex) { if (activeState === theActiveState) { indices.push(data.getRawIndex(dataIndex)); } }); return indices; }, defaultOption: { zlevel: 0, // 一级层叠 z: 2, // 二级层叠 coordinateSystem: 'parallel', parallelIndex: 0, label: { normal: { show: false }, emphasis: { show: false } }, inactiveOpacity: 0.05, activeOpacity: 1, lineStyle: { normal: { width: 1, opacity: 0.45, type: 'solid' } }, progressive: false, // 100 smooth: false, animationEasing: 'linear' } }); function translateCategoryValue(axisModel, dim, rawData) { var axisData = axisModel.get('data'); var numberDim = convertDimNameToNumber(dim); if (axisData && axisData.length) { zrUtil.each(rawData, function (dataItem) { if (!dataItem) { return; } // FIXME // time consuming, should use hash? var index = zrUtil.indexOf(axisData, dataItem[numberDim]); dataItem[numberDim] = index >= 0 ? index : NaN; }); } // FIXME // 如果没有设置axis data, 应自动算出，或者提示。 } function convertDimNameToNumber(dimName) { return +dimName.replace('dim', ''); } function generateDataDims(modelDims, rawData) { // parallelModel.dimension should not be regarded as data // dimensions. Consider dimensions = ['dim4', 'dim2', 'dim6']; // We detect max dim by parallelModel.dimensions and fist // item in rawData arbitrarily. var maxDimNum = 0; zrUtil.each(modelDims, function (dimName) { var numberDim = convertDimNameToNumber(dimName); numberDim > maxDimNum && (maxDimNum = numberDim); }); var firstItem = rawData[0]; if (firstItem && firstItem.length - 1 > maxDimNum) { maxDimNum = firstItem.length - 1; } var dataDims = []; for (var i = 0; i ')); }, defaultOption: { coordinateSystem: 'geo', zlevel: 0, z: 2, legendHoverLink: true, hoverAnimation: true, // Cartesian coordinate system xAxisIndex: 0, yAxisIndex: 0, symbol: ['none', 'none'], symbolSize: [10, 10], // Geo coordinate system geoIndex: 0, effect: { show: false, period: 4, // Animation delay. support callback // delay: 0, // If move with constant speed px/sec // period will be ignored if this property is > 0, constantSpeed: 0, symbol: 'circle', symbolSize: 3, loop: true, // Length of trail, 0 - 1 trailLength: 0.2 // Same with lineStyle.normal.color // color }, large: false, // Available when large is true largeThreshold: 2000, // If lines are polyline // polyline not support curveness, label, animation polyline: false, label: { normal: { show: false, position: 'end' // distance: 5, // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调 } }, lineStyle: { normal: { opacity: 0.5 } } } }); /***/ }), /* 279 */ /***/ (function(module, exports, __webpack_require__) { var LineDraw = __webpack_require__(213); var EffectLine = __webpack_require__(280); var Line = __webpack_require__(214); var Polyline = __webpack_require__(281); var EffectPolyline = __webpack_require__(282); var LargeLineDraw = __webpack_require__(283); __webpack_require__(1).extendChartView({ type: 'lines', init: function () {}, render: function (seriesModel, ecModel, api) { var data = seriesModel.getData(); var lineDraw = this._lineDraw; var hasEffect = seriesModel.get('effect.show'); var isPolyline = seriesModel.get('polyline'); var isLarge = seriesModel.get('large') && data.count() >= seriesModel.get('largeThreshold'); if (true) { if (hasEffect && isLarge) { console.warn('Large lines not support effect'); } } if (hasEffect !== this._hasEffet || isPolyline !== this._isPolyline || isLarge !== this._isLarge) { if (lineDraw) { lineDraw.remove(); } lineDraw = this._lineDraw = isLarge ? new LargeLineDraw() : new LineDraw( isPolyline ? (hasEffect ? EffectPolyline : Polyline) : (hasEffect ? EffectLine : Line) ); this._hasEffet = hasEffect; this._isPolyline = isPolyline; this._isLarge = isLarge; } var zlevel = seriesModel.get('zlevel'); var trailLength = seriesModel.get('effect.trailLength'); var zr = api.getZr(); // Avoid the drag cause ghost shadow // FIXME Better way ? // SVG doesn't support var isSvg = zr.painter.getType() === 'svg'; if (!isSvg) { zr.painter.getLayer(zlevel).clear(true); } // Config layer with motion blur if (this._lastZlevel != null && !isSvg) { zr.configLayer(this._lastZlevel, { motionBlur: false }); } if (hasEffect && trailLength) { if (true) { var notInIndividual = false; ecModel.eachSeries(function (otherSeriesModel) { if (otherSeriesModel !== seriesModel && otherSeriesModel.get('zlevel') === zlevel) { notInIndividual = true; } }); notInIndividual && console.warn('Lines with trail effect should have an individual zlevel'); } if (!isSvg) { zr.configLayer(zlevel, { motionBlur: true, lastFrameAlpha: Math.max(Math.min(trailLength / 10 + 0.9, 1), 0) }); } } this.group.add(lineDraw.group); lineDraw.updateData(data); this._lastZlevel = zlevel; }, updateLayout: function (seriesModel, ecModel, api) { this._lineDraw.updateLayout(seriesModel); // Not use motion when dragging or zooming var zr = api.getZr(); var isSvg = zr.painter.getType() === 'svg'; if (!isSvg) { zr.painter.getLayer(this._lastZlevel).clear(true); } }, remove: function (ecModel, api) { this._lineDraw && this._lineDraw.remove(api, true); // Clear motion when lineDraw is removed var zr = api.getZr(); var isSvg = zr.painter.getType() === 'svg'; if (!isSvg) { zr.painter.getLayer(this._lastZlevel).clear(true); } }, dispose: function () {} }); /***/ }), /* 280 */ /***/ (function(module, exports, __webpack_require__) { /** * Provide effect for line * @module echarts/chart/helper/EffectLine */ var graphic = __webpack_require__(20); var Line = __webpack_require__(214); var zrUtil = __webpack_require__(4); var symbolUtil = __webpack_require__(114); var vec2 = __webpack_require__(10); var curveUtil = __webpack_require__(40); /** * @constructor * @extends {module:zrender/graphic/Group} * @alias {module:echarts/chart/helper/Line} */ function EffectLine(lineData, idx, seriesScope) { graphic.Group.call(this); this.add(this.createLine(lineData, idx, seriesScope)); this._updateEffectSymbol(lineData, idx); } var effectLineProto = EffectLine.prototype; effectLineProto.createLine = function (lineData, idx, seriesScope) { return new Line(lineData, idx, seriesScope); }; effectLineProto._updateEffectSymbol = function (lineData, idx) { var itemModel = lineData.getItemModel(idx); var effectModel = itemModel.getModel('effect'); var size = effectModel.get('symbolSize'); var symbolType = effectModel.get('symbol'); if (!zrUtil.isArray(size)) { size = [size, size]; } var color = effectModel.get('color') || lineData.getItemVisual(idx, 'color'); var symbol = this.childAt(1); if (this._symbolType !== symbolType) { // Remove previous this.remove(symbol); symbol = symbolUtil.createSymbol( symbolType, -0.5, -0.5, 1, 1, color ); symbol.z2 = 100; symbol.culling = true; this.add(symbol); } // Symbol may be removed if loop is false if (!symbol) { return; } // Shadow color is same with color in default symbol.setStyle('shadowColor', color); symbol.setStyle(effectModel.getItemStyle(['color'])); symbol.attr('scale', size); symbol.setColor(color); symbol.attr('scale', size); this._symbolType = symbolType; this._updateEffectAnimation(lineData, effectModel, idx); }; effectLineProto._updateEffectAnimation = function (lineData, effectModel, idx) { var symbol = this.childAt(1); if (!symbol) { return; } var self = this; var points = lineData.getItemLayout(idx); var period = effectModel.get('period') * 1000; var loop = effectModel.get('loop'); var constantSpeed = effectModel.get('constantSpeed'); var delayExpr = zrUtil.retrieve(effectModel.get('delay'), function (idx) { return idx / lineData.count() * period / 3; }); var isDelayFunc = typeof delayExpr === 'function'; // Ignore when updating symbol.ignore = true; this.updateAnimationPoints(symbol, points); if (constantSpeed > 0) { period = this.getLineLength(symbol) / constantSpeed * 1000; } if (period !== this._period || loop !== this._loop) { symbol.stopAnimation(); var delay = delayExpr; if (isDelayFunc) { delay = delayExpr(idx); } if (symbol.__t > 0) { delay = -period * symbol.__t; } symbol.__t = 0; var animator = symbol.animate('', loop) .when(period, { __t: 1 }) .delay(delay) .during(function () { self.updateSymbolPosition(symbol); }); if (!loop) { animator.done(function () { self.remove(symbol); }); } animator.start(); } this._period = period; this._loop = loop; }; effectLineProto.getLineLength = function (symbol) { // Not so accurate return (vec2.dist(symbol.__p1, symbol.__cp1) + vec2.dist(symbol.__cp1, symbol.__p2)); }; effectLineProto.updateAnimationPoints = function (symbol, points) { symbol.__p1 = points[0]; symbol.__p2 = points[1]; symbol.__cp1 = points[2] || [ (points[0][0] + points[1][0]) / 2, (points[0][1] + points[1][1]) / 2 ]; }; effectLineProto.updateData = function (lineData, idx, seriesScope) { this.childAt(0).updateData(lineData, idx, seriesScope); this._updateEffectSymbol(lineData, idx); }; effectLineProto.updateSymbolPosition = function (symbol) { var p1 = symbol.__p1; var p2 = symbol.__p2; var cp1 = symbol.__cp1; var t = symbol.__t; var pos = symbol.position; var quadraticAt = curveUtil.quadraticAt; var quadraticDerivativeAt = curveUtil.quadraticDerivativeAt; pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t); pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t); // Tangent var tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t); var ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t); symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2; symbol.ignore = false; }; effectLineProto.updateLayout = function (lineData, idx) { this.childAt(0).updateLayout(lineData, idx); var effectModel = lineData.getItemModel(idx).getModel('effect'); this._updateEffectAnimation(lineData, effectModel, idx); }; zrUtil.inherits(EffectLine, graphic.Group); module.exports = EffectLine; /***/ }), /* 281 */ /***/ (function(module, exports, __webpack_require__) { /** * @module echarts/chart/helper/Line */ var graphic = __webpack_require__(20); var zrUtil = __webpack_require__(4); /** * @constructor * @extends {module:zrender/graphic/Group} * @alias {module:echarts/chart/helper/Polyline} */ function Polyline(lineData, idx, seriesScope) { graphic.Group.call(this); this._createPolyline(lineData, idx, seriesScope); } var polylineProto = Polyline.prototype; polylineProto._createPolyline = function (lineData, idx, seriesScope) { // var seriesModel = lineData.hostModel; var points = lineData.getItemLayout(idx); var line = new graphic.Polyline({ shape: { points: points } }); this.add(line); this._updateCommonStl(lineData, idx, seriesScope); }; polylineProto.updateData = function (lineData, idx, seriesScope) { var seriesModel = lineData.hostModel; var line = this.childAt(0); var target = { shape: { points: lineData.getItemLayout(idx) } }; graphic.updateProps(line, target, seriesModel, idx); this._updateCommonStl(lineData, idx, seriesScope); }; polylineProto._updateCommonStl = function (lineData, idx, seriesScope) { var line = this.childAt(0); var itemModel = lineData.getItemModel(idx); var visualColor = lineData.getItemVisual(idx, 'color'); var lineStyle = seriesScope && seriesScope.lineStyle; var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle; if (!seriesScope || lineData.hasItemOption) { lineStyle = itemModel.getModel('lineStyle.normal').getLineStyle(); hoverLineStyle = itemModel.getModel('lineStyle.emphasis').getLineStyle(); } line.useStyle(zrUtil.defaults( { strokeNoScale: true, fill: 'none', stroke: visualColor }, lineStyle )); line.hoverStyle = hoverLineStyle; graphic.setHoverStyle(this); }; polylineProto.updateLayout = function (lineData, idx) { var polyline = this.childAt(0); polyline.setShape('points', lineData.getItemLayout(idx)); }; zrUtil.inherits(Polyline, graphic.Group); module.exports = Polyline; /***/ }), /* 282 */ /***/ (function(module, exports, __webpack_require__) { /** * Provide effect for line * @module echarts/chart/helper/EffectLine */ var Polyline = __webpack_require__(281); var zrUtil = __webpack_require__(4); var EffectLine = __webpack_require__(280); var vec2 = __webpack_require__(10); /** * @constructor * @extends {module:echarts/chart/helper/EffectLine} * @alias {module:echarts/chart/helper/Polyline} */ function EffectPolyline(lineData, idx, seriesScope) { EffectLine.call(this, lineData, idx, seriesScope); this._lastFrame = 0; this._lastFramePercent = 0; } var effectPolylineProto = EffectPolyline.prototype; // Overwrite effectPolylineProto.createLine = function (lineData, idx, seriesScope) { return new Polyline(lineData, idx, seriesScope); }; // Overwrite effectPolylineProto.updateAnimationPoints = function (symbol, points) { this._points = points; var accLenArr = [0]; var len = 0; for (var i = 1; i < points.length; i++) { var p1 = points[i - 1]; var p2 = points[i]; len += vec2.dist(p1, p2); accLenArr.push(len); } if (len === 0) { return; } for (var i = 0; i < accLenArr.length; i++) { accLenArr[i] /= len; } this._offsets = accLenArr; this._length = len; }; // Overwrite effectPolylineProto.getLineLength = function (symbol) { return this._length; }; // Overwrite effectPolylineProto.updateSymbolPosition = function (symbol) { var t = symbol.__t; var points = this._points; var offsets = this._offsets; var len = points.length; if (!offsets) { // Has length 0 return; } var lastFrame = this._lastFrame; var frame; if (t < this._lastFramePercent) { // Start from the next frame // PENDING start from lastFrame ? var start = Math.min(lastFrame + 1, len - 1); for (frame = start; frame >= 0; frame--) { if (offsets[frame] 2) { path.quadraticCurveTo(seg[2][0], seg[2][1], seg[1][0], seg[1][1]); } else { path.lineTo(seg[1][0], seg[1][1]); } } } }, findDataIndex: function (x, y) { var shape = this.shape; var segs = shape.segs; var isPolyline = shape.polyline; var lineWidth = Math.max(this.style.lineWidth, 1); // Not consider transform for (var i = 0; i < segs.length; i++) { var seg = segs[i]; if (isPolyline) { for (var j = 1; j < seg.length; j++) { if (lineContain.containStroke( seg[j - 1][0], seg[j - 1][1], seg[j][0], seg[j][1], lineWidth, x, y )) { return i; } } } else { if (seg.length > 2) { if (quadraticContain.containStroke( seg[0][0], seg[0][1], seg[2][0], seg[2][1], seg[1][0], seg[1][1], lineWidth, x, y )) { return i; } } else { if (lineContain.containStroke( seg[0][0], seg[0][1], seg[1][0], seg[1][1], lineWidth, x, y )) { return i; } } } } return -1; } }); function LargeLineDraw() { this.group = new graphic.Group(); this._lineEl = new LargeLineShape(); } var largeLineProto = LargeLineDraw.prototype; /** * Update symbols draw by new data * @param {module:echarts/data/List} data */ largeLineProto.updateData = function (data) { this.group.removeAll(); var lineEl = this._lineEl; var seriesModel = data.hostModel; lineEl.setShape({ segs: data.mapArray(data.getItemLayout), polyline: seriesModel.get('polyline') }); lineEl.useStyle( seriesModel.getModel('lineStyle.normal').getLineStyle() ); var visualColor = data.getVisual('color'); if (visualColor) { lineEl.setStyle('stroke', visualColor); } lineEl.setStyle('fill'); // Enable tooltip // PENDING May have performance issue when path is extremely large lineEl.seriesIndex = seriesModel.seriesIndex; lineEl.on('mousemove', function (e) { lineEl.dataIndex = null; var dataIndex = lineEl.findDataIndex(e.offsetX, e.offsetY); if (dataIndex > 0) { // Provide dataIndex for tooltip lineEl.dataIndex = dataIndex; } }); // Add back this.group.add(lineEl); }; largeLineProto.updateLayout = function (seriesModel) { var data = seriesModel.getData(); this._lineEl.setShape({ segs: data.mapArray(data.getItemLayout) }); }; largeLineProto.remove = function () { this.group.removeAll(); }; module.exports = LargeLineDraw; /***/ }), /* 284 */ /***/ (function(module, exports, __webpack_require__) { module.exports = function (ecModel) { ecModel.eachSeriesByType('lines', function (seriesModel) { var coordSys = seriesModel.coordinateSystem; var lineData = seriesModel.getData(); // FIXME Use data dimensions ? lineData.each(function (idx) { var itemModel = lineData.getItemModel(idx); var coords = (itemModel.option instanceof Array) ? itemModel.option : itemModel.get('coords'); if (true) { if (!(coords instanceof Array && coords.length > 0 && coords[0] instanceof Array)) { throw new Error('Invalid coords ' + JSON.stringify(coords) + '. Lines must have 2d coords array in data item.'); } } var pts = []; if (seriesModel.get('polyline')) { for (var i = 0; i < coords.length; i++) { pts.push(coordSys.dataToPoint(coords[i])); } } else { pts[0] = coordSys.dataToPoint(coords[0]); pts[1] = coordSys.dataToPoint(coords[1]); var curveness = itemModel.get('lineStyle.normal.curveness'); if (+curveness) { pts[2] = [ (pts[0][0] + pts[1][0]) / 2 - (pts[0][1] - pts[1][1]) * curveness, (pts[0][1] + pts[1][1]) / 2 - (pts[1][0] - pts[0][0]) * curveness ]; } } lineData.setItemLayout(idx, pts); }); }); }; /***/ }), /* 285 */ /***/ (function(module, exports) { function normalize(a) { if (!(a instanceof Array)) { a = [a, a]; } return a; } module.exports = function (ecModel) { ecModel.eachSeriesByType('lines', function (seriesModel) { var data = seriesModel.getData(); var symbolType = normalize(seriesModel.get('symbol')); var symbolSize = normalize(seriesModel.get('symbolSize')); var opacityQuery = 'lineStyle.normal.opacity'.split('.'); data.setVisual('fromSymbol', symbolType && symbolType[0]); data.setVisual('toSymbol', symbolType && symbolType[1]); data.setVisual('fromSymbolSize', symbolSize && symbolSize[0]); data.setVisual('toSymbolSize', symbolSize && symbolSize[1]); data.setVisual('opacity', seriesModel.get(opacityQuery)); data.each(function (idx) { var itemModel = data.getItemModel(idx); var symbolType = normalize(itemModel.getShallow('symbol', true)); var symbolSize = normalize(itemModel.getShallow('symbolSize', true)); var opacity = itemModel.get(opacityQuery); symbolType[0] && data.setItemVisual(idx, 'fromSymbol', symbolType[0]); symbolType[1] && data.setItemVisual(idx, 'toSymbol', symbolType[1]); symbolSize[0] && data.setItemVisual(idx, 'fromSymbolSize', symbolSize[0]); symbolSize[1] && data.setItemVisual(idx, 'toSymbolSize', symbolSize[1]); data.setItemVisual(idx, 'opacity', opacity); }); }); }; /***/ }), /* 286 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(287); __webpack_require__(288); /***/ }), /* 287 */ /***/ (function(module, exports, __webpack_require__) { var SeriesModel = __webpack_require__(83); var createListFromArray = __webpack_require__(112); module.exports = SeriesModel.extend({ type: 'series.heatmap', getInitialData: function (option, ecModel) { return createListFromArray(option.data, this, ecModel); }, defaultOption: { // Cartesian2D or geo coordinateSystem: 'cartesian2d', zlevel: 0, z: 2, // Cartesian coordinate system // xAxisIndex: 0, // yAxisIndex: 0, // Geo coordinate system geoIndex: 0, blurSize: 30, pointSize: 20, maxOpacity: 1, minOpacity: 0 } }); /***/ }), /* 288 */ /***/ (function(module, exports, __webpack_require__) { var graphic = __webpack_require__(20); var HeatmapLayer = __webpack_require__(289); var zrUtil = __webpack_require__(4); function getIsInPiecewiseRange(dataExtent, pieceList, selected) { var dataSpan = dataExtent[1] - dataExtent[0]; pieceList = zrUtil.map(pieceList, function (piece) { return { interval: [ (piece.interval[0] - dataExtent[0]) / dataSpan, (piece.interval[1] - dataExtent[0]) / dataSpan ] }; }); var len = pieceList.length; var lastIndex = 0; return function (val) { // Try to find in the location of the last found for (var i = lastIndex; i < len; i++) { var interval = pieceList[i].interval; if (interval[0] 0 && (alpha = alpha * diffOpacity + minOpacity); pixels[offset++] = gradient[gradientOffset]; pixels[offset++] = gradient[gradientOffset + 1]; pixels[offset++] = gradient[gradientOffset + 2]; pixels[offset++] = gradient[gradientOffset + 3] * alpha * 256; } else { offset += 4; } } ctx.putImageData(imageData, 0, 0); return canvas; }, /** * get canvas of a black circle brush used for canvas to draw later * @private * @returns {Object} circle brush canvas */ _getBrush: function() { var brushCanvas = this._brushCanvas || (this._brushCanvas = zrUtil.createCanvas()); // set brush size var r = this.pointSize + this.blurSize; var d = r * 2; brushCanvas.width = d; brushCanvas.height = d; var ctx = brushCanvas.getContext('2d'); ctx.clearRect(0, 0, d, d); // in order to render shadow without the distinct circle, // draw the distinct circle in an invisible place, // and use shadowOffset to draw shadow in the center of the canvas ctx.shadowOffsetX = d; ctx.shadowBlur = this.blurSize; // draw the shadow in black, and use alpha and shadow blur to generate // color in color map ctx.shadowColor = '#000'; // draw circle in the left to the canvas ctx.beginPath(); ctx.arc(-r, r, this.pointSize, 0, Math.PI * 2, true); ctx.closePath(); ctx.fill(); return brushCanvas; }, /** * get gradient color map * @private */ _getGradient: function (data, colorFunc, state) { var gradientPixels = this._gradientPixels; var pixelsSingleState = gradientPixels[state] || (gradientPixels[state] = new Uint8ClampedArray(256 * 4)); var color = [0, 0, 0, 0]; var off = 0; for (var i = 0; i < 256; i++) { colorFunc[state](i / 255, true, color); pixelsSingleState[off++] = color[0]; pixelsSingleState[off++] = color[1]; pixelsSingleState[off++] = color[2]; pixelsSingleState[off++] = color[3]; } return pixelsSingleState; } }; module.exports = Heatmap; /***/ }), /* 290 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); __webpack_require__(128); __webpack_require__(291); __webpack_require__(292); var barLayoutGrid = __webpack_require__(148); var echarts = __webpack_require__(1); echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'pictorialBar')); echarts.registerVisual(zrUtil.curry( __webpack_require__(124), 'pictorialBar', 'roundRect', null )); // In case developer forget to include grid component __webpack_require__(127); /***/ }), /* 291 */ /***/ (function(module, exports, __webpack_require__) { var PictorialBarSeries = __webpack_require__(144).extend({ type: 'series.pictorialBar', dependencies: ['grid'], defaultOption: { symbol: 'circle', // Customized bar shape symbolSize: null, // Can be ['100%', '100%'], null means auto. symbolRotate: null, symbolPosition: null, // 'start' or 'end' or 'center', null means auto. symbolOffset: null, symbolMargin: null, // start margin and end margin. Can be a number or a percent string. // Auto margin by defualt. symbolRepeat: false, // false/null/undefined, means no repeat. // Can be true, means auto calculate repeat times and cut by data. // Can be a number, specifies repeat times, and do not cut by data. // Can be 'fixed', means auto calculate repeat times but do not cut by data. symbolRepeatDirection: 'end', // 'end' means from 'start' to 'end'. symbolClip: false, symbolBoundingData: null, // Can be 60 or -40 or [-40, 60] symbolPatternSize: 400, // 400 * 400 px barGap: '-100%', // In most case, overlap is needed. // z can be set in data item, which is z2 actually. // Disable progressive progressive: 0, hoverAnimation: false // Open only when needed. }, getInitialData: function (option) { // Disable stack. option.stack = null; return PictorialBarSeries.superApply(this, 'getInitialData', arguments); } }); module.exports = PictorialBarSeries; /***/ }), /* 292 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); var graphic = __webpack_require__(20); var symbolUtil = __webpack_require__(114); var numberUtil = __webpack_require__(7); var helper = __webpack_require__(146); var parsePercent = numberUtil.parsePercent; var BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'normal', 'borderWidth']; // index: +isHorizontal var LAYOUT_ATTRS = [ {xy: 'x', wh: 'width', index: 0, posDesc: ['left', 'right']}, {xy: 'y', wh: 'height', index: 1, posDesc: ['top', 'bottom']} ]; var pathForLineWidth = new graphic.Circle(); var BarView = __webpack_require__(1).extendChartView({ type: 'pictorialBar', render: function (seriesModel, ecModel, api) { var group = this.group; var data = seriesModel.getData(); var oldData = this._data; var cartesian = seriesModel.coordinateSystem; var baseAxis = cartesian.getBaseAxis(); var isHorizontal = !!baseAxis.isHorizontal(); var coordSysRect = cartesian.grid.getRect(); var opt = { ecSize: {width: api.getWidth(), height: api.getHeight()}, seriesModel: seriesModel, coordSys: cartesian, coordSysExtent: [ [coordSysRect.x, coordSysRect.x + coordSysRect.width], [coordSysRect.y, coordSysRect.y + coordSysRect.height] ], isHorizontal: isHorizontal, valueDim: LAYOUT_ATTRS[+isHorizontal], categoryDim: LAYOUT_ATTRS[1 - isHorizontal] }; data.diff(oldData) .add(function (dataIndex) { if (!data.hasValue(dataIndex)) { return; } var itemModel = getItemModel(data, dataIndex); var symbolMeta = getSymbolMeta(data, dataIndex, itemModel, opt); var bar = createBar(data, opt, symbolMeta); data.setItemGraphicEl(dataIndex, bar); group.add(bar); updateCommon(bar, opt, symbolMeta); }) .update(function (newIndex, oldIndex) { var bar = oldData.getItemGraphicEl(oldIndex); if (!data.hasValue(newIndex)) { group.remove(bar); return; } var itemModel = getItemModel(data, newIndex); var symbolMeta = getSymbolMeta(data, newIndex, itemModel, opt); var pictorialShapeStr = getShapeStr(data, symbolMeta); if (bar && pictorialShapeStr !== bar.__pictorialShapeStr) { group.remove(bar); data.setItemGraphicEl(newIndex, null); bar = null; } if (bar) { updateBar(bar, opt, symbolMeta); } else { bar = createBar(data, opt, symbolMeta, true); } data.setItemGraphicEl(newIndex, bar); bar.__pictorialSymbolMeta = symbolMeta; // Add back group.add(bar); updateCommon(bar, opt, symbolMeta); }) .remove(function (dataIndex) { var bar = oldData.getItemGraphicEl(dataIndex); bar && removeBar(oldData, dataIndex, bar.__pictorialSymbolMeta.animationModel, bar); }) .execute(); this._data = data; return this.group; }, dispose: zrUtil.noop, remove: function (ecModel, api) { var group = this.group; var data = this._data; if (ecModel.get('animation')) { if (data) { data.eachItemGraphicEl(function (bar) { removeBar(data, bar.dataIndex, ecModel, bar); }); } } else { group.removeAll(); } } }); // Set or calculate default value about symbol, and calculate layout info. function getSymbolMeta(data, dataIndex, itemModel, opt) { var layout = data.getItemLayout(dataIndex); var symbolRepeat = itemModel.get('symbolRepeat'); var symbolClip = itemModel.get('symbolClip'); var symbolPosition = itemModel.get('symbolPosition') || 'start'; var symbolRotate = itemModel.get('symbolRotate'); var rotation = (symbolRotate || 0) * Math.PI / 180 || 0; var symbolPatternSize = itemModel.get('symbolPatternSize') || 2; var isAnimationEnabled = itemModel.isAnimationEnabled(); var symbolMeta = { dataIndex: dataIndex, layout: layout, itemModel: itemModel, symbolType: data.getItemVisual(dataIndex, 'symbol') || 'circle', color: data.getItemVisual(dataIndex, 'color'), symbolClip: symbolClip, symbolRepeat: symbolRepeat, symbolRepeatDirection: itemModel.get('symbolRepeatDirection'), symbolPatternSize: symbolPatternSize, rotation: rotation, animationModel: isAnimationEnabled ? itemModel : null, hoverAnimation: isAnimationEnabled && itemModel.get('hoverAnimation'), z2: itemModel.getShallow('z', true) || 0 }; prepareBarLength(itemModel, symbolRepeat, layout, opt, symbolMeta); prepareSymbolSize( data, dataIndex, layout, symbolRepeat, symbolClip, symbolMeta.boundingLength, symbolMeta.pxSign, symbolPatternSize, opt, symbolMeta ); prepareLineWidth(itemModel, symbolMeta.symbolScale, rotation, opt, symbolMeta); var symbolSize = symbolMeta.symbolSize; var symbolOffset = itemModel.get('symbolOffset'); if (zrUtil.isArray(symbolOffset)) { symbolOffset = [ parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1]) ]; } prepareLayoutInfo( itemModel, symbolSize, layout, symbolRepeat, symbolClip, symbolOffset, symbolPosition, symbolMeta.valueLineWidth, symbolMeta.boundingLength, symbolMeta.repeatCutLength, opt, symbolMeta ); return symbolMeta; } // bar length can be negative. function prepareBarLength(itemModel, symbolRepeat, layout, opt, output) { var valueDim = opt.valueDim; var symbolBoundingData = itemModel.get('symbolBoundingData'); var valueAxis = opt.coordSys.getOtherAxis(opt.coordSys.getBaseAxis()); var zeroPx = valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)); var pxSignIdx = 1 - +(layout[valueDim.wh] 0) || (end && pxSign < 0): i = repeatTimes - index // Otherwise: i = index; var pxSign = symbolMeta.pxSign; var i = index; if (symbolMeta.symbolRepeatDirection === 'start' ? pxSign > 0 : pxSign < 0) { i = repeatTimes - 1 - index; } position[valueDim.index] = unit * (i - repeatTimes / 2 + 0.5) + pathPosition[valueDim.index]; return { position: position, scale: symbolMeta.symbolScale.slice(), rotation: symbolMeta.rotation }; } function onMouseOver() { eachPath(bar, function (path) { path.trigger('emphasis'); }); } function onMouseOut() { eachPath(bar, function (path) { path.trigger('normal'); }); } } function createOrUpdateSingleSymbol(bar, opt, symbolMeta, isUpdate) { var bundle = bar.__pictorialBundle; var mainPath = bar.__pictorialMainPath; if (!mainPath) { mainPath = bar.__pictorialMainPath = createPath(symbolMeta); bundle.add(mainPath); updateAttr( mainPath, { position: symbolMeta.pathPosition.slice(), scale: [0, 0], rotation: symbolMeta.rotation }, { scale: symbolMeta.symbolScale.slice() }, symbolMeta, isUpdate ); mainPath .on('mouseover', onMouseOver) .on('mouseout', onMouseOut); } else { updateAttr( mainPath, null, { position: symbolMeta.pathPosition.slice(), scale: symbolMeta.symbolScale.slice(), rotation: symbolMeta.rotation }, symbolMeta, isUpdate ); } updateHoverAnimation(mainPath, symbolMeta); function onMouseOver() { this.trigger('emphasis'); } function onMouseOut() { this.trigger('normal'); } } // bar rect is used for label. function createOrUpdateBarRect(bar, symbolMeta, isUpdate) { var rectShape = zrUtil.extend({}, symbolMeta.barRectShape); var barRect = bar.__pictorialBarRect; if (!barRect) { barRect = bar.__pictorialBarRect = new graphic.Rect({ z2: 2, shape: rectShape, silent: true, style: { stroke: 'transparent', fill: 'transparent', lineWidth: 0 } }); bar.add(barRect); } else { updateAttr(barRect, null, {shape: rectShape}, symbolMeta, isUpdate); } } function createOrUpdateClip(bar, opt, symbolMeta, isUpdate) { // If not clip, symbol will be remove and rebuilt. if (symbolMeta.symbolClip) { var clipPath = bar.__pictorialClipPath; var clipShape = zrUtil.extend({}, symbolMeta.clipShape); var valueDim = opt.valueDim; var animationModel = symbolMeta.animationModel; var dataIndex = symbolMeta.dataIndex; if (clipPath) { graphic.updateProps( clipPath, {shape: clipShape}, animationModel, dataIndex ); } else { clipShape[valueDim.wh] = 0; clipPath = new graphic.Rect({shape: clipShape}); bar.__pictorialBundle.setClipPath(clipPath); bar.__pictorialClipPath = clipPath; var target = {}; target[valueDim.wh] = symbolMeta.clipShape[valueDim.wh]; graphic[isUpdate ? 'updateProps' : 'initProps']( clipPath, {shape: target}, animationModel, dataIndex ); } } } function getItemModel(data, dataIndex) { var itemModel = data.getItemModel(dataIndex); itemModel.getAnimationDelayParams = getAnimationDelayParams; itemModel.isAnimationEnabled = isAnimationEnabled; return itemModel; } function getAnimationDelayParams(path) { // The order is the same as the z-order, see `symbolRepeatDiretion`. return { index: path.__pictorialAnimationIndex, count: path.__pictorialRepeatTimes }; } function isAnimationEnabled() { // `animation` prop can be set on itemModel in pictorial bar chart. return this.parentModel.isAnimationEnabled() && !!this.getShallow('animation'); } function updateHoverAnimation(path, symbolMeta) { path.off('emphasis').off('normal'); var scale = symbolMeta.symbolScale.slice(); symbolMeta.hoverAnimation && path .on('emphasis', function() { this.animateTo({ scale: [scale[0] * 1.1, scale[1] * 1.1] }, 400, 'elasticOut'); }) .on('normal', function() { this.animateTo({ scale: scale.slice() }, 400, 'elasticOut'); }); } function createBar(data, opt, symbolMeta, isUpdate) { // bar is the main element for each data. var bar = new graphic.Group(); // bundle is used for location and clip. var bundle = new graphic.Group(); bar.add(bundle); bar.__pictorialBundle = bundle; bundle.attr('position', symbolMeta.bundlePosition.slice()); if (symbolMeta.symbolRepeat) { createOrUpdateRepeatSymbols(bar, opt, symbolMeta); } else { createOrUpdateSingleSymbol(bar, opt, symbolMeta); } createOrUpdateBarRect(bar, symbolMeta, isUpdate); createOrUpdateClip(bar, opt, symbolMeta, isUpdate); bar.__pictorialShapeStr = getShapeStr(data, symbolMeta); bar.__pictorialSymbolMeta = symbolMeta; return bar; } function updateBar(bar, opt, symbolMeta) { var animationModel = symbolMeta.animationModel; var dataIndex = symbolMeta.dataIndex; var bundle = bar.__pictorialBundle; graphic.updateProps( bundle, {position: symbolMeta.bundlePosition.slice()}, animationModel, dataIndex ); if (symbolMeta.symbolRepeat) { createOrUpdateRepeatSymbols(bar, opt, symbolMeta, true); } else { createOrUpdateSingleSymbol(bar, opt, symbolMeta, true); } createOrUpdateBarRect(bar, symbolMeta, true); createOrUpdateClip(bar, opt, symbolMeta, true); } function removeBar(data, dataIndex, animationModel, bar) { // Not show text when animating var labelRect = bar.__pictorialBarRect; labelRect && (labelRect.style.text = null); var pathes = []; eachPath(bar, function (path) { pathes.push(path); }); bar.__pictorialMainPath && pathes.push(bar.__pictorialMainPath); // I do not find proper remove animation for clip yet. bar.__pictorialClipPath && (animationModel = null); zrUtil.each(pathes, function (path) { graphic.updateProps( path, {scale: [0, 0]}, animationModel, dataIndex, function () { bar.parent && bar.parent.remove(bar); } ); }); data.setItemGraphicEl(dataIndex, null); } function getShapeStr(data, symbolMeta) { return [ data.getItemVisual(symbolMeta.dataIndex, 'symbol') || 'none', !!symbolMeta.symbolRepeat, !!symbolMeta.symbolClip ].join(':'); } function eachPath(bar, cb, context) { // Do not use Group#eachChild, because it do not support remove. zrUtil.each(bar.__pictorialBundle.children(), function (el) { el !== bar.__pictorialBarRect && cb.call(context, el); }); } function updateAttr(el, immediateAttrs, animationAttrs, symbolMeta, isUpdate, cb) { immediateAttrs && el.attr(immediateAttrs); // when symbolCip used, only clip path has init animation, otherwise it would be weird effect. if (symbolMeta.symbolClip && !isUpdate) { animationAttrs && el.attr(animationAttrs); } else { animationAttrs && graphic[isUpdate ? 'updateProps' : 'initProps']( el, animationAttrs, symbolMeta.animationModel, symbolMeta.dataIndex, cb ); } } function updateCommon(bar, opt, symbolMeta) { var color = symbolMeta.color; var dataIndex = symbolMeta.dataIndex; var itemModel = symbolMeta.itemModel; // Color must be excluded. // Because symbol provide setColor individually to set fill and stroke var normalStyle = itemModel.getModel('itemStyle.normal').getItemStyle(['color']); var hoverStyle = itemModel.getModel('itemStyle.emphasis').getItemStyle(); var cursorStyle = itemModel.getShallow('cursor'); eachPath(bar, function (path) { // PENDING setColor should be before setStyle!!! path.setColor(color); path.setStyle(zrUtil.defaults( { fill: color, opacity: symbolMeta.opacity }, normalStyle )); graphic.setHoverStyle(path, hoverStyle); cursorStyle && (path.cursor = cursorStyle); path.z2 = symbolMeta.z2; }); var barRectHoverStyle = {}; var barPositionOutside = opt.valueDim.posDesc[+(symbolMeta.boundingLength > 0)]; var barRect = bar.__pictorialBarRect; helper.setLabel( barRect.style, barRectHoverStyle, itemModel, color, opt.seriesModel, dataIndex, barPositionOutside ); graphic.setHoverStyle(barRect, barRectHoverStyle); } function toIntTimes(times) { var roundedTimes = Math.round(times); // Escapse accurate error return Math.abs(times - roundedTimes) < 1e-4 ? roundedTimes : Math.ceil(times); } module.exports = BarView; /***/ }), /* 293 */ /***/ (function(module, exports, __webpack_require__) { var echarts = __webpack_require__(1); var zrUtil = __webpack_require__(4); __webpack_require__(294); __webpack_require__(311); __webpack_require__(312); echarts.registerLayout(__webpack_require__(314)); echarts.registerVisual(__webpack_require__(315)); echarts.registerProcessor( zrUtil.curry(__webpack_require__(157), 'themeRiver') ); /***/ }), /* 294 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(295); __webpack_require__(298); __webpack_require__(300); __webpack_require__(301); __webpack_require__(310); var echarts = __webpack_require__(1); echarts.extendComponentView({ type: 'single' }); /***/ }), /* 295 */ /***/ (function(module, exports, __webpack_require__) { /** * Single coordinate system creator. */ var Single = __webpack_require__(296); /** * Create single coordinate system and inject it into seriesModel. * * @param {module:echarts/model/Global} ecModel * @param {module:echarts/ExtensionAPI} api * @return {Array.} */ function create(ecModel, api) { var singles = []; ecModel.eachComponent('singleAxis', function(axisModel, idx) { var single = new Single(axisModel, ecModel, api); single.name = 'single_' + idx; single.resize(axisModel, api); axisModel.coordinateSystem = single; singles.push(single); }); ecModel.eachSeries(function (seriesModel) { if (seriesModel.get('coordinateSystem') === 'singleAxis') { var singleAxisModel = ecModel.queryComponents({ mainType: 'singleAxis', index: seriesModel.get('singleAxisIndex'), id: seriesModel.get('singleAxisId') })[0]; seriesModel.coordinateSystem = singleAxisModel && singleAxisModel.coordinateSystem; } }); return singles; } __webpack_require__(79).register('single', { create: create, dimensions: Single.prototype.dimensions }); /***/ }), /* 296 */ /***/ (function(module, exports, __webpack_require__) { /** * Single coordinates system. */ var SingleAxis = __webpack_require__(297); var axisHelper = __webpack_require__(104); var layout = __webpack_require__(74); /** * Create a single coordinates system. * * @param {module:echarts/coord/single/AxisModel} axisModel * @param {module:echarts/model/Global} ecModel * @param {module:echarts/ExtensionAPI} api */ function Single(axisModel, ecModel, api) { /** * @type {string} * @readOnly */ this.dimension = 'single'; /** * Add it just for draw tooltip. * * @type {Array.} * @readOnly */ this.dimensions = ['single']; /** * @private * @type {module:echarts/coord/single/SingleAxis}. */ this._axis = null; /** * @private * @type {module:zrender/core/BoundingRect} */ this._rect; this._init(axisModel, ecModel, api); /** * @type {module:echarts/coord/single/AxisModel} */ this.model = axisModel; } Single.prototype = { type: 'singleAxis', axisPointerEnabled: true, constructor: Single, /** * Initialize single coordinate system. * * @param {module:echarts/coord/single/AxisModel} axisModel * @param {module:echarts/model/Global} ecModel * @param {module:echarts/ExtensionAPI} api * @private */ _init: function (axisModel, ecModel, api) { var dim = this.dimension; var axis = new SingleAxis( dim, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisModel.get('position') ); var isCategory = axis.type === 'category'; axis.onBand = isCategory && axisModel.get('boundaryGap'); axis.inverse = axisModel.get('inverse'); axis.orient = axisModel.get('orient'); axisModel.axis = axis; axis.model = axisModel; axis.coordinateSystem = this; this._axis = axis; }, /** * Update axis scale after data processed * @param {module:echarts/model/Global} ecModel * @param {module:echarts/ExtensionAPI} api */ update: function (ecModel, api) { ecModel.eachSeries(function (seriesModel) { if (seriesModel.coordinateSystem === this) { var data = seriesModel.getData(); var dim = this.dimension; this._axis.scale.unionExtentFromData( data, seriesModel.coordDimToDataDim(dim) ); axisHelper.niceScaleExtent(this._axis.scale, this._axis.model); } }, this); }, /** * Resize the single coordinate system. * * @param {module:echarts/coord/single/AxisModel} axisModel * @param {module:echarts/ExtensionAPI} api */ resize: function (axisModel, api) { this._rect = layout.getLayoutRect( { left: axisModel.get('left'), top: axisModel.get('top'), right: axisModel.get('right'), bottom: axisModel.get('bottom'), width: axisModel.get('width'), height: axisModel.get('height') }, { width: api.getWidth(), height: api.getHeight() } ); this._adjustAxis(); }, /** * @return {module:zrender/core/BoundingRect} */ getRect: function () { return this._rect; }, /** * @private */ _adjustAxis: function () { var rect = this._rect; var axis = this._axis; var isHorizontal = axis.isHorizontal(); var extent = isHorizontal ? [0, rect.width] : [0, rect.height]; var idx = axis.reverse ? 1 : 0; axis.setExtent(extent[idx], extent[1 - idx]); this._updateAxisTransform(axis, isHorizontal ? rect.x : rect.y); }, /** * @param {module:echarts/coord/single/SingleAxis} axis * @param {number} coordBase */ _updateAxisTransform: function (axis, coordBase) { var axisExtent = axis.getExtent(); var extentSum = axisExtent[0] + axisExtent[1]; var isHorizontal = axis.isHorizontal(); axis.toGlobalCoord = isHorizontal ? function (coord) { return coord + coordBase; } : function (coord) { return extentSum - coord + coordBase; }; axis.toLocalCoord = isHorizontal ? function (coord) { return coord - coordBase; } : function (coord) { return extentSum - coord + coordBase; }; }, /** * Get axis. * * @return {module:echarts/coord/single/SingleAxis} */ getAxis: function () { return this._axis; }, /** * Get axis, add it just for draw tooltip. * * @return {[type]} [description] */ getBaseAxis: function () { return this._axis; }, /** * @return {Array.} */ getAxes: function () { return [this._axis]; }, /** * @return {Object} {baseAxes: [], otherAxes: []} */ getTooltipAxes: function () { return {baseAxes: [this.getAxis()]}; }, /** * If contain point. * * @param {Array.} point * @return {boolean} */ containPoint: function (point) { var rect = this.getRect(); var axis = this.getAxis(); var orient = axis.orient; if (orient === 'horizontal') { return axis.contain(axis.toLocalCoord(point[0])) && (point[1] >= rect.y && point[1] = rect.y && point[0] animationThreshold) { return true; } // It is important to auto animation when snap used. Consider if there is // a dataZoom, animation will be disabled when too many points exist, while // it will be enabled for better visual effect when little points exist. if (useSnap) { var seriesDataCount = axisPointerModelHelper.getAxisInfo(axisModel).seriesDataCount; var axisExtent = axis.getExtent(); // Approximate band width return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold; } return false; } return animation === true; }, /** * add {pointer, label, graphicKey} to elOption * @protected */ makeElOption: function (elOption, value, axisModel, axisPointerModel, api) { // Shoule be implemenented by sub-class. }, /** * @protected */ createPointerEl: function (group, elOption, axisModel, axisPointerModel) { var pointerOption = elOption.pointer; if (pointerOption) { var pointerEl = get(group).pointerEl = new graphic[pointerOption.type]( clone(elOption.pointer) ); group.add(pointerEl); } }, /** * @protected */ createLabelEl: function (group, elOption, axisModel, axisPointerModel) { if (elOption.label) { var labelEl = get(group).labelEl = new graphic.Rect( clone(elOption.label) ); group.add(labelEl); updateLabelShowHide(labelEl, axisPointerModel); } }, /** * @protected */ updatePointerEl: function (group, elOption, updateProps) { var pointerEl = get(group).pointerEl; if (pointerEl) { pointerEl.setStyle(elOption.pointer.style); updateProps(pointerEl, {shape: elOption.pointer.shape}); } }, /** * @protected */ updateLabelEl: function (group, elOption, updateProps, axisPointerModel) { var labelEl = get(group).labelEl; if (labelEl) { labelEl.setStyle(elOption.label.style); updateProps(labelEl, { // Consider text length change in vertical axis, animation should // be used on shape, otherwise the effect will be weird. shape: elOption.label.shape, position: elOption.label.position }); updateLabelShowHide(labelEl, axisPointerModel); } }, /** * @private */ _renderHandle: function (value) { if (this._dragging || !this.updateHandleTransform) { return; } var axisPointerModel = this._axisPointerModel; var zr = this._api.getZr(); var handle = this._handle; var handleModel = axisPointerModel.getModel('handle'); var status = axisPointerModel.get('status'); if (!handleModel.get('show') || !status || status === 'hide') { handle && zr.remove(handle); this._handle = null; return; } var isInit; if (!this._handle) { isInit = true; handle = this._handle = graphic.createIcon( handleModel.get('icon'), { cursor: 'move', draggable: true, onmousemove: function (e) { // Fot mobile devicem, prevent screen slider on the button. eventTool.stop(e.event); }, onmousedown: bind(this._onHandleDragMove, this, 0, 0), drift: bind(this._onHandleDragMove, this), ondragend: bind(this._onHandleDragEnd, this) } ); zr.add(handle); } updateMandatoryProps(handle, axisPointerModel, false); // update style var includeStyles = [ 'color', 'borderColor', 'borderWidth', 'opacity', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY' ]; handle.setStyle(handleModel.getItemStyle(null, includeStyles)); // update position var handleSize = handleModel.get('size'); if (!zrUtil.isArray(handleSize)) { handleSize = [handleSize, handleSize]; } handle.attr('scale', [handleSize[0] / 2, handleSize[1] / 2]); throttle.createOrUpdate( this, '_doDispatchAxisPointer', handleModel.get('throttle') || 0, 'fixRate' ); this._moveHandleToValue(value, isInit); }, /** * @private */ _moveHandleToValue: function (value, isInit) { updateProps( this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform( value, this._axisModel, this._axisPointerModel )) ); }, /** * @private */ _onHandleDragMove: function (dx, dy) { var handle = this._handle; if (!handle) { return; } this._dragging = true; // Persistent for throttle. var trans = this.updateHandleTransform( getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel ); this._payloadInfo = trans; handle.stopAnimation(); handle.attr(getHandleTransProps(trans)); get(handle).lastProp = null; this._doDispatchAxisPointer(); }, /** * Throttled method. * @private */ _doDispatchAxisPointer: function () { var handle = this._handle; if (!handle) { return; } var payloadInfo = this._payloadInfo; var axisModel = this._axisModel; this._api.dispatchAction({ type: 'updateAxisPointer', x: payloadInfo.cursorPoint[0], y: payloadInfo.cursorPoint[1], tooltipOption: payloadInfo.tooltipOption, axesInfo: [{ axisDim: axisModel.axis.dim, axisIndex: axisModel.componentIndex }] }); }, /** * @private */ _onHandleDragEnd: function (moveAnimation) { this._dragging = false; var handle = this._handle; if (!handle) { return; } var value = this._axisPointerModel.get('value'); // Consider snap or categroy axis, handle may be not consistent with // axisPointer. So move handle to align the exact value position when // drag ended. this._moveHandleToValue(value); // For the effect: tooltip will be shown when finger holding on handle // button, and will be hidden after finger left handle button. this._api.dispatchAction({ type: 'hideTip' }); }, /** * Should be implemenented by sub-class if support `handle`. * @protected * @param {number} value * @param {module:echarts/model/Model} axisModel * @param {module:echarts/model/Model} axisPointerModel * @return {Object} {position: [x, y], rotation: 0} */ getHandleTransform: null, /** * * Should be implemenented by sub-class if support `handle`. * @protected * @param {Object} transform {position, rotation} * @param {Array.} delta [dx, dy] * @param {module:echarts/model/Model} axisModel * @param {module:echarts/model/Model} axisPointerModel * @return {Object} {position: [x, y], rotation: 0, cursorPoint: [x, y]} */ updateHandleTransform: null, /** * @private */ clear: function (api) { this._lastValue = null; this._lastStatus = null; var zr = api.getZr(); var group = this._group; var handle = this._handle; if (zr && group) { this._lastGraphicKey = null; group && zr.remove(group); handle && zr.remove(handle); this._group = null; this._handle = null; this._payloadInfo = null; } }, /** * @protected */ doClear: function () { // Implemented by sub-class if necessary. }, /** * @protected * @param {Array.} xy * @param {Array.} wh * @param {number} [xDimIndex=0] or 1 */ buildLabel: function (xy, wh, xDimIndex) { xDimIndex = xDimIndex || 0; return { x: xy[xDimIndex], y: xy[1 - xDimIndex], width: wh[xDimIndex], height: wh[1 - xDimIndex] }; } }; BaseAxisPointer.prototype.constructor = BaseAxisPointer; function updateProps(animationModel, moveAnimation, el, props) { // Animation optimize. if (!propsEqual(get(el).lastProp, props)) { get(el).lastProp = props; moveAnimation ? graphic.updateProps(el, props, animationModel) : (el.stopAnimation(), el.attr(props)); } } function propsEqual(lastProps, newProps) { if (zrUtil.isObject(lastProps) && zrUtil.isObject(newProps)) { var equals = true; zrUtil.each(newProps, function (item, key) { equals = equals && propsEqual(lastProps[key], item); }); return !!equals; } else { return lastProps === newProps; } } function updateLabelShowHide(labelEl, axisPointerModel) { labelEl[axisPointerModel.get('label.show') ? 'show' : 'hide'](); } function getHandleTransProps(trans) { return { position: trans.position.slice(), rotation: trans.rotation || 0 }; } function updateMandatoryProps(group, axisPointerModel, silent) { var z = axisPointerModel.get('z'); var zlevel = axisPointerModel.get('zlevel'); group && group.traverse(function (el) { if (el.type !== 'group') { z != null && (el.z = z); zlevel != null && (el.zlevel = zlevel); el.silent = silent; } }); } clazzUtil.enableClassExtend(BaseAxisPointer); module.exports = BaseAxisPointer; /***/ }), /* 309 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var zrUtil = __webpack_require__(4); var graphic = __webpack_require__(20); var textContain = __webpack_require__(8); var formatUtil = __webpack_require__(6); var matrix = __webpack_require__(11); var axisHelper = __webpack_require__(104); var AxisBuilder = __webpack_require__(138); var helper = {}; /** * @param {module:echarts/model/Model} axisPointerModel */ helper.buildElStyle = function (axisPointerModel) { var axisPointerType = axisPointerModel.get('type'); var styleModel = axisPointerModel.getModel(axisPointerType + 'Style'); var style; if (axisPointerType === 'line') { style = styleModel.getLineStyle(); style.fill = null; } else if (axisPointerType === 'shadow') { style = styleModel.getAreaStyle(); style.stroke = null; } return style; }; /** * @param {Function} labelPos {align, verticalAlign, position} */ helper.buildLabelElOption = function ( elOption, axisModel, axisPointerModel, api, labelPos ) { var value = axisPointerModel.get('value'); var text = helper.getValueLabel( value, axisModel.axis, axisModel.ecModel, axisPointerModel.get('seriesDataIndices'), { precision: axisPointerModel.get('label.precision'), formatter: axisPointerModel.get('label.formatter') } ); var labelModel = axisPointerModel.getModel('label'); var paddings = formatUtil.normalizeCssArray(labelModel.get('padding') || 0); var font = labelModel.getFont(); var textRect = textContain.getBoundingRect(text, font); var position = labelPos.position; var width = textRect.width + paddings[1] + paddings[3]; var height = textRect.height + paddings[0] + paddings[2]; // Adjust by align. var align = labelPos.align; align === 'right' && (position[0] -= width); align === 'center' && (position[0] -= width / 2); var verticalAlign = labelPos.verticalAlign; verticalAlign === 'bottom' && (position[1] -= height); verticalAlign === 'middle' && (position[1] -= height / 2); // Not overflow ec container confineInContainer(position, width, height, api); var bgColor = labelModel.get('backgroundColor'); if (!bgColor || bgColor === 'auto') { bgColor = axisModel.get('axisLine.lineStyle.color'); } elOption.label = { shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')}, position: position.slice(), // TODO: rich style: { text: text, textFont: font, textFill: labelModel.getTextColor(), textPosition: 'inside', fill: bgColor, stroke: labelModel.get('borderColor') || 'transparent', lineWidth: labelModel.get('borderWidth') || 0, shadowBlur: labelModel.get('shadowBlur'), shadowColor: labelModel.get('shadowColor'), shadowOffsetX: labelModel.get('shadowOffsetX'), shadowOffsetY: labelModel.get('shadowOffsetY') }, // Lable should be over axisPointer. z2: 10 }; }; // Do not overflow ec container function confineInContainer(position, width, height, api) { var viewWidth = api.getWidth(); var viewHeight = api.getHeight(); position[0] = Math.min(position[0] + width, viewWidth) - width; position[1] = Math.min(position[1] + height, viewHeight) - height; position[0] = Math.max(position[0], 0); position[1] = Math.max(position[1], 0); } /** * @param {number} value * @param {module:echarts/coord/Axis} axis * @param {module:echarts/model/Global} ecModel * @param {Object} opt * @param {Array.} seriesDataIndices * @param {number|string} opt.precision 'auto' or a number * @param {string|Function} opt.formatter label formatter */ helper.getValueLabel = function (value, axis, ecModel, seriesDataIndices, opt) { var text = axis.scale.getLabel( // If `precision` is set, width can be fixed (like '12.00500'), which // helps to debounce when when moving label. value, {precision: opt.precision} ); var formatter = opt.formatter; if (formatter) { var params = { value: axisHelper.getAxisRawValue(axis, value), seriesData: [] }; zrUtil.each(seriesDataIndices, function (idxItem) { var series = ecModel.getSeriesByIndex(idxItem.seriesIndex); var dataIndex = idxItem.dataIndexInside; var dataParams = series && series.getDataParams(dataIndex); dataParams && params.seriesData.push(dataParams); }); if (zrUtil.isString(formatter)) { text = formatter.replace('{value}', text); } else if (zrUtil.isFunction(formatter)) { text = formatter(params); } } return text; }; /** * @param {module:echarts/coord/Axis} axis * @param {number} value * @param {Object} layoutInfo { * rotation, position, labelOffset, labelDirection, labelMargin * } */ helper.getTransformedPosition = function (axis, value, layoutInfo) { var transform = matrix.create(); matrix.rotate(transform, transform, layoutInfo.rotation); matrix.translate(transform, transform, layoutInfo.position); return graphic.applyTransform([ axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0) ], transform); }; helper.buildCartesianSingleLabelElOption = function ( value, elOption, layoutInfo, axisModel, axisPointerModel, api ) { var textLayout = AxisBuilder.innerTextLayout( layoutInfo.rotation, 0, layoutInfo.labelDirection ); layoutInfo.labelMargin = axisPointerModel.get('label.margin'); helper.buildLabelElOption(elOption, axisModel, axisPointerModel, api, { position: helper.getTransformedPosition(axisModel.axis, value, layoutInfo), align: textLayout.textAlign, verticalAlign: textLayout.textVerticalAlign }); }; /** * @param {Array.} p1 * @param {Array.} p2 * @param {number} [xDimIndex=0] or 1 */ helper.makeLineShape = function (p1, p2, xDimIndex) { xDimIndex = xDimIndex || 0; return { x1: p1[xDimIndex], y1: p1[1 - xDimIndex], x2: p2[xDimIndex], y2: p2[1 - xDimIndex] }; }; /** * @param {Array.} xy * @param {Array.} wh * @param {number} [xDimIndex=0] or 1 */ helper.makeRectShape = function (xy, wh, xDimIndex) { xDimIndex = xDimIndex || 0; return { x: xy[xDimIndex], y: xy[1 - xDimIndex], width: wh[xDimIndex], height: wh[1 - xDimIndex] }; }; helper.makeSectorShape = function (cx, cy, r0, r, startAngle, endAngle) { return { cx: cx, cy: cy, r0: r0, r: r, startAngle: startAngle, endAngle: endAngle, clockwise: true }; }; module.exports = helper; /***/ }), /* 310 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var graphic = __webpack_require__(20); var BaseAxisPointer = __webpack_require__(308); var viewHelper = __webpack_require__(309); var singleAxisHelper = __webpack_require__(299); var AxisView = __webpack_require__(139); var XY = ['x', 'y']; var WH = ['width', 'height']; var SingleAxisPointer = BaseAxisPointer.extend({ /** * @override */ makeElOption: function (elOption, value, axisModel, axisPointerModel, api) { var axis = axisModel.axis; var coordSys = axis.coordinateSystem; var otherExtent = getGlobalExtent(coordSys, 1 - getPointDimIndex(axis)); var pixelValue = coordSys.dataToPoint(value)[0]; var axisPointerType = axisPointerModel.get('type'); if (axisPointerType && axisPointerType !== 'none') { var elStyle = viewHelper.buildElStyle(axisPointerModel); var pointerOption = pointerShapeBuilder[axisPointerType]( axis, pixelValue, otherExtent, elStyle ); pointerOption.style = elStyle; elOption.graphicKey = pointerOption.type; elOption.pointer = pointerOption; } var layoutInfo = singleAxisHelper.layout(axisModel); viewHelper.buildCartesianSingleLabelElOption( value, elOption, layoutInfo, axisModel, axisPointerModel, api ); }, /** * @override */ getHandleTransform: function (value, axisModel, axisPointerModel) { var layoutInfo = singleAxisHelper.layout(axisModel, {labelInside: false}); layoutInfo.labelMargin = axisPointerModel.get('handle.margin'); return { position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo), rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0) }; }, /** * @override */ updateHandleTransform: function (transform, delta, axisModel, axisPointerModel) { var axis = axisModel.axis; var coordSys = axis.coordinateSystem; var dimIndex = getPointDimIndex(axis); var axisExtent = getGlobalExtent(coordSys, dimIndex); var currPosition = transform.position; currPosition[dimIndex] += delta[dimIndex]; currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]); currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]); var otherExtent = getGlobalExtent(coordSys, 1 - dimIndex); var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2; var cursorPoint = [cursorOtherValue, cursorOtherValue]; cursorPoint[dimIndex] = currPosition[dimIndex]; return { position: currPosition, rotation: transform.rotation, cursorPoint: cursorPoint, tooltipOption: { verticalAlign: 'middle' } }; } }); var pointerShapeBuilder = { line: function (axis, pixelValue, otherExtent, elStyle) { var targetShape = viewHelper.makeLineShape( [pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getPointDimIndex(axis) ); graphic.subPixelOptimizeLine({ shape: targetShape, style: elStyle }); return { type: 'Line', shape: targetShape }; }, shadow: function (axis, pixelValue, otherExtent, elStyle) { var bandWidth = axis.getBandWidth(); var span = otherExtent[1] - otherExtent[0]; return { type: 'Rect', shape: viewHelper.makeRectShape( [pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getPointDimIndex(axis) ) }; } }; function getPointDimIndex(axis) { return axis.isHorizontal() ? 0 : 1; } function getGlobalExtent(coordSys, dimIndex) { var rect = coordSys.getRect(); return [rect[XY[dimIndex]], rect[XY[dimIndex]] + rect[WH[dimIndex]]]; } AxisView.registerAxisPointerClass('SingleAxisPointer', SingleAxisPointer); module.exports = SingleAxisPointer; /***/ }), /* 311 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; /** * @file Define the themeRiver view's series model * @author Deqing Li(annong035@gmail.com) */ var completeDimensions = __webpack_require__(113); var SeriesModel = __webpack_require__(83); var List = __webpack_require__(101); var zrUtil = __webpack_require__(4); var formatUtil = __webpack_require__(6); var encodeHTML = formatUtil.encodeHTML; var nest = __webpack_require__(258); var DATA_NAME_INDEX = 2; var ThemeRiverSeries = SeriesModel.extend({ type: 'series.themeRiver', dependencies: ['singleAxis'], /** * @readOnly * @type {module:zrender/core/util#HashMap} */ nameMap: null, /** * @override */ init: function (option) { ThemeRiverSeries.superApply(this, 'init', arguments); // Put this function here is for the sake of consistency of code // Enable legend selection for each data item // Use a function instead of direct access because data reference may changed this.legendDataProvider = function () { return this.getRawData(); }; }, /** * If there is no value of a certain point in the time for some event,set it value to 0. * * @param {Array} data initial data in the option * @return {Array} */ fixData: function (data) { var rawDataLength = data.length; // grouped data by name var dataByName = nest() .key(function (dataItem) { return dataItem[2]; }) .entries(data); // data group in each layer var layData = zrUtil.map(dataByName, function (d) { return { name: d.key, dataList: d.values }; }); var layerNum = layData.length; var largestLayer = -1; var index = -1; for (var i = 0; i < layerNum; ++i) { var len = layData[i].dataList.length; if (len > largestLayer) { largestLayer = len; index = i; } } for (var k = 0; k < layerNum; ++k) { if (k === index) { continue; } var name = layData[k].name; for (var j = 0; j < largestLayer; ++j) { var timeValue = layData[index].dataList[j][0]; var length = layData[k].dataList.length; var keyIndex = -1; for (var l = 0; l < length; ++l) { var value = layData[k].dataList[l][0]; if (value === timeValue) { keyIndex = l; break; } } if (keyIndex === -1) { data[rawDataLength] = []; data[rawDataLength][0] = timeValue; data[rawDataLength][1] = 0; data[rawDataLength][2] = name; rawDataLength++; } } } return data; }, /** * @override * @param {Object} option the initial option that user gived * @param {module:echarts/model/Model} ecModel the model object for themeRiver option * @return {module:echarts/data/List} */ getInitialData: function (option, ecModel) { var dimensions = []; var singleAxisModel = ecModel.queryComponents({ mainType: 'singleAxis', index: this.get('singleAxisIndex'), id: this.get('singleAxisId') })[0]; var axisType = singleAxisModel.get('type'); dimensions = [ { name: 'time', // FIXME common? type: axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float' }, { name: 'value', type: 'float' }, { name: 'name', type: 'ordinal' } ]; // filter the data item with the value of label is undefined var filterData = zrUtil.filter(option.data, function (dataItem) { return dataItem[2] !== undefined; }); var data = this.fixData(filterData || []); var nameList = []; var nameMap = this.nameMap = zrUtil.createHashMap(); var count = 0; for (var i = 0; i < data.length; ++i) { nameList.push(data[i][DATA_NAME_INDEX]); if (!nameMap.get(data[i][DATA_NAME_INDEX])) { nameMap.set(data[i][DATA_NAME_INDEX], count); count++; } } dimensions = completeDimensions(dimensions, data); var list = new List(dimensions, this); list.initData(data, nameList); return list; }, /** * Used by single coordinate * * @param {string} axisDim the dimension for single coordinate * @return {Array. } specified dimensions on the axis. */ coordDimToDataDim: function (axisDim) { return ['time']; }, /** * The raw data is divided into multiple layers and each layer * has same name. * * @return {Array.} */ getLayerSeries: function () { var data = this.getData(); var lenCount = data.count(); var indexArr = []; for (var i = 0; i < lenCount; ++i) { indexArr[i] = i; } // data group by name var dataByName = nest() .key(function (index) { return data.get('name', index); }) .entries(indexArr); var layerSeries = zrUtil.map(dataByName, function (d) { return { name: d.key, indices: d.values }; }); for (var j = 0; j < layerSeries.length; ++j) { layerSeries[j].indices.sort(comparer); } function comparer(index1, index2) { return data.get('time', index1) - data.get('time', index2); } return layerSeries; }, /** * Get data indices for show tooltip content * * @param {Array.|string} dim single coordinate dimension * @param {number} value axis value * @param {module:echarts/coord/single/SingleAxis} baseAxis single Axis used * the themeRiver. * @return {Object} {dataIndices, nestestValue} */ getAxisTooltipData: function (dim, value, baseAxis) { if (!zrUtil.isArray(dim)) { dim = dim ? [dim] : []; } var data = this.getData(); var layerSeries = this.getLayerSeries(); var indices = []; var layerNum = layerSeries.length; var nestestValue; for (var i = 0; i < layerNum; ++i) { var minDist = Number.MAX_VALUE; var nearestIdx = -1; var pointNum = layerSeries[i].indices.length; for (var j = 0; j < pointNum; ++j) { var theValue = data.get(dim[0], layerSeries[i].indices[j]); var dist = Math.abs(theValue - value); if (dist max) { max = temp; } sums.push(temp); } for (var k = 0; k < pointNum; ++k) { y0[k] = (max - sums[k]) / 2; } max = 0; for (var l = 0; l < pointNum; ++l) { var sum = sums[l] + y0[l]; if (sum > max) { max = sum; } } base.y0 = y0; base.max = max; return base; } /***/ }), /* 315 */ /***/ (function(module, exports) { /** * @file Visual encoding for themeRiver view * @author Deqing Li(annong035@gmail.com) */ module.exports = function (ecModel) { ecModel.eachSeriesByType('themeRiver', function (seriesModel) { var data = seriesModel.getData(); var rawData = seriesModel.getRawData(); var colorList = seriesModel.get('color'); data.each(function (index) { var name = data.getName(index); var color = colorList[(seriesModel.nameMap.get(name) - 1) % colorList.length]; rawData.setItemVisual(index, 'color', color); }); }); }; /***/ }), /* 316 */ /***/ (function(module, exports, __webpack_require__) { var echarts = __webpack_require__(1); var zrUtil = __webpack_require__(4); var graphicUtil = __webpack_require__(20); var labelHelper = __webpack_require__(121); var createListFromArray = __webpack_require__(112); var barGrid = __webpack_require__(148); var DataDiffer = __webpack_require__(102); var ITEM_STYLE_NORMAL_PATH = ['itemStyle', 'normal']; var ITEM_STYLE_EMPHASIS_PATH = ['itemStyle', 'emphasis']; var LABEL_NORMAL = ['label', 'normal']; var LABEL_EMPHASIS = ['label', 'emphasis']; // Use prefix to avoid index to be the same as el.name, // which will cause weird udpate animation. var GROUP_DIFF_PREFIX = 'e\\0\\0'; /** * To reduce total package size of each coordinate systems, the modules `prepareCustom` * of each coordinate systems are not required by each coordinate systems directly, but * required by the module `custom`. * * prepareInfoForCustomSeries {Function}: optional * @return {Object} {coordSys: {...}, api: { * coord: function (data, clamp) {}, // return point in global. * size: function (dataSize, dataItem) {} // return size of each axis in coordSys. * }} */ var prepareCustoms = { cartesian2d: __webpack_require__(317), geo: __webpack_require__(318), singleAxis: __webpack_require__(319), polar: __webpack_require__(320), calendar: __webpack_require__(321) }; // ------ // Model // ------ echarts.extendSeriesModel({ type: 'series.custom', dependencies: ['grid', 'polar', 'geo', 'singleAxis', 'calendar'], defaultOption: { coordinateSystem: 'cartesian2d', // Can be set as 'none' zlevel: 0, z: 2, legendHoverLink: true // Cartesian coordinate system // xAxisIndex: 0, // yAxisIndex: 0, // Polar coordinate system // polarIndex: 0, // Geo coordinate system // geoIndex: 0, // label: {} // itemStyle: {} }, getInitialData: function (option, ecModel) { return createListFromArray(option.data, this, ecModel); } }); // ----- // View // ----- echarts.extendChartView({ type: 'custom', /** * @private * @type {module:echarts/data/List} */ _data: null, /** * @override */ render: function (customSeries, ecModel, api) { var oldData = this._data; var data = customSeries.getData(); var group = this.group; var renderItem = makeRenderItem(customSeries, data, ecModel, api); data.diff(oldData) .add(function (newIdx) { data.hasValue(newIdx) && createOrUpdate( null, newIdx, renderItem(newIdx), customSeries, group, data ); }) .update(function (newIdx, oldIdx) { var el = oldData.getItemGraphicEl(oldIdx); data.hasValue(newIdx) ? createOrUpdate( el, newIdx, renderItem(newIdx), customSeries, group, data ) : (el && group.remove(el)); }) .remove(function (oldIdx) { var el = oldData.getItemGraphicEl(oldIdx); el && group.remove(el); }) .execute(); this._data = data; }, /** * @override */ dispose: zrUtil.noop }); function createEl(elOption) { var graphicType = elOption.type; var el; if (graphicType === 'path') { var shape = elOption.shape; el = graphicUtil.makePath( shape.pathData, null, { x: shape.x || 0, y: shape.y || 0, width: shape.width || 0, height: shape.height || 0 }, 'center' ); el.__customPathData = elOption.pathData; } else if (graphicType === 'image') { el = new graphicUtil.Image({ }); el.__customImagePath = elOption.style.image; } else if (graphicType === 'text') { el = new graphicUtil.Text({ }); el.__customText = elOption.style.text; } else { var Clz = graphicUtil[graphicType.charAt(0).toUpperCase() + graphicType.slice(1)]; if (true) { zrUtil.assert(Clz, 'graphic type \"' + graphicType + '\" can not be found.'); } el = new Clz(); } el.__customGraphicType = graphicType; el.name = elOption.name; return el; } function updateEl(el, dataIndex, elOption, animatableModel, data, isInit) { var targetProps = {}; var elOptionStyle = elOption.style || {}; elOption.shape && (targetProps.shape = zrUtil.clone(elOption.shape)); elOption.position && (targetProps.position = elOption.position.slice()); elOption.scale && (targetProps.scale = elOption.scale.slice()); elOption.origin && (targetProps.origin = elOption.origin.slice()); elOption.rotation && (targetProps.rotation = elOption.rotation); if (el.type === 'image' && elOption.style) { var targetStyle = targetProps.style = {}; zrUtil.each(['x', 'y', 'width', 'height'], function (prop) { prepareStyleTransition(prop, targetStyle, elOptionStyle, el.style, isInit); }); } if (el.type === 'text' && elOption.style) { var targetStyle = targetProps.style = {}; zrUtil.each(['x', 'y'], function (prop) { prepareStyleTransition(prop, targetStyle, elOptionStyle, el.style, isInit); }); // Compatible with previous: both support // textFill and fill, textStroke and stroke in 'text' element. !elOptionStyle.hasOwnProperty('textFill') && elOptionStyle.fill && ( elOptionStyle.textFill = elOptionStyle.fill ); !elOptionStyle.hasOwnProperty('textStroke') && elOptionStyle.stroke && ( elOptionStyle.textStroke = elOptionStyle.stroke ); } if (el.type !== 'group') { el.useStyle(elOptionStyle); // Init animation. if (isInit) { el.style.opacity = 0; var targetOpacity = elOptionStyle.opacity; targetOpacity == null && (targetOpacity = 1); graphicUtil.initProps(el, {style: {opacity: targetOpacity}}, animatableModel, dataIndex); } } if (isInit) { el.attr(targetProps); } else { graphicUtil.updateProps(el, targetProps, animatableModel, dataIndex); } // z2 must not be null/undefined, otherwise sort error may occur. el.attr({z2: elOption.z2 || 0, silent: elOption.silent}); elOption.styleEmphasis !== false && graphicUtil.setHoverStyle(el, elOption.styleEmphasis); } function prepareStyleTransition(prop, targetStyle, elOptionStyle, oldElStyle, isInit) { if (elOptionStyle[prop] != null && !isInit) { targetStyle[prop] = elOptionStyle[prop]; elOptionStyle[prop] = oldElStyle[prop]; } } function makeRenderItem(customSeries, data, ecModel, api) { var renderItem = customSeries.get('renderItem'); var coordSys = customSeries.coordinateSystem; var prepareResult = {}; if (coordSys) { if (true) { zrUtil.assert(renderItem, 'series.render is required.'); zrUtil.assert( coordSys.prepareCustoms || prepareCustoms[coordSys.type], 'This coordSys does not support custom series.' ); } prepareResult = coordSys.prepareCustoms ? coordSys.prepareCustoms() : prepareCustoms[coordSys.type](coordSys); } var userAPI = zrUtil.defaults({ getWidth: api.getWidth, getHeight: api.getHeight, getZr: api.getZr, getDevicePixelRatio: api.getDevicePixelRatio, value: value, style: style, styleEmphasis: styleEmphasis, visual: visual, barLayout: barLayout, currentSeriesIndices: currentSeriesIndices, font: font }, prepareResult.api || {}); var userParams = { context: {}, seriesId: customSeries.id, seriesName: customSeries.name, seriesIndex: customSeries.seriesIndex, coordSys: prepareResult.coordSys, dataInsideLength: data.count(), encode: wrapEncodeDef(customSeries.getData()) }; // Do not support call `api` asynchronously without dataIndexInside input. var currDataIndexInside; var currDirty = true; var currItemModel; var currLabelNormalModel; var currLabelEmphasisModel; var currLabelValueDim; var currVisualColor; return function (dataIndexInside) { currDataIndexInside = dataIndexInside; currDirty = true; return renderItem && renderItem( zrUtil.defaults({ dataIndexInside: dataIndexInside, dataIndex: data.getRawIndex(dataIndexInside) }, userParams), userAPI ) || {}; }; // Do not update cache until api called. function updateCache(dataIndexInside) { dataIndexInside == null && (dataIndexInside = currDataIndexInside); if (currDirty) { currItemModel = data.getItemModel(dataIndexInside); currLabelNormalModel = currItemModel.getModel(LABEL_NORMAL); currLabelEmphasisModel = currItemModel.getModel(LABEL_EMPHASIS); currLabelValueDim = labelHelper.findLabelValueDim(data); currVisualColor = data.getItemVisual(dataIndexInside, 'color'); currDirty = false; } } /** * @public * @param {number|string} dim * @param {number} [dataIndexInside=currDataIndexInside] * @return {number|string} value */ function value(dim, dataIndexInside) { dataIndexInside == null && (dataIndexInside = currDataIndexInside); return data.get(data.getDimension(dim || 0), dataIndexInside); } /** * By default, `visual` is applied to style (to support visualMap). * `visual.color` is applied at `fill`. If user want apply visual.color on `stroke`, * it can be implemented as: * `api.style({stroke: api.visual('color'), fill: null})`; * @public * @param {Object} [extra] * @param {number} [dataIndexInside=currDataIndexInside] */ function style(extra, dataIndexInside) { dataIndexInside == null && (dataIndexInside = currDataIndexInside); updateCache(dataIndexInside); var itemStyle = currItemModel.getModel(ITEM_STYLE_NORMAL_PATH).getItemStyle(); currVisualColor != null && (itemStyle.fill = currVisualColor); var opacity = data.getItemVisual(dataIndexInside, 'opacity'); opacity != null && (itemStyle.opacity = opacity); if (currLabelValueDim != null) { graphicUtil.setTextStyle(itemStyle, currLabelNormalModel, null, { autoColor: currVisualColor, isRectText: true }); itemStyle.text = currLabelNormalModel.getShallow('show') ? zrUtil.retrieve2( customSeries.getFormattedLabel(dataIndexInside, 'normal'), data.get(currLabelValueDim, dataIndexInside) ) : null; } extra && zrUtil.extend(itemStyle, extra); return itemStyle; } /** * @public * @param {Object} [extra] * @param {number} [dataIndexInside=currDataIndexInside] */ function styleEmphasis(extra, dataIndexInside) { dataIndexInside == null && (dataIndexInside = currDataIndexInside); updateCache(dataIndexInside); var itemStyle = currItemModel.getModel(ITEM_STYLE_EMPHASIS_PATH).getItemStyle(); if (currLabelValueDim != null) { graphicUtil.setTextStyle(itemStyle, currLabelEmphasisModel, null, { isRectText: true }, true); itemStyle.text = currLabelEmphasisModel.getShallow('show') ? zrUtil.retrieve3( customSeries.getFormattedLabel(dataIndexInside, 'emphasis'), customSeries.getFormattedLabel(dataIndexInside, 'normal'), data.get(currLabelValueDim, dataIndexInside) ) : null; } extra && zrUtil.extend(itemStyle, extra); return itemStyle; } /** * @public * @param {string} visualType * @param {number} [dataIndexInside=currDataIndexInside] */ function visual(visualType, dataIndexInside) { dataIndexInside == null && (dataIndexInside = currDataIndexInside); return data.getItemVisual(dataIndexInside, visualType); } /** * @public * @param {number} opt.count Positive interger. * @param {number} [opt.barWidth] * @param {number} [opt.barMaxWidth] * @param {number} [opt.barGap] * @param {number} [opt.barCategoryGap] * @return {Object} {width, offset, offsetCenter} is not support, return undefined. */ function barLayout(opt) { if (coordSys.getBaseAxis) { var baseAxis = coordSys.getBaseAxis(); return barGrid.getLayoutOnAxis(zrUtil.defaults({axis: baseAxis}, opt), api); } } /** * @public * @return {Array.} */ function currentSeriesIndices() { return ecModel.getCurrentSeriesIndices(); } /** * @public * @param {Object} opt * @param {string} [opt.fontStyle] * @param {number} [opt.fontWeight] * @param {number} [opt.fontSize] * @param {string} [opt.fontFamily] * @return {string} font string */ function font(opt) { return graphicUtil.getFont(opt, ecModel); } } function wrapEncodeDef(data) { var encodeDef = {}; zrUtil.each(data.dimensions, function (dimName, dataDimIndex) { var dimInfo = data.getDimensionInfo(dimName); if (!dimInfo.isExtraCoord) { var coordDim = dimInfo.coordDim; var dataDims = encodeDef[coordDim] = encodeDef[coordDim] || []; dataDims[dimInfo.coordDimIndex] = dataDimIndex; } }); return encodeDef; } function createOrUpdate(el, dataIndex, elOption, animatableModel, group, data) { el = doCreateOrUpdate(el, dataIndex, elOption, animatableModel, group, data); el && data.setItemGraphicEl(dataIndex, el); } function doCreateOrUpdate(el, dataIndex, elOption, animatableModel, group, data) { var elOptionType = elOption.type; if (el && elOptionType !== el.__customGraphicType && (elOptionType !== 'path' || elOption.pathData !== el.__customPathData) && (elOptionType !== 'image' || elOption.style.image !== el.__customImagePath) && (elOptionType !== 'text' || elOption.style.text !== el.__customText) ) { group.remove(el); el = null; } // `elOption.type` is undefined when `renderItem` returns nothing. if (elOptionType == null) { return; } var isInit = !el; !el && (el = createEl(elOption)); updateEl(el, dataIndex, elOption, animatableModel, data, isInit); if (elOptionType === 'group') { var oldChildren = el.children() || []; var newChildren = elOption.children || []; if (elOption.diffChildrenByName) { // lower performance. diffGroupChildren({ oldChildren: oldChildren, newChildren: newChildren, dataIndex: dataIndex, animatableModel: animatableModel, group: el, data: data }); } else { // better performance. var index = 0; for (; index < newChildren.length; index++) { doCreateOrUpdate( el.childAt(index), dataIndex, newChildren[index], animatableModel, el, data ); } for (; index < oldChildren.length; index++) { oldChildren[index] && el.remove(oldChildren[index]); } } } group.add(el); return el; } function diffGroupChildren(context) { (new DataDiffer( context.oldChildren, context.newChildren, getKey, getKey, context )) .add(processAddUpdate) .update(processAddUpdate) .remove(processRemove) .execute(); } function getKey(item, idx) { var name = item && item.name; return name != null ? name : GROUP_DIFF_PREFIX + idx; } function processAddUpdate(newIndex, oldIndex) { var context = this.context; var childOption = newIndex != null ? context.newChildren[newIndex] : null; var child = oldIndex != null ? context.oldChildren[oldIndex] : null; doCreateOrUpdate( child, context.dataIndex, childOption, context.animatableModel, context.group, context.data ); } function processRemove(oldIndex) { var context = this.context; var child = context.oldChildren[oldIndex]; child && context.group.remove(child); } /***/ }), /* 317 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); function dataToCoordSize(dataSize, dataItem) { // dataItem is necessary in log axis. dataItem = dataItem || [0, 0]; return zrUtil.map(['x', 'y'], function (dim, dimIdx) { var axis = this.getAxis(dim); var val = dataItem[dimIdx]; var halfSize = dataSize[dimIdx] / 2; return axis.type === 'category' ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize)); }, this); } function prepareCustom(coordSys) { var rect = coordSys.grid.getRect(); return { coordSys: { // The name exposed to user is always 'cartesian2d' but not 'grid'. type: 'cartesian2d', x: rect.x, y: rect.y, width: rect.width, height: rect.height }, api: { coord: zrUtil.bind(coordSys.dataToPoint, coordSys), size: zrUtil.bind(dataToCoordSize, coordSys) } }; } module.exports = prepareCustom; /***/ }), /* 318 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); function dataToCoordSize(dataSize, dataItem) { dataItem = dataItem || [0, 0]; return zrUtil.map([0, 1], function (dimIdx) { var val = dataItem[dimIdx]; var halfSize = dataSize[dimIdx] / 2; var p1 = []; var p2 = []; p1[dimIdx] = val - halfSize; p2[dimIdx] = val + halfSize; p1[1 - dimIdx] = p2[1 - dimIdx] = dataItem[1 - dimIdx]; return Math.abs(this.dataToPoint(p1)[dimIdx] - this.dataToPoint(p2)[dimIdx]); }, this); } function prepareCustom(coordSys) { var rect = coordSys.getBoundingRect(); return { coordSys: { type: 'geo', x: rect.x, y: rect.y, width: rect.width, height: rect.height }, api: { coord: zrUtil.bind(coordSys.dataToPoint, coordSys), size: zrUtil.bind(dataToCoordSize, coordSys) } }; } module.exports = prepareCustom; /***/ }), /* 319 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); function dataToCoordSize(dataSize, dataItem) { // dataItem is necessary in log axis. var axis = this.getAxis(); var val = dataItem instanceof Array ? dataItem[0] : dataItem; var halfSize = (dataSize instanceof Array ? dataSize[0] : dataSize) / 2; return axis.type === 'category' ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize)); } function prepareCustom(coordSys) { var rect = coordSys.getRect(); return { coordSys: { type: 'singleAxis', x: rect.x, y: rect.y, width: rect.width, height: rect.height }, api: { coord: zrUtil.bind(coordSys.dataToPoint, coordSys), size: zrUtil.bind(dataToCoordSize, coordSys) } }; } module.exports = prepareCustom; /***/ }), /* 320 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); function dataToCoordSize(dataSize, dataItem) { // dataItem is necessary in log axis. return zrUtil.map(['Radius', 'Angle'], function (dim, dimIdx) { var axis = this['get' + dim + 'Axis'](); var val = dataItem[dimIdx]; var halfSize = dataSize[dimIdx] / 2; var method = 'dataTo' + dim; var result = axis.type === 'category' ? axis.getBandWidth() : Math.abs(axis[method](val - halfSize) - axis[method](val + halfSize)); if (dim === 'Angle') { result = result * Math.PI / 180; } return result; }, this); } function prepareCustom(coordSys) { var radiusAxis = coordSys.getRadiusAxis(); var angleAxis = coordSys.getAngleAxis(); var radius = radiusAxis.getExtent(); radius[0] > radius[1] && radius.reverse(); return { coordSys: { type: 'polar', cx: coordSys.cx, cy: coordSys.cy, r: radius[1], r0: radius[0] }, api: { coord: zrUtil.bind(function (data) { var radius = radiusAxis.dataToRadius(data[0]); var angle = angleAxis.dataToAngle(data[1]); var coord = coordSys.coordToPoint([radius, angle]); coord.push(radius, angle * Math.PI / 180); return coord; }), size: zrUtil.bind(dataToCoordSize, coordSys) } }; } module.exports = prepareCustom; /***/ }), /* 321 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); function prepareCustom(coordSys) { var rect = coordSys.getRect(); var rangeInfo = coordSys.getRangeInfo(); return { coordSys: { type: 'calendar', x: rect.x, y: rect.y, width: rect.width, height: rect.height, cellWidth: coordSys.getCellWidth(), cellHeight: coordSys.getCellHeight(), rangeInfo: { start: rangeInfo.start, end: rangeInfo.end, weeks: rangeInfo.weeks, dayCount: rangeInfo.allDay } }, api: { coord: zrUtil.bind(coordSys.dataToPoint, coordSys) } }; } module.exports = prepareCustom; /***/ }), /* 322 */ /***/ (function(module, exports, __webpack_require__) { var echarts = __webpack_require__(1); var zrUtil = __webpack_require__(4); var modelUtil = __webpack_require__(5); var graphicUtil = __webpack_require__(20); var layoutUtil = __webpack_require__(74); // ------------- // Preprocessor // ------------- echarts.registerPreprocessor(function (option) { var graphicOption = option.graphic; // Convert // {graphic: [{left: 10, type: 'circle'}, ...]} // or // {graphic: {left: 10, type: 'circle'}} // to // {graphic: [{elements: [{left: 10, type: 'circle'}, ...]}]} if (zrUtil.isArray(graphicOption)) { if (!graphicOption[0] || !graphicOption[0].elements) { option.graphic = [{elements: graphicOption}]; } else { // Only one graphic instance can be instantiated. (We dont // want that too many views are created in echarts._viewMap) option.graphic = [option.graphic[0]]; } } else if (graphicOption && !graphicOption.elements) { option.graphic = [{elements: [graphicOption]}]; } }); // ------ // Model // ------ var GraphicModel = echarts.extendComponentModel({ type: 'graphic', defaultOption: { // Extra properties for each elements: // // left/right/top/bottom: (like 12, '22%', 'center', default undefined) // If left/rigth is set, shape.x/shape.cx/position will not be used. // If top/bottom is set, shape.y/shape.cy/position will not be used. // This mechanism is useful when you want to position a group/element // against the right side or the center of this container. // // width/height: (can only be pixel value, default 0) // Only be used to specify contianer(group) size, if needed. And // can not be percentage value (like '33%'). See the reason in the // layout algorithm below. // // bounding: (enum: 'all' (default) | 'raw') // Specify how to calculate boundingRect when locating. // 'all': Get uioned and transformed boundingRect // from both itself and its descendants. // This mode simplies confining a group of elements in the bounding // of their ancester container (e.g., using 'right: 0'). // 'raw': Only use the boundingRect of itself and before transformed. // This mode is similar to css behavior, which is useful when you // want an element to be able to overflow its container. (Consider // a rotated circle needs to be located in a corner.) // Note: elements is always behind its ancestors in this elements array. elements: [], parentId: null }, /** * Save el options for the sake of the performance (only update modified graphics). * The order is the same as those in option. (ancesters -> descendants) * * @private * @type {Array.} */ _elOptionsToUpdate: null, /** * @override */ mergeOption: function (option) { // Prevent default merge to elements var elements = this.option.elements; this.option.elements = null; GraphicModel.superApply(this, 'mergeOption', arguments); this.option.elements = elements; }, /** * @override */ optionUpdated: function (newOption, isInit) { var thisOption = this.option; var newList = (isInit ? thisOption : newOption).elements; var existList = thisOption.elements = isInit ? [] : thisOption.elements; var flattenedList = []; this._flatten(newList, flattenedList); var mappingResult = modelUtil.mappingToExists(existList, flattenedList); modelUtil.makeIdAndName(mappingResult); // Clear elOptionsToUpdate var elOptionsToUpdate = this._elOptionsToUpdate = []; zrUtil.each(mappingResult, function (resultItem, index) { var newElOption = resultItem.option; if (true) { zrUtil.assert( zrUtil.isObject(newElOption) || resultItem.exist, 'Empty graphic option definition' ); } if (!newElOption) { return; } elOptionsToUpdate.push(newElOption); setKeyInfoToNewElOption(resultItem, newElOption); mergeNewElOptionToExist(existList, index, newElOption); setLayoutInfoToExist(existList[index], newElOption); }, this); // Clean for (var i = existList.length - 1; i >= 0; i--) { if (existList[i] == null) { existList.splice(i, 1); } else { // $action should be volatile, otherwise option gotten from // `getOption` will contain unexpected $action. delete existList[i].$action; } } }, /** * Convert * [{ * type: 'group', * id: 'xx', * children: [{type: 'circle'}, {type: 'polygon'}] * }] * to * [ * {type: 'group', id: 'xx'}, * {type: 'circle', parentId: 'xx'}, * {type: 'polygon', parentId: 'xx'} * ] * * @private * @param {Array.} optionList option list * @param {Array.} result result of flatten * @param {Object} parentOption parent option */ _flatten: function (optionList, result, parentOption) { zrUtil.each(optionList, function (option) { if (!option) { return; } if (parentOption) { option.parentOption = parentOption; } result.push(option); var children = option.children; if (option.type === 'group' && children) { this._flatten(children, result, option); } // Deleting for JSON output, and for not affecting group creation. delete option.children; }, this); }, // FIXME // Pass to view using payload? setOption has a payload? useElOptionsToUpdate: function () { var els = this._elOptionsToUpdate; // Clear to avoid render duplicately when zooming. this._elOptionsToUpdate = null; return els; } }); // ----- // View // ----- echarts.extendComponentView({ type: 'graphic', /** * @override */ init: function (ecModel, api) { /** * @private * @type {module:zrender/core/util.HashMap} */ this._elMap = zrUtil.createHashMap(); /** * @private * @type {module:echarts/graphic/GraphicModel} */ this._lastGraphicModel; }, /** * @override */ render: function (graphicModel, ecModel, api) { // Having leveraged between use cases and algorithm complexity, a very // simple layout mechanism is used: // The size(width/height) can be determined by itself or its parent (not // implemented yet), but can not by its children. (Top-down travel) // The location(x/y) can be determined by the bounding rect of itself // (can including its descendants or not) and the size of its parent. // (Bottom-up travel) // When `chart.clear()` or `chart.setOption({...}, true)` with the same id, // view will be reused. if (graphicModel !== this._lastGraphicModel) { this._clear(); } this._lastGraphicModel = graphicModel; this._updateElements(graphicModel, api); this._relocate(graphicModel, api); }, /** * Update graphic elements. * * @private * @param {Object} graphicModel graphic model * @param {module:echarts/ExtensionAPI} api extension API */ _updateElements: function (graphicModel, api) { var elOptionsToUpdate = graphicModel.useElOptionsToUpdate(); if (!elOptionsToUpdate) { return; } var elMap = this._elMap; var rootGroup = this.group; // Top-down tranverse to assign graphic settings to each elements. zrUtil.each(elOptionsToUpdate, function (elOption) { var $action = elOption.$action; var id = elOption.id; var existEl = elMap.get(id); var parentId = elOption.parentId; var targetElParent = parentId != null ? elMap.get(parentId) : rootGroup; if (elOption.type === 'text') { var elOptionStyle = elOption.style; // In top/bottom mode, textVerticalAlign should not be used, which cause // inaccurately locating. if (elOption.hv && elOption.hv[1]) { elOptionStyle.textVerticalAlign = elOptionStyle.textBaseline = null; } // Compatible with previous setting: both support fill and textFill, // stroke and textStroke. !elOptionStyle.hasOwnProperty('textFill') && elOptionStyle.fill && ( elOptionStyle.textFill = elOptionStyle.fill ); !elOptionStyle.hasOwnProperty('textStroke') && elOptionStyle.stroke && ( elOptionStyle.textStroke = elOptionStyle.stroke ); } // Remove unnecessary props to avoid potential problems. var elOptionCleaned = getCleanedElOption(elOption); // For simple, do not support parent change, otherwise reorder is needed. if (true) { existEl && zrUtil.assert( targetElParent === existEl.parent, 'Changing parent is not supported.' ); } if (!$action || $action === 'merge') { existEl ? existEl.attr(elOptionCleaned) : createEl(id, targetElParent, elOptionCleaned, elMap); } else if ($action === 'replace') { removeEl(existEl, elMap); createEl(id, targetElParent, elOptionCleaned, elMap); } else if ($action === 'remove') { removeEl(existEl, elMap); } var el = elMap.get(id); if (el) { el.__ecGraphicWidth = elOption.width; el.__ecGraphicHeight = elOption.height; } }); }, /** * Locate graphic elements. * * @private * @param {Object} graphicModel graphic model * @param {module:echarts/ExtensionAPI} api extension API */ _relocate: function (graphicModel, api) { var elOptions = graphicModel.option.elements; var rootGroup = this.group; var elMap = this._elMap; // Bottom-up tranvese all elements (consider ec resize) to locate elements. for (var i = elOptions.length - 1; i >= 0; i--) { var elOption = elOptions[i]; var el = elMap.get(elOption.id); if (!el) { continue; } var parentEl = el.parent; var containerInfo = parentEl === rootGroup ? { width: api.getWidth(), height: api.getHeight() } : { // Like 'position:absolut' in css, default 0. width: parentEl.__ecGraphicWidth || 0, height: parentEl.__ecGraphicHeight || 0 }; layoutUtil.positionElement( el, elOption, containerInfo, null, {hv: elOption.hv, boundingMode: elOption.bounding} ); } }, /** * Clear all elements. * * @private */ _clear: function () { var elMap = this._elMap; elMap.each(function (el) { removeEl(el, elMap); }); this._elMap = zrUtil.createHashMap(); }, /** * @override */ dispose: function () { this._clear(); } }); function createEl(id, targetElParent, elOption, elMap) { var graphicType = elOption.type; if (true) { zrUtil.assert(graphicType, 'graphic type MUST be set'); } var Clz = graphicUtil[graphicType.charAt(0).toUpperCase() + graphicType.slice(1)]; if (true) { zrUtil.assert(Clz, 'graphic type can not be found'); } var el = new Clz(elOption); targetElParent.add(el); elMap.set(id, el); el.__ecGraphicId = id; } function removeEl(existEl, elMap) { var existElParent = existEl && existEl.parent; if (existElParent) { existEl.type === 'group' && existEl.traverse(function (el) { removeEl(el, elMap); }); elMap.removeKey(existEl.__ecGraphicId); existElParent.remove(existEl); } } // Remove unnecessary props to avoid potential problems. function getCleanedElOption(elOption) { elOption = zrUtil.extend({}, elOption); zrUtil.each( ['id', 'parentId', '$action', 'hv', 'bounding'].concat(layoutUtil.LOCATION_PARAMS), function (name) { delete elOption[name]; } ); return elOption; } function isSetLoc(obj, props) { var isSet; zrUtil.each(props, function (prop) { obj[prop] != null && obj[prop] !== 'auto' && (isSet = true); }); return isSet; } function setKeyInfoToNewElOption(resultItem, newElOption) { var existElOption = resultItem.exist; // Set id and type after id assigned. newElOption.id = resultItem.keyInfo.id; !newElOption.type && existElOption && (newElOption.type = existElOption.type); // Set parent id if not specified if (newElOption.parentId == null) { var newElParentOption = newElOption.parentOption; if (newElParentOption) { newElOption.parentId = newElParentOption.id; } else if (existElOption) { newElOption.parentId = existElOption.parentId; } } // Clear newElOption.parentOption = null; } function mergeNewElOptionToExist(existList, index, newElOption) { // Update existing options, for `getOption` feature. var newElOptCopy = zrUtil.extend({}, newElOption); var existElOption = existList[index]; var $action = newElOption.$action || 'merge'; if ($action === 'merge') { if (existElOption) { if (true) { var newType = newElOption.type; zrUtil.assert( !newType || existElOption.type === newType, 'Please set $action: \"replace\" to change `type`' ); } // We can ensure that newElOptCopy and existElOption are not // the same object, so `merge` will not change newElOptCopy. zrUtil.merge(existElOption, newElOptCopy, true); // Rigid body, use ignoreSize. layoutUtil.mergeLayoutParam(existElOption, newElOptCopy, {ignoreSize: true}); // Will be used in render. layoutUtil.copyLayoutParams(newElOption, existElOption); } else { existList[index] = newElOptCopy; } } else if ($action === 'replace') { existList[index] = newElOptCopy; } else if ($action === 'remove') { // null will be cleaned later. existElOption && (existList[index] = null); } } function setLayoutInfoToExist(existItem, newElOption) { if (!existItem) { return; } existItem.hv = newElOption.hv = [ // Rigid body, dont care `width`. isSetLoc(newElOption, ['left', 'right']), // Rigid body, dont care `height`. isSetLoc(newElOption, ['top', 'bottom']) ]; // Give default group size. Otherwise layout error may occur. if (existItem.type === 'group') { existItem.width == null && (existItem.width = newElOption.width = 0); existItem.height == null && (existItem.height = newElOption.height = 0); } } /***/ }), /* 323 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(127); __webpack_require__(307); __webpack_require__(301); /***/ }), /* 324 */ /***/ (function(module, exports, __webpack_require__) { /** * Legend component entry file8 */ __webpack_require__(325); __webpack_require__(331); __webpack_require__(332); __webpack_require__(333); /***/ }), /* 325 */ /***/ (function(module, exports, __webpack_require__) { // Do not contain scrollable legend, for sake of file size. __webpack_require__(326); __webpack_require__(327); __webpack_require__(328); var echarts = __webpack_require__(1); // Series Filter echarts.registerProcessor(__webpack_require__(330)); __webpack_require__(72).registerSubTypeDefaulter('legend', function () { // Default 'plain' when no type specified. return 'plain'; }); /***/ }), /* 326 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var zrUtil = __webpack_require__(4); var Model = __webpack_require__(14); var LegendModel = __webpack_require__(1).extendComponentModel({ type: 'legend.plain', dependencies: ['series'], layoutMode: { type: 'box', // legend.width/height are maxWidth/maxHeight actually, // whereas realy width/height is calculated by its content. // (Setting {left: 10, right: 10} does not make sense). // So consider the case: // `setOption({legend: {left: 10});` // then `setOption({legend: {right: 10});` // The previous `left` should be cleared by setting `ignoreSize`. ignoreSize: true }, init: function (option, parentModel, ecModel) { this.mergeDefaultAndTheme(option, ecModel); option.selected = option.selected || {}; }, mergeOption: function (option) { LegendModel.superCall(this, 'mergeOption', option); }, optionUpdated: function () { this._updateData(this.ecModel); var legendData = this._data; // If selectedMode is single, try to select one if (legendData[0] && this.get('selectedMode') === 'single') { var hasSelected = false; // If has any selected in option.selected for (var i = 0; i < legendData.length; i++) { var name = legendData[i].get('name'); if (this.isSelected(name)) { // Force to unselect others this.select(name); hasSelected = true; break; } } // Try select the first if selectedMode is single !hasSelected && this.select(legendData[0].get('name')); } }, _updateData: function (ecModel) { var legendData = zrUtil.map(this.get('data') || [], function (dataItem) { // Can be string or number if (typeof dataItem === 'string' || typeof dataItem === 'number') { dataItem = { name: dataItem }; } return new Model(dataItem, this, this.ecModel); }, this); this._data = legendData; var availableNames = zrUtil.map(ecModel.getSeries(), function (series) { return series.name; }); ecModel.eachSeries(function (seriesModel) { if (seriesModel.legendDataProvider) { var data = seriesModel.legendDataProvider(); availableNames = availableNames.concat(data.mapArray(data.getName)); } }); /** * @type {Array.} * @private */ this._availableNames = availableNames; }, /** * @return {Array.} */ getData: function () { return this._data; }, /** * @param {string} name */ select: function (name) { var selected = this.option.selected; var selectedMode = this.get('selectedMode'); if (selectedMode === 'single') { var data = this._data; zrUtil.each(data, function (dataItem) { selected[dataItem.get('name')] = false; }); } selected[name] = true; }, /** * @param {string} name */ unSelect: function (name) { if (this.get('selectedMode') !== 'single') { this.option.selected[name] = false; } }, /** * @param {string} name */ toggleSelected: function (name) { var selected = this.option.selected; // Default is true if (!selected.hasOwnProperty(name)) { selected[name] = true; } this[selected[name] ? 'unSelect' : 'select'](name); }, /** * @param {string} name */ isSelected: function (name) { var selected = this.option.selected; return !(selected.hasOwnProperty(name) && !selected[name]) && zrUtil.indexOf(this._availableNames, name) >= 0; }, defaultOption: { // 一级层叠 zlevel: 0, // 二级层叠 z: 4, show: true, // 布局方式，默认为水平布局，可选为： // 'horizontal' | 'vertical' orient: 'horizontal', left: 'center', // right: 'center', top: 0, // bottom: null, // 水平对齐 // 'auto' | 'left' | 'right' // 默认为 'auto', 根据 x 的位置判断是左对齐还是右对齐 align: 'auto', backgroundColor: 'rgba(0,0,0,0)', // 图例边框颜色 borderColor: '#ccc', borderRadius: 0, // 图例边框线宽，单位px，默认为0（无边框） borderWidth: 0, // 图例内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css padding: 5, // 各个item之间的间隔，单位px，默认为10， // 横向布局时为水平间隔，纵向布局时为纵向间隔 itemGap: 10, // 图例图形宽度 itemWidth: 25, // 图例图形高度 itemHeight: 14, // 图例关闭时候的颜色 inactiveColor: '#ccc', textStyle: { // 图例文字颜色 color: '#333' }, // formatter: '', // 选择模式，默认开启图例开关 selectedMode: true, // 配置默认选中状态，可配合LEGEND.SELECTED事件做动态数据载入 // selected: null, // 图例内容（详见legend.data，数组中每一项代表一个item // data: [], // Tooltip 相关配置 tooltip: { show: false } } }); module.exports = LegendModel; /***/ }), /* 327 */ /***/ (function(module, exports, __webpack_require__) { /** * @file Legend action */ var echarts = __webpack_require__(1); var zrUtil = __webpack_require__(4); function legendSelectActionHandler(methodName, payload, ecModel) { var selectedMap = {}; var isToggleSelect = methodName === 'toggleSelected'; var isSelected; // Update all legend components ecModel.eachComponent('legend', function (legendModel) { if (isToggleSelect && isSelected != null) { // Force other legend has same selected status // Or the first is toggled to true and other are toggled to false // In the case one legend has some item unSelected in option. And if other legend // doesn't has the item, they will assume it is selected. legendModel[isSelected ? 'select' : 'unSelect'](payload.name); } else { legendModel[methodName](payload.name); isSelected = legendModel.isSelected(payload.name); } var legendData = legendModel.getData(); zrUtil.each(legendData, function (model) { var name = model.get('name'); // Wrap element if (name === '\\n' || name === '') { return; } var isItemSelected = legendModel.isSelected(name); if (selectedMap.hasOwnProperty(name)) { // Unselected if any legend is unselected selectedMap[name] = selectedMap[name] && isItemSelected; } else { selectedMap[name] = isItemSelected; } }); }); // Return the event explicitly return { name: payload.name, selected: selectedMap }; } /** * @event legendToggleSelect * @type {Object} * @property {string} type 'legendToggleSelect' * @property {string} [from] * @property {string} name Series name or data item name */ echarts.registerAction( 'legendToggleSelect', 'legendselectchanged', zrUtil.curry(legendSelectActionHandler, 'toggleSelected') ); /** * @event legendSelect * @type {Object} * @property {string} type 'legendSelect' * @property {string} name Series name or data item name */ echarts.registerAction( 'legendSelect', 'legendselected', zrUtil.curry(legendSelectActionHandler, 'select') ); /** * @event legendUnSelect * @type {Object} * @property {string} type 'legendUnSelect' * @property {string} name Series name or data item name */ echarts.registerAction( 'legendUnSelect', 'legendunselected', zrUtil.curry(legendSelectActionHandler, 'unSelect') ); /***/ }), /* 328 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); var symbolCreator = __webpack_require__(114); var graphic = __webpack_require__(20); var listComponentHelper = __webpack_require__(329); var layoutUtil = __webpack_require__(74); var curry = zrUtil.curry; var each = zrUtil.each; var Group = graphic.Group; module.exports = __webpack_require__(1).extendComponentView({ type: 'legend.plain', newlineDisabled: false, /** * @override */ init: function () { /** * @private * @type {module:zrender/container/Group} */ this.group.add(this._contentGroup = new Group()); /** * @private * @type {module:zrender/Element} */ this._backgroundEl; }, /** * @protected */ getContentGroup: function () { return this._contentGroup; }, /** * @override */ render: function (legendModel, ecModel, api) { this.resetInner(); if (!legendModel.get('show', true)) { return; } var itemAlign = legendModel.get('align'); if (!itemAlign || itemAlign === 'auto') { itemAlign = ( legendModel.get('left') === 'right' && legendModel.get('orient') === 'vertical' ) ? 'right' : 'left'; } this.renderInner(itemAlign, legendModel, ecModel, api); // Perform layout. var positionInfo = legendModel.getBoxLayoutParams(); var viewportSize = {width: api.getWidth(), height: api.getHeight()}; var padding = legendModel.get('padding'); var maxSize = layoutUtil.getLayoutRect(positionInfo, viewportSize, padding); var mainRect = this.layoutInner(legendModel, itemAlign, maxSize); // Place mainGroup, based on the calculated `mainRect`. var layoutRect = layoutUtil.getLayoutRect( zrUtil.defaults({width: mainRect.width, height: mainRect.height}, positionInfo), viewportSize, padding ); this.group.attr('position', [layoutRect.x - mainRect.x, layoutRect.y - mainRect.y]); // Render background after group is layout. this.group.add( this._backgroundEl = listComponentHelper.makeBackground(mainRect, legendModel) ); }, /** * @protected */ resetInner: function () { this.getContentGroup().removeAll(); this._backgroundEl && this.group.remove(this._backgroundEl); }, /** * @protected */ renderInner: function (itemAlign, legendModel, ecModel, api) { var contentGroup = this.getContentGroup(); var legendDrawnMap = zrUtil.createHashMap(); var selectMode = legendModel.get('selectedMode'); each(legendModel.getData(), function (itemModel, dataIndex) { var name = itemModel.get('name'); // Use empty string or \\n as a newline string if (!this.newlineDisabled && (name === '' || name === '\\n')) { contentGroup.add(new Group({ newline: true })); return; } var seriesModel = ecModel.getSeriesByName(name)[0]; if (legendDrawnMap.get(name)) { // Have been drawed return; } // Series legend if (seriesModel) { var data = seriesModel.getData(); var color = data.getVisual('color'); // If color is a callback function if (typeof color === 'function') { // Use the first data color = color(seriesModel.getDataParams(0)); } // Using rect symbol defaultly var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect'; var symbolType = data.getVisual('symbol'); var itemGroup = this._createItem( name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode ); itemGroup.on('click', curry(dispatchSelectAction, name, api)) .on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api)) .on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api)); legendDrawnMap.set(name, true); } else { // Data legend of pie, funnel ecModel.eachRawSeries(function (seriesModel) { // In case multiple series has same data name if (legendDrawnMap.get(name)) { return; } if (seriesModel.legendDataProvider) { var data = seriesModel.legendDataProvider(); var idx = data.indexOfName(name); if (idx < 0) { return; } var color = data.getItemVisual(idx, 'color'); var legendSymbolType = 'roundRect'; var itemGroup = this._createItem( name, dataIndex, itemModel, legendModel, legendSymbolType, null, itemAlign, color, selectMode ); itemGroup.on('click', curry(dispatchSelectAction, name, api)) // FIXME Should not specify the series name .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api)) .on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api)); legendDrawnMap.set(name, true); } }, this); } if (true) { if (!legendDrawnMap.get(name)) { console.warn(name + ' series not exists. Legend data should be same with series name or data name.'); } } }, this); }, _createItem: function ( name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode ) { var itemWidth = legendModel.get('itemWidth'); var itemHeight = legendModel.get('itemHeight'); var inactiveColor = legendModel.get('inactiveColor'); var isSelected = legendModel.isSelected(name); var itemGroup = new Group(); var textStyleModel = itemModel.getModel('textStyle'); var itemIcon = itemModel.get('icon'); var tooltipModel = itemModel.getModel('tooltip'); var legendGlobalTooltipModel = tooltipModel.parentModel; // Use user given icon first legendSymbolType = itemIcon || legendSymbolType; itemGroup.add(symbolCreator.createSymbol( legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor )); // Compose symbols // PENDING if (!itemIcon && symbolType // At least show one symbol, can't be all none && ((symbolType !== legendSymbolType) || symbolType == 'none') ) { var size = itemHeight * 0.8; if (symbolType === 'none') { symbolType = 'circle'; } // Put symbol in the center itemGroup.add(symbolCreator.createSymbol( symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size, isSelected ? color : inactiveColor )); } var textX = itemAlign === 'left' ? itemWidth + 5 : -5; var textAlign = itemAlign; var formatter = legendModel.get('formatter'); var content = name; if (typeof formatter === 'string' && formatter) { content = formatter.replace('{name}', name != null ? name : ''); } else if (typeof formatter === 'function') { content = formatter(name); } itemGroup.add(new graphic.Text({ style: graphic.setTextStyle({}, textStyleModel, { text: content, x: textX, y: itemHeight / 2, textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor, textAlign: textAlign, textVerticalAlign: 'middle' }) })); // Add a invisible rect to increase the area of mouse hover var hitRect = new graphic.Rect({ shape: itemGroup.getBoundingRect(), invisible: true, tooltip: tooltipModel.get('show') ? zrUtil.extend({ content: name, // Defaul formatter formatter: legendGlobalTooltipModel.get('formatter', true) || function () { return name; }, formatterParams: { componentType: 'legend', legendIndex: legendModel.componentIndex, name: name, $vars: ['name'] } }, tooltipModel.option) : null }); itemGroup.add(hitRect); itemGroup.eachChild(function (child) { child.silent = true; }); hitRect.silent = !selectMode; this.getContentGroup().add(itemGroup); graphic.setHoverStyle(itemGroup); itemGroup.__legendDataIndex = dataIndex; return itemGroup; }, /** * @protected */ layoutInner: function (legendModel, itemAlign, maxSize) { var contentGroup = this.getContentGroup(); // Place items in contentGroup. layoutUtil.box( legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), maxSize.width, maxSize.height ); var contentRect = contentGroup.getBoundingRect(); contentGroup.attr('position', [-contentRect.x, -contentRect.y]); return this.group.getBoundingRect(); } }); function dispatchSelectAction(name, api) { api.dispatchAction({ type: 'legendToggleSelect', name: name }); } function dispatchHighlightAction(seriesModel, dataName, api) { // If element hover will move to a hoverLayer. var el = api.getZr().storage.getDisplayList()[0]; if (!(el && el.useHoverLayer)) { seriesModel.get('legendHoverLink') && api.dispatchAction({ type: 'highlight', seriesName: seriesModel.name, name: dataName }); } } function dispatchDownplayAction(seriesModel, dataName, api) { // If element hover will move to a hoverLayer. var el = api.getZr().storage.getDisplayList()[0]; if (!(el && el.useHoverLayer)) { seriesModel.get('legendHoverLink') && api.dispatchAction({ type: 'downplay', seriesName: seriesModel.name, name: dataName }); } } /***/ }), /* 329 */ /***/ (function(module, exports, __webpack_require__) { // List layout var layout = __webpack_require__(74); var formatUtil = __webpack_require__(6); var graphic = __webpack_require__(20); module.exports = { /** * Layout list like component. * It will box layout each items in group of component and then position the whole group in the viewport * @param {module:zrender/group/Group} group * @param {module:echarts/model/Component} componentModel * @param {module:echarts/ExtensionAPI} */ layout: function (group, componentModel, api) { var boxLayoutParams = componentModel.getBoxLayoutParams(); var padding = componentModel.get('padding'); var viewportSize = {width: api.getWidth(), height: api.getHeight()}; var rect = layout.getLayoutRect( boxLayoutParams, viewportSize, padding ); layout.box( componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height ); layout.positionElement( group, boxLayoutParams, viewportSize, padding ); }, makeBackground: function (rect, componentModel) { var padding = formatUtil.normalizeCssArray( componentModel.get('padding') ); var style = componentModel.getItemStyle(['color', 'opacity']); style.fill = componentModel.get('backgroundColor'); var rect = new graphic.Rect({ shape: { x: rect.x - padding[3], y: rect.y - padding[0], width: rect.width + padding[1] + padding[3], height: rect.height + padding[0] + padding[2], r: componentModel.get('borderRadius') }, style: style, silent: true, z2: -1 }); // FIXME // `subPixelOptimizeRect` may bring some gap between edge of viewpart // and background rect when setting like `left: 0`, `top: 0`. // graphic.subPixelOptimizeRect(rect); return rect; } }; /***/ }), /* 330 */ /***/ (function(module, exports) { module.exports = function (ecModel) { var legendModels = ecModel.findComponents({ mainType: 'legend' }); if (legendModels && legendModels.length) { ecModel.filterSeries(function (series) { // If in any legend component the status is not selected. // Because in legend series is assumed selected when it is not in the legend data. for (var i = 0; i < legendModels.length; i++) { if (!legendModels[i].isSelected(series.name)) { return false; } } return true; }); } }; /***/ }), /* 331 */ /***/ (function(module, exports, __webpack_require__) { var LegendModel = __webpack_require__(326); var layout = __webpack_require__(74); var ScrollableLegendModel = LegendModel.extend({ type: 'legend.scroll', /** * @param {number} scrollDataIndex */ setScrollDataIndex: function (scrollDataIndex) { this.option.scrollDataIndex = scrollDataIndex; }, defaultOption: { scrollDataIndex: 0, pageButtonItemGap: 5, pageButtonGap: null, pageButtonPosition: 'end', // 'start' or 'end' pageFormatter: '{current}/{total}', // If null/undefined, do not show page. pageIcons: { horizontal: ['M0,0L12,-10L12,10z', 'M0,0L-12,-10L-12,10z'], vertical: ['M0,0L20,0L10,-20z', 'M0,0L20,0L10,20z'] }, pageIconColor: '#2f4554', pageIconInactiveColor: '#aaa', pageIconSize: 15, // Can be [10, 3], which represents [width, height] pageTextStyle: { color: '#333' }, animationDurationUpdate: 800 }, /** * @override */ init: function (option, parentModel, ecModel, extraOpt) { var inputPositionParams = layout.getLayoutParams(option); ScrollableLegendModel.superCall(this, 'init', option, parentModel, ecModel, extraOpt); mergeAndNormalizeLayoutParams(this, option, inputPositionParams); }, /** * @override */ mergeOption: function (option, extraOpt) { ScrollableLegendModel.superCall(this, 'mergeOption', option, extraOpt); mergeAndNormalizeLayoutParams(this, this.option, option); }, getOrient: function () { return this.get('orient') === 'vertical' ? {index: 1, name: 'vertical'} : {index: 0, name: 'horizontal'}; } }); // Do not `ignoreSize` to enable setting {left: 10, right: 10}. function mergeAndNormalizeLayoutParams(legendModel, target, raw) { var orient = legendModel.getOrient(); var ignoreSize = [1, 1]; ignoreSize[orient.index] = 0; layout.mergeLayoutParam(target, raw, { type: 'box', ignoreSize: ignoreSize }); } module.exports = ScrollableLegendModel; /***/ }), /* 332 */ /***/ (function(module, exports, __webpack_require__) { /** * Separate legend and scrollable legend to reduce package size. */ var zrUtil = __webpack_require__(4); var graphic = __webpack_require__(20); var layoutUtil = __webpack_require__(74); var LegendView = __webpack_require__(328); var Group = graphic.Group; var WH = ['width', 'height']; var XY = ['x', 'y']; var ScrollableLegendView = LegendView.extend({ type: 'legend.scroll', newlineDisabled: true, init: function () { ScrollableLegendView.superCall(this, 'init'); /** * @private * @type {number} For `scroll`. */ this._currentIndex = 0; /** * @private * @type {module:zrender/container/Group} */ this.group.add(this._containerGroup = new Group()); this._containerGroup.add(this.getContentGroup()); /** * @private * @type {module:zrender/container/Group} */ this.group.add(this._controllerGroup = new Group()); }, /** * @override */ resetInner: function () { ScrollableLegendView.superCall(this, 'resetInner'); this._controllerGroup.removeAll(); this._containerGroup.removeClipPath(); this._containerGroup.__rectSize = null; }, /** * @override */ renderInner: function (itemAlign, legendModel, ecModel, api) { var me = this; // Render content items. ScrollableLegendView.superCall(this, 'renderInner', itemAlign, legendModel, ecModel, api); var controllerGroup = this._controllerGroup; var pageIconSize = legendModel.get('pageIconSize', true); if (!zrUtil.isArray(pageIconSize)) { pageIconSize = [pageIconSize, pageIconSize]; } createPageButton('pagePrev', 0); var pageTextStyleModel = legendModel.getModel('pageTextStyle'); controllerGroup.add(new graphic.Text({ name: 'pageText', style: { textFill: pageTextStyleModel.getTextColor(), font: pageTextStyleModel.getFont(), textVerticalAlign: 'middle', textAlign: 'center' }, silent: true })); createPageButton('pageNext', 1); function createPageButton(name, iconIdx) { var pageDataIndexName = name + 'DataIndex'; var icon = graphic.createIcon( legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], { // Buttons will be created in each render, so we do not need // to worry about avoiding using legendModel kept in scope. onclick: zrUtil.bind( me._pageGo, me, pageDataIndexName, legendModel, api ) }, { x: -pageIconSize[0] / 2, y: -pageIconSize[1] / 2, width: pageIconSize[0], height: pageIconSize[1] } ); icon.name = name; controllerGroup.add(icon); } }, /** * @override */ layoutInner: function (legendModel, itemAlign, maxSize) { var contentGroup = this.getContentGroup(); var containerGroup = this._containerGroup; var controllerGroup = this._controllerGroup; var orientIdx = legendModel.getOrient().index; var wh = WH[orientIdx]; var hw = WH[1 - orientIdx]; var yx = XY[1 - orientIdx]; // Place items in contentGroup. layoutUtil.box( legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height ); layoutUtil.box( // Buttons in controller are layout always horizontally. 'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true) ); var contentRect = contentGroup.getBoundingRect(); var controllerRect = controllerGroup.getBoundingRect(); var showController = contentRect[wh] > maxSize[wh]; var contentPos = [-contentRect.x, -contentRect.y]; // Remain contentPos when scroll animation perfroming. contentPos[orientIdx] = contentGroup.position[orientIdx]; // Layout container group based on 0. var containerPos = [0, 0]; var controllerPos = [-controllerRect.x, -controllerRect.y]; var pageButtonGap = zrUtil.retrieve2( legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true) ); // Place containerGroup and controllerGroup and contentGroup. if (showController) { var pageButtonPosition = legendModel.get('pageButtonPosition', true); // controller is on the right / bottom. if (pageButtonPosition === 'end') { controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh]; } // controller is on the left / top. else { containerPos[orientIdx] += controllerRect[wh] + pageButtonGap; } } // Always align controller to content as 'middle'. controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2; contentGroup.attr('position', contentPos); containerGroup.attr('position', containerPos); controllerGroup.attr('position', controllerPos); // Calculate `mainRect` and set `clipPath`. // mainRect should not be calculated by `this.group.getBoundingRect()` // for sake of the overflow. var mainRect = this.group.getBoundingRect(); var mainRect = {x: 0, y: 0}; // Consider content may be overflow (should be clipped). mainRect[wh] = showController ? maxSize[wh] : contentRect[wh]; mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]); // `containerRect[yx] + containerPos[1 - orientIdx]` is 0. mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]); containerGroup.__rectSize = maxSize[wh]; if (showController) { var clipShape = {x: 0, y: 0}; clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0); clipShape[hw] = mainRect[hw]; containerGroup.setClipPath(new graphic.Rect({shape: clipShape})); // Consider content may be larger than container, container rect // can not be obtained from `containerGroup.getBoundingRect()`. containerGroup.__rectSize = clipShape[wh]; } else { // Do not remove or ignore controller. Keep them set as place holders. controllerGroup.eachChild(function (child) { child.attr({invisible: true, silent: true}); }); } // Content translate animation. var pageInfo = this._getPageInfo(legendModel); pageInfo.pageIndex != null && graphic.updateProps( contentGroup, {position: pageInfo.contentPosition}, legendModel ); this._updatePageInfoView(legendModel, pageInfo); return mainRect; }, _pageGo: function (to, legendModel, api) { var scrollDataIndex = this._getPageInfo(legendModel)[to]; scrollDataIndex != null && api.dispatchAction({ type: 'legendScroll', scrollDataIndex: scrollDataIndex, legendId: legendModel.id }); }, _updatePageInfoView: function (legendModel, pageInfo) { var controllerGroup = this._controllerGroup; zrUtil.each(['pagePrev', 'pageNext'], function (name) { var canJump = pageInfo[name + 'DataIndex'] != null; var icon = controllerGroup.childOfName(name); if (icon) { icon.setStyle( 'fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true) ); icon.cursor = canJump ? 'pointer' : 'default'; } }); var pageText = controllerGroup.childOfName('pageText'); var pageFormatter = legendModel.get('pageFormatter'); var pageIndex = pageInfo.pageIndex; var current = pageIndex != null ? pageIndex + 1 : 0; var total = pageInfo.pageCount; pageText && pageFormatter && pageText.setStyle( 'text', zrUtil.isString(pageFormatter) ? pageFormatter.replace('{current}', current).replace('{total}', total) : pageFormatter({current: current, total: total}) ); }, /** * @param {module:echarts/model/Model} legendModel * @return {Object} { * contentPosition: Array., null when data item not found. * pageIndex: number, null when data item not found. * pageCount: number, always be a number, can be 0. * pagePrevDataIndex: number, null when no next page. * pageNextDataIndex: number, null when no previous page. * } */ _getPageInfo: function (legendModel) { // Align left or top by the current dataIndex. var currDataIndex = legendModel.get('scrollDataIndex', true); var contentGroup = this.getContentGroup(); var contentRect = contentGroup.getBoundingRect(); var containerRectSize = this._containerGroup.__rectSize; var orientIdx = legendModel.getOrient().index; var wh = WH[orientIdx]; var hw = WH[1 - orientIdx]; var xy = XY[orientIdx]; var contentPos = contentGroup.position.slice(); var pageIndex; var pagePrevDataIndex; var pageNextDataIndex; var targetItemGroup; contentGroup.eachChild(function (child) { if (child.__legendDataIndex === currDataIndex) { targetItemGroup = child; } }); var pageCount = containerRectSize ? Math.ceil(contentRect[wh] / containerRectSize) : 0; if (targetItemGroup) { var itemRect = targetItemGroup.getBoundingRect(); var itemLoc = targetItemGroup.position[orientIdx] + itemRect[xy]; contentPos[orientIdx] = -itemLoc - contentRect[xy]; pageIndex = Math.floor( pageCount * (itemLoc + itemRect[xy] + containerRectSize / 2) / contentRect[wh] ); pageIndex = (contentRect[wh] && pageCount) ? Math.max(0, Math.min(pageCount - 1, pageIndex)) : -1; var winRect = {x: 0, y: 0}; winRect[wh] = containerRectSize; winRect[hw] = contentRect[hw]; winRect[xy] = -contentPos[orientIdx] - contentRect[xy]; var startIdx; var children = contentGroup.children(); contentGroup.eachChild(function (child, index) { var itemRect = getItemRect(child); if (itemRect.intersect(winRect)) { startIdx == null && (startIdx = index); // It is user-friendly that the last item shown in the // current window is shown at the begining of next window. pageNextDataIndex = child.__legendDataIndex; } // If the last item is shown entirely, no next page. if (index === children.length - 1 && itemRect[xy] + itemRect[wh] 0 && getItemRect(children[startIdx - 1]).intersect(winRect)) { startIdx--; } pagePrevDataIndex = children[startIdx].__legendDataIndex; } } } return { contentPosition: contentPos, pageIndex: pageIndex, pageCount: pageCount, pagePrevDataIndex: pagePrevDataIndex, pageNextDataIndex: pageNextDataIndex }; function getItemRect(el) { var itemRect = el.getBoundingRect().clone(); itemRect[xy] += el.position[orientIdx]; return itemRect; } } }); module.exports = ScrollableLegendView; /***/ }), /* 333 */ /***/ (function(module, exports, __webpack_require__) { /** * @file Legend action */ /** * @event legendScroll * @type {Object} * @property {string} type 'legendScroll' * @property {string} scrollDataIndex */ __webpack_require__(1).registerAction( 'legendScroll', 'legendscroll', function (payload, ecModel) { var scrollDataIndex = payload.scrollDataIndex; scrollDataIndex != null && ecModel.eachComponent( {mainType: 'legend', subType: 'scroll', query: payload}, function (legendModel) { legendModel.setScrollDataIndex(scrollDataIndex); } ); } ); /***/ }), /* 334 */ /***/ (function(module, exports, __webpack_require__) { // FIXME Better way to pack data in graphic element __webpack_require__(301); __webpack_require__(335); __webpack_require__(336); // Show tip action /** * @action * @property {string} type * @property {number} seriesIndex * @property {number} dataIndex * @property {number} [x] * @property {number} [y] */ __webpack_require__(1).registerAction( { type: 'showTip', event: 'showTip', update: 'tooltip:manuallyShowTip' }, // noop function () {} ); // Hide tip action __webpack_require__(1).registerAction( { type: 'hideTip', event: 'hideTip', update: 'tooltip:manuallyHideTip' }, // noop function () {} ); /***/ }), /* 335 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(1).extendComponentModel({ type: 'tooltip', dependencies: ['axisPointer'], defaultOption: { zlevel: 0, z: 8, show: true, // tooltip主体内容 showContent: true, // 'trigger' only works on coordinate system. // 'item' | 'axis' | 'none' trigger: 'item', // 'click' | 'mousemove' | 'none' triggerOn: 'mousemove|click', alwaysShowContent: false, displayMode: 'single', // 'single' | 'multipleByCoordSys' // 位置 {Array} | {Function} // position: null // Consider triggered from axisPointer handle, verticalAlign should be 'middle' // align: null, // verticalAlign: null, // 是否约束 content 在 viewRect 中。默认 false 是为了兼容以前版本。 confine: false, // 内容格式器：{string}（Template） ¦ {Function} // formatter: null showDelay: 0, // 隐藏延迟，单位ms hideDelay: 100, // 动画变换时间，单位s transitionDuration: 0.4, enterable: false, // 提示背景颜色，默认为透明度为0.7的黑色 backgroundColor: 'rgba(50,50,50,0.7)', // 提示边框颜色 borderColor: '#333', // 提示边框圆角，单位px，默认为4 borderRadius: 4, // 提示边框线宽，单位px，默认为0（无边框） borderWidth: 0, // 提示内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css padding: 5, // Extra css text extraCssText: '', // 坐标轴指示器，坐标轴触发有效 axisPointer: { // 默认为直线 // 可选为：'line' | 'shadow' | 'cross' type: 'line', // type 为 line 的时候有效，指定 tooltip line 所在的轴，可选 // 可选 'x' | 'y' | 'angle' | 'radius' | 'auto' // 默认 'auto'，会选择类型为 cateogry 的轴，对于双数值轴，笛卡尔坐标系会默认选择 x 轴 // 极坐标系会默认选择 angle 轴 axis: 'auto', animation: 'auto', animationDurationUpdate: 200, animationEasingUpdate: 'exponentialOut', crossStyle: { color: '#999', width: 1, type: 'dashed', // TODO formatter textStyle: {} } // lineStyle and shadowStyle should not be specified here, // otherwise it will always override those styles on option.axisPointer. }, textStyle: { color: '#fff', fontSize: 14 } } }); /***/ }), /* 336 */ /***/ (function(module, exports, __webpack_require__) { var TooltipContent = __webpack_require__(337); var zrUtil = __webpack_require__(4); var formatUtil = __webpack_require__(6); var numberUtil = __webpack_require__(7); var graphic = __webpack_require__(20); var findPointFromSeries = __webpack_require__(303); var layoutUtil = __webpack_require__(74); var env = __webpack_require__(2); var Model = __webpack_require__(14); var globalListener = __webpack_require__(306); var axisHelper = __webpack_require__(104); var axisPointerViewHelper = __webpack_require__(309); var bind = zrUtil.bind; var each = zrUtil.each; var parsePercent = numberUtil.parsePercent; var proxyRect = new graphic.Rect({ shape: {x: -1, y: -1, width: 2, height: 2} }); __webpack_require__(1).extendComponentView({ type: 'tooltip', init: function (ecModel, api) { if (env.node) { return; } var tooltipContent = new TooltipContent(api.getDom(), api); this._tooltipContent = tooltipContent; }, render: function (tooltipModel, ecModel, api) { if (env.node) { return; } // Reset this.group.removeAll(); /** * @private * @type {module:echarts/component/tooltip/TooltipModel} */ this._tooltipModel = tooltipModel; /** * @private * @type {module:echarts/model/Global} */ this._ecModel = ecModel; /** * @private * @type {module:echarts/ExtensionAPI} */ this._api = api; /** * Should be cleaned when render. * @private * @type {Array.} */ this._lastDataByCoordSys = null; /** * @private * @type {boolean} */ this._alwaysShowContent = tooltipModel.get('alwaysShowContent'); var tooltipContent = this._tooltipContent; tooltipContent.update(); tooltipContent.setEnterable(tooltipModel.get('enterable')); this._initGlobalListener(); this._keepShow(); }, _initGlobalListener: function () { var tooltipModel = this._tooltipModel; var triggerOn = tooltipModel.get('triggerOn'); globalListener.register( 'itemTooltip', this._api, bind(function (currTrigger, e, dispatchAction) { // If 'none', it is not controlled by mouse totally. if (triggerOn !== 'none') { if (triggerOn.indexOf(currTrigger) >= 0) { this._tryShow(e, dispatchAction); } else if (currTrigger === 'leave') { this._hide(dispatchAction); } } }, this) ); }, _keepShow: function () { var tooltipModel = this._tooltipModel; var ecModel = this._ecModel; var api = this._api; // Try to keep the tooltip show when refreshing if (this._lastX != null && this._lastY != null // When user is willing to control tooltip totally using API, // self.manuallyShowTip({x, y}) might cause tooltip hide, // which is not expected. && tooltipModel.get('triggerOn') !== 'none' ) { var self = this; clearTimeout(this._refreshUpdateTimeout); this._refreshUpdateTimeout = setTimeout(function () { // Show tip next tick after other charts are rendered // In case highlight action has wrong result // FIXME self.manuallyShowTip(tooltipModel, ecModel, api, { x: self._lastX, y: self._lastY }); }); } }, /** * Show tip manually by * dispatchAction({ * type: 'showTip', * x: 10, * y: 10 * }); * Or * dispatchAction({ * type: 'showTip', * seriesIndex: 0, * dataIndex or dataIndexInside or name * }); * * TODO Batch */ manuallyShowTip: function (tooltipModel, ecModel, api, payload) { if (payload.from === this.uid || env.node) { return; } var dispatchAction = makeDispatchAction(payload, api); // Reset ticket this._ticket = ''; // When triggered from axisPointer. var dataByCoordSys = payload.dataByCoordSys; if (payload.tooltip && payload.x != null && payload.y != null) { var el = proxyRect; el.position = [payload.x, payload.y]; el.update(); el.tooltip = payload.tooltip; // Manually show tooltip while view is not using zrender elements. this._tryShow({ offsetX: payload.x, offsetY: payload.y, target: el }, dispatchAction); } else if (dataByCoordSys) { this._tryShow({ offsetX: payload.x, offsetY: payload.y, position: payload.position, event: {}, dataByCoordSys: payload.dataByCoordSys, tooltipOption: payload.tooltipOption }, dispatchAction); } else if (payload.seriesIndex != null) { if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) { return; } var pointInfo = findPointFromSeries(payload, ecModel); var cx = pointInfo.point[0]; var cy = pointInfo.point[1]; if (cx != null && cy != null) { this._tryShow({ offsetX: cx, offsetY: cy, position: payload.position, target: pointInfo.el, event: {} }, dispatchAction); } } else if (payload.x != null && payload.y != null) { // FIXME // should wrap dispatchAction like `axisPointer/globalListener` ? api.dispatchAction({ type: 'updateAxisPointer', x: payload.x, y: payload.y }); this._tryShow({ offsetX: payload.x, offsetY: payload.y, position: payload.position, target: api.getZr().findHover(payload.x, payload.y).target, event: {} }, dispatchAction); } }, manuallyHideTip: function (tooltipModel, ecModel, api, payload) { var tooltipContent = this._tooltipContent; if (!this._alwaysShowContent) { tooltipContent.hideLater(this._tooltipModel.get('hideDelay')); } this._lastX = this._lastY = null; if (payload.from !== this.uid) { this._hide(makeDispatchAction(payload, api)); } }, // Be compatible with previous design, that is, when tooltip.type is 'axis' and // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer // and tooltip. _manuallyAxisShowTip: function (tooltipModel, ecModel, api, payload) { var seriesIndex = payload.seriesIndex; var dataIndex = payload.dataIndex; var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo; if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) { return; } var seriesModel = ecModel.getSeriesByIndex(seriesIndex); if (!seriesModel) { return; } var data = seriesModel.getData(); var tooltipModel = buildTooltipModel([ data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model, tooltipModel ]); if (tooltipModel.get('trigger') !== 'axis') { return; } api.dispatchAction({ type: 'updateAxisPointer', seriesIndex: seriesIndex, dataIndex: dataIndex, position: payload.position }); return true; }, _tryShow: function (e, dispatchAction) { var el = e.target; var tooltipModel = this._tooltipModel; if (!tooltipModel) { return; } // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed this._lastX = e.offsetX; this._lastY = e.offsetY; var dataByCoordSys = e.dataByCoordSys; if (dataByCoordSys && dataByCoordSys.length) { this._showAxisTooltip(dataByCoordSys, e); } // Always show item tooltip if mouse is on the element with dataIndex else if (el && el.dataIndex != null) { this._lastDataByCoordSys = null; this._showSeriesItemTooltip(e, el, dispatchAction); } // Tooltip provided directly. Like legend. else if (el && el.tooltip) { this._lastDataByCoordSys = null; this._showComponentItemTooltip(e, el, dispatchAction); } else { this._lastDataByCoordSys = null; this._hide(dispatchAction); } }, _showOrMove: function (tooltipModel, cb) { // showDelay is used in this case: tooltip.enterable is set // as true. User intent to move mouse into tooltip and click // something. `showDelay` makes it easyer to enter the content // but tooltip do not move immediately. var delay = tooltipModel.get('showDelay'); cb = zrUtil.bind(cb, this); clearTimeout(this._showTimout); delay > 0 ? (this._showTimout = setTimeout(cb, delay)) : cb(); }, _showAxisTooltip: function (dataByCoordSys, e) { var ecModel = this._ecModel; var globalTooltipModel = this._tooltipModel; var point = [e.offsetX, e.offsetY]; var singleDefaultHTML = []; var singleParamsList = []; var singleTooltipModel = buildTooltipModel([ e.tooltipOption, globalTooltipModel ]); each(dataByCoordSys, function (itemCoordSys) { // var coordParamList = []; // var coordDefaultHTML = []; // var coordTooltipModel = buildTooltipModel([ // e.tooltipOption, // itemCoordSys.tooltipOption, // ecModel.getComponent(itemCoordSys.coordSysMainType, itemCoordSys.coordSysIndex), // globalTooltipModel // ]); // var displayMode = coordTooltipModel.get('displayMode'); // var paramsList = displayMode === 'single' ? singleParamsList : []; each(itemCoordSys.dataByAxis, function (item) { var axisModel = ecModel.getComponent(item.axisDim + 'Axis', item.axisIndex); var axisValue = item.value; var seriesDefaultHTML = []; if (!axisModel || axisValue == null) { return; } var valueLabel = axisPointerViewHelper.getValueLabel( axisValue, axisModel.axis, ecModel, item.seriesDataIndices, item.valueLabelOpt ); zrUtil.each(item.seriesDataIndices, function (idxItem) { var series = ecModel.getSeriesByIndex(idxItem.seriesIndex); var dataIndex = idxItem.dataIndexInside; var dataParams = series && series.getDataParams(dataIndex); dataParams.axisDim = item.axisDim; dataParams.axisIndex = item.axisIndex; dataParams.axisType = item.axisType; dataParams.axisId = item.axisId; dataParams.axisValue = axisHelper.getAxisRawValue(axisModel.axis, axisValue); dataParams.axisValueLabel = valueLabel; if (dataParams) { singleParamsList.push(dataParams); seriesDefaultHTML.push(series.formatTooltip(dataIndex, true)); } }); // Default tooltip content // FIXME // (1) shold be the first data which has name? // (2) themeRiver, firstDataIndex is array, and first line is unnecessary. var firstLine = valueLabel; singleDefaultHTML.push( (firstLine ? formatUtil.encodeHTML(firstLine) + '' : '') + seriesDefaultHTML.join('') ); }); }, this); // In most case, the second axis is shown upper than the first one. singleDefaultHTML.reverse(); singleDefaultHTML = singleDefaultHTML.join(''); var positionExpr = e.position; this._showOrMove(singleTooltipModel, function () { if (this._updateContentNotChangedOnAxis(dataByCoordSys)) { this._updatePosition( singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, singleParamsList ); } else { this._showTooltipContent( singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(), point[0], point[1], positionExpr ); } }); // Do not trigger events here, because this branch only be entered // from dispatchAction. }, _showSeriesItemTooltip: function (e, el, dispatchAction) { var ecModel = this._ecModel; // Use dataModel in element if possible // Used when mouseover on a element like markPoint or edge // In which case, the data is not main data in series. var seriesIndex = el.seriesIndex; var seriesModel = ecModel.getSeriesByIndex(seriesIndex); // For example, graph link. var dataModel = el.dataModel || seriesModel; var dataIndex = el.dataIndex; var dataType = el.dataType; var data = dataModel.getData(); var tooltipModel = buildTooltipModel([ data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model, this._tooltipModel ]); var tooltipTrigger = tooltipModel.get('trigger'); if (tooltipTrigger != null && tooltipTrigger !== 'item') { return; } var params = dataModel.getDataParams(dataIndex, dataType); var defaultHtml = dataModel.formatTooltip(dataIndex, false, dataType); var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex; this._showOrMove(tooltipModel, function () { this._showTooltipContent( tooltipModel, defaultHtml, params, asyncTicket, e.offsetX, e.offsetY, e.position, e.target ); }); // FIXME // duplicated showtip if manuallyShowTip is called from dispatchAction. dispatchAction({ type: 'showTip', dataIndexInside: dataIndex, dataIndex: data.getRawIndex(dataIndex), seriesIndex: seriesIndex, from: this.uid }); }, _showComponentItemTooltip: function (e, el, dispatchAction) { var tooltipOpt = el.tooltip; if (typeof tooltipOpt === 'string') { var content = tooltipOpt; tooltipOpt = { content: content, // Fixed formatter formatter: content }; } var subTooltipModel = new Model(tooltipOpt, this._tooltipModel, this._ecModel); var defaultHtml = subTooltipModel.get('content'); var asyncTicket = Math.random(); // Do not check whether `trigger` is 'none' here, because `trigger` // only works on cooridinate system. In fact, we have not found case // that requires setting `trigger` nothing on component yet. this._showOrMove(subTooltipModel, function () { this._showTooltipContent( subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {}, asyncTicket, e.offsetX, e.offsetY, e.position, el ); }); // If not dispatch showTip, tip may be hide triggered by axis. dispatchAction({ type: 'showTip', from: this.uid }); }, _showTooltipContent: function ( tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el ) { // Reset ticket this._ticket = ''; if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) { return; } var tooltipContent = this._tooltipContent; var formatter = tooltipModel.get('formatter'); positionExpr = positionExpr || tooltipModel.get('position'); var html = defaultHtml; if (formatter && typeof formatter === 'string') { html = formatUtil.formatTpl(formatter, params, true); } else if (typeof formatter === 'function') { var callback = bind(function (cbTicket, html) { if (cbTicket === this._ticket) { tooltipContent.setContent(html); this._updatePosition( tooltipModel, positionExpr, x, y, tooltipContent, params, el ); } }, this); this._ticket = asyncTicket; html = formatter(params, asyncTicket, callback); } tooltipContent.setContent(html); tooltipContent.show(tooltipModel); this._updatePosition( tooltipModel, positionExpr, x, y, tooltipContent, params, el ); }, /** * @param {string|Function|Array.|Object} positionExpr * @param {number} x Mouse x * @param {number} y Mouse y * @param {boolean} confine Whether confine tooltip content in view rect. * @param {Object| viewWidth) { x -= width + gapH; } else { x += gapH; } } if (gapV != null) { if (y + height + gapV > viewHeight) { y -= height + gapV; } else { y += gapV; } } return [x, y]; } function confineTooltipPosition(x, y, el, viewWidth, viewHeight) { var size = getOuterSize(el); var width = size.width; var height = size.height; x = Math.min(x + width, viewWidth) - width; y = Math.min(y + height, viewHeight) - height; x = Math.max(x, 0); y = Math.max(y, 0); return [x, y]; } function getOuterSize(el) { var width = el.clientWidth; var height = el.clientHeight; // Consider browser compatibility. // IE8 does not support getComputedStyle. if (document.defaultView && document.defaultView.getComputedStyle) { var stl = document.defaultView.getComputedStyle(el); if (stl) { width += parseInt(stl.paddingLeft, 10) + parseInt(stl.paddingRight, 10) + parseInt(stl.borderLeftWidth, 10) + parseInt(stl.borderRightWidth, 10); height += parseInt(stl.paddingTop, 10) + parseInt(stl.paddingBottom, 10) + parseInt(stl.borderTopWidth, 10) + parseInt(stl.borderBottomWidth, 10); } } return {width: width, height: height}; } function calcTooltipPosition(position, rect, contentSize) { var domWidth = contentSize[0]; var domHeight = contentSize[1]; var gap = 5; var x = 0; var y = 0; var rectWidth = rect.width; var rectHeight = rect.height; switch (position) { case 'inside': x = rect.x + rectWidth / 2 - domWidth / 2; y = rect.y + rectHeight / 2 - domHeight / 2; break; case 'top': x = rect.x + rectWidth / 2 - domWidth / 2; y = rect.y - domHeight - gap; break; case 'bottom': x = rect.x + rectWidth / 2 - domWidth / 2; y = rect.y + rectHeight + gap; break; case 'left': x = rect.x - domWidth - gap; y = rect.y + rectHeight / 2 - domHeight / 2; break; case 'right': x = rect.x + rectWidth + gap; y = rect.y + rectHeight / 2 - domHeight / 2; } return [x, y]; } function isCenterAlign(align) { return align === 'center' || align === 'middle'; } /***/ }), /* 337 */ /***/ (function(module, exports, __webpack_require__) { /** * @module echarts/component/tooltip/TooltipContent */ var zrUtil = __webpack_require__(4); var zrColor = __webpack_require__(33); var eventUtil = __webpack_require__(93); var formatUtil = __webpack_require__(6); var each = zrUtil.each; var toCamelCase = formatUtil.toCamelCase; var env = __webpack_require__(2); var vendors = ['', '-webkit-', '-moz-', '-o-']; var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;'; /** * @param {number} duration * @return {string} * @inner */ function assembleTransition(duration) { var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)'; var transitionText = 'left ' + duration + 's ' + transitionCurve + ',' + 'top ' + duration + 's ' + transitionCurve; return zrUtil.map(vendors, function (vendorPrefix) { return vendorPrefix + 'transition:' + transitionText; }).join(';'); } /** * @param {Object} textStyle * @return {string} * @inner */ function assembleFont(textStyleModel) { var cssText = []; var fontSize = textStyleModel.get('fontSize'); var color = textStyleModel.getTextColor(); color && cssText.push('color:' + color); cssText.push('font:' + textStyleModel.getFont()); fontSize && cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px'); each(['decoration', 'align'], function (name) { var val = textStyleModel.get(name); val && cssText.push('text-' + name + ':' + val); }); return cssText.join(';'); } /** * @param {Object} tooltipModel * @return {string} * @inner */ function assembleCssText(tooltipModel) { var cssText = []; var transitionDuration = tooltipModel.get('transitionDuration'); var backgroundColor = tooltipModel.get('backgroundColor'); var textStyleModel = tooltipModel.getModel('textStyle'); var padding = tooltipModel.get('padding'); // Animation transition. Do not animate when transitionDuration is 0. transitionDuration && cssText.push(assembleTransition(transitionDuration)); if (backgroundColor) { if (env.canvasSupported) { cssText.push('background-Color:' + backgroundColor); } else { // for ie cssText.push( 'background-Color:#' + zrColor.toHex(backgroundColor) ); cssText.push('filter:alpha(opacity=70)'); } } // Border style each(['width', 'color', 'radius'], function (name) { var borderName = 'border-' + name; var camelCase = toCamelCase(borderName); var val = tooltipModel.get(camelCase); val != null && cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px')); }); // Text style cssText.push(assembleFont(textStyleModel)); // Padding if (padding != null) { cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px'); } return cssText.join(';') + ';'; } /** * @alias module:echarts/component/tooltip/TooltipContent * @constructor */ function TooltipContent(container, api) { var el = document.createElement('div'); var zr = this._zr = api.getZr(); this.el = el; this._x = api.getWidth() / 2; this._y = api.getHeight() / 2; container.appendChild(el); this._container = container; this._show = false; /** * @private */ this._hideTimeout; var self = this; el.onmouseenter = function () { // clear the timeout in hideLater and keep showing tooltip if (self._enterable) { clearTimeout(self._hideTimeout); self._show = true; } self._inContent = true; }; el.onmousemove = function (e) { e = e || window.event; if (!self._enterable) { // Try trigger zrender event to avoid mouse // in and out shape too frequently var handler = zr.handler; eventUtil.normalizeEvent(container, e, true); handler.dispatch('mousemove', e); } }; el.onmouseleave = function () { if (self._enterable) { if (self._show) { self.hideLater(self._hideDelay); } } self._inContent = false; }; } TooltipContent.prototype = { constructor: TooltipContent, /** * @private * @type {boolean} */ _enterable: true, /** * Update when tooltip is rendered */ update: function () { // FIXME // Move this logic to ec main? var container = this._container; var stl = container.currentStyle || document.defaultView.getComputedStyle(container); var domStyle = container.style; if (domStyle.position !== 'absolute' && stl.position !== 'absolute') { domStyle.position = 'relative'; } // Hide the tooltip // PENDING // this.hide(); }, show: function (tooltipModel) { clearTimeout(this._hideTimeout); var el = this.el; el.style.cssText = gCssText + assembleCssText(tooltipModel) // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore + ';left:' + this._x + 'px;top:' + this._y + 'px;' + (tooltipModel.get('extraCssText') || ''); el.style.display = el.innerHTML ? 'block' : 'none'; this._show = true; }, setContent: function (content) { this.el.innerHTML = content == null ? '' : content; }, setEnterable: function (enterable) { this._enterable = enterable; }, getSize: function () { var el = this.el; return [el.clientWidth, el.clientHeight]; }, moveTo: function (x, y) { // xy should be based on canvas root. But tooltipContent is // the sibling of canvas root. So padding of ec container // should be considered here. var zr = this._zr; var viewportRootOffset; if (zr && zr.painter && (viewportRootOffset = zr.painter.getViewportRootOffset())) { x += viewportRootOffset.offsetLeft; y += viewportRootOffset.offsetTop; } var style = this.el.style; style.left = x + 'px'; style.top = y + 'px'; this._x = x; this._y = y; }, hide: function () { this.el.style.display = 'none'; this._show = false; }, hideLater: function (time) { if (this._show && !(this._inContent && this._enterable)) { if (time) { this._hideDelay = time; // Set show false to avoid invoke hideLater mutiple times this._show = false; this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time); } else { this.hide(); } } }, isShow: function () { return this._show; } }; module.exports = TooltipContent; /***/ }), /* 338 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var zrUtil = __webpack_require__(4); __webpack_require__(339); __webpack_require__(345); __webpack_require__(347); __webpack_require__(301); __webpack_require__(349); // For reducing size of echarts.min, barLayoutPolar is required by polar. __webpack_require__(1).registerLayout(zrUtil.curry(__webpack_require__(350), 'bar')); // Polar view __webpack_require__(1).extendComponentView({ type: 'polar' }); /***/ }), /* 339 */ /***/ (function(module, exports, __webpack_require__) { // TODO Axis scale var Polar = __webpack_require__(340); var numberUtil = __webpack_require__(7); var zrUtil = __webpack_require__(4); var axisHelper = __webpack_require__(104); var niceScaleExtent = axisHelper.niceScaleExtent; // 依赖 PolarModel 做预处理 __webpack_require__(343); /** * Resize method bound to the polar * @param {module:echarts/coord/polar/PolarModel} polarModel * @param {module:echarts/ExtensionAPI} api */ function resizePolar(polarModel, api) { var center = polarModel.get('center'); var radius = polarModel.get('radius'); var width = api.getWidth(); var height = api.getHeight(); var parsePercent = numberUtil.parsePercent; this.cx = parsePercent(center[0], width); this.cy = parsePercent(center[1], height); var radiusAxis = this.getRadiusAxis(); var size = Math.min(width, height) / 2; // var idx = radiusAxis.inverse ? 1 : 0; radiusAxis.setExtent(0, parsePercent(radius, size)); } /** * Update polar */ function updatePolarScale(ecModel, api) { var polar = this; var angleAxis = polar.getAngleAxis(); var radiusAxis = polar.getRadiusAxis(); // Reset scale angleAxis.scale.setExtent(Infinity, -Infinity); radiusAxis.scale.setExtent(Infinity, -Infinity); ecModel.eachSeries(function (seriesModel) { if (seriesModel.coordinateSystem === polar) { var data = seriesModel.getData(); radiusAxis.scale.unionExtentFromData(data, 'radius'); angleAxis.scale.unionExtentFromData(data, 'angle'); } }); niceScaleExtent(angleAxis.scale, angleAxis.model); niceScaleExtent(radiusAxis.scale, radiusAxis.model); // Fix extent of category angle axis if (angleAxis.type === 'category' && !angleAxis.onBand) { var extent = angleAxis.getExtent(); var diff = 360 / angleAxis.scale.count(); angleAxis.inverse ? (extent[1] += diff) : (extent[1] -= diff); angleAxis.setExtent(extent[0], extent[1]); } } /** * Set common axis properties * @param {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis} * @param {module:echarts/coord/polar/AxisModel} * @inner */ function setAxis(axis, axisModel) { axis.type = axisModel.get('type'); axis.scale = axisHelper.createScaleByModel(axisModel); axis.onBand = axisModel.get('boundaryGap') && axis.type === 'category'; // FIXME Radius axis not support inverse axis if (axisModel.mainType === 'angleAxis') { var startAngle = axisModel.get('startAngle'); axis.inverse = axisModel.get('inverse') ^ axisModel.get('clockwise'); axis.setExtent(startAngle, startAngle + (axis.inverse ? -360 : 360)); } // Inject axis instance axisModel.axis = axis; axis.model = axisModel; } var polarCreator = { dimensions: Polar.prototype.dimensions, create: function (ecModel, api) { var polarList = []; ecModel.eachComponent('polar', function (polarModel, idx) { var polar = new Polar(idx); // Inject resize and update method polar.resize = resizePolar; polar.update = updatePolarScale; var radiusAxis = polar.getRadiusAxis(); var angleAxis = polar.getAngleAxis(); var radiusAxisModel = polarModel.findAxisModel('radiusAxis'); var angleAxisModel = polarModel.findAxisModel('angleAxis'); setAxis(radiusAxis, radiusAxisModel); setAxis(angleAxis, angleAxisModel); polar.resize(polarModel, api); polarList.push(polar); polarModel.coordinateSystem = polar; polar.model = polarModel; }); // Inject coordinateSystem to series ecModel.eachSeries(function (seriesModel) { if (seriesModel.get('coordinateSystem') === 'polar') { var polarModel = ecModel.queryComponents({ mainType: 'polar', index: seriesModel.get('polarIndex'), id: seriesModel.get('polarId') })[0]; if (true) { if (!polarModel) { throw new Error( 'Polar \"' + zrUtil.retrieve( seriesModel.get('polarIndex'), seriesModel.get('polarId'), 0 ) + '\" not found' ); } } seriesModel.coordinateSystem = polarModel.coordinateSystem; } }); return polarList; } }; __webpack_require__(79).register('polar', polarCreator); /***/ }), /* 340 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; /** * @module echarts/coord/polar/Polar */ var RadiusAxis = __webpack_require__(341); var AngleAxis = __webpack_require__(342); /** * @alias {module:echarts/coord/polar/Polar} * @constructor * @param {string} name */ var Polar = function (name) { /** * @type {string} */ this.name = name || ''; /** * x of polar center * @type {number} */ this.cx = 0; /** * y of polar center * @type {number} */ this.cy = 0; /** * @type {module:echarts/coord/polar/RadiusAxis} * @private */ this._radiusAxis = new RadiusAxis(); /** * @type {module:echarts/coord/polar/AngleAxis} * @private */ this._angleAxis = new AngleAxis(); this._radiusAxis.polar = this._angleAxis.polar = this; }; Polar.prototype = { type: 'polar', axisPointerEnabled: true, constructor: Polar, /** * @param {Array.} * @readOnly */ dimensions: ['radius', 'angle'], /** * @type {module:echarts/coord/PolarModel} */ model: null, /** * If contain coord * @param {Array.} point * @return {boolean} */ containPoint: function (point) { var coord = this.pointToCoord(point); return this._radiusAxis.contain(coord[0]) && this._angleAxis.contain(coord[1]); }, /** * If contain data * @param {Array.} data * @return {boolean} */ containData: function (data) { return this._radiusAxis.containData(data[0]) && this._angleAxis.containData(data[1]); }, /** * @param {string} dim * @return {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis} */ getAxis: function (dim) { return this['_' + dim + 'Axis']; }, /** * @return {Array.} */ getAxes: function () { return [this._radiusAxis, this._angleAxis]; }, /** * Get axes by type of scale * @param {string} scaleType * @return {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis} */ getAxesByScale: function (scaleType) { var axes = []; var angleAxis = this._angleAxis; var radiusAxis = this._radiusAxis; angleAxis.scale.type === scaleType && axes.push(angleAxis); radiusAxis.scale.type === scaleType && axes.push(radiusAxis); return axes; }, /** * @return {module:echarts/coord/polar/AngleAxis} */ getAngleAxis: function () { return this._angleAxis; }, /** * @return {module:echarts/coord/polar/RadiusAxis} */ getRadiusAxis: function () { return this._radiusAxis; }, /** * @param {module:echarts/coord/polar/Axis} * @return {module:echarts/coord/polar/Axis} */ getOtherAxis: function (axis) { var angleAxis = this._angleAxis; return axis === angleAxis ? this._radiusAxis : angleAxis; }, /** * Base axis will be used on stacking. * * @return {module:echarts/coord/polar/Axis} */ getBaseAxis: function () { return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAngleAxis(); }, /** * @param {string} [dim] 'radius' or 'angle' or 'auto' or null/undefined * @return {Object} {baseAxes: [], otherAxes: []} */ getTooltipAxes: function (dim) { var baseAxis = (dim != null && dim !== 'auto') ? this.getAxis(dim) : this.getBaseAxis(); return { baseAxes: [baseAxis], otherAxes: [this.getOtherAxis(baseAxis)] }; }, /** * Convert a single data item to (x, y) point. * Parameter data is an array which the first element is radius and the second is angle * @param {Array.} data * @param {boolean} [clamp=false] * @return {Array.} */ dataToPoint: function (data, clamp) { return this.coordToPoint([ this._radiusAxis.dataToRadius(data[0], clamp), this._angleAxis.dataToAngle(data[1], clamp) ]); }, /** * Convert a (x, y) point to data * @param {Array.} point * @param {boolean} [clamp=false] * @return {Array.} */ pointToData: function (point, clamp) { var coord = this.pointToCoord(point); return [ this._radiusAxis.radiusToData(coord[0], clamp), this._angleAxis.angleToData(coord[1], clamp) ]; }, /** * Convert a (x, y) point to (radius, angle) coord * @param {Array.} point * @return {Array.} */ pointToCoord: function (point) { var dx = point[0] - this.cx; var dy = point[1] - this.cy; var angleAxis = this.getAngleAxis(); var extent = angleAxis.getExtent(); var minAngle = Math.min(extent[0], extent[1]); var maxAngle = Math.max(extent[0], extent[1]); // Fix fixed extent in polarCreator // FIXME angleAxis.inverse ? (minAngle = maxAngle - 360) : (maxAngle = minAngle + 360); var radius = Math.sqrt(dx * dx + dy * dy); dx /= radius; dy /= radius; var radian = Math.atan2(-dy, dx) / Math.PI * 180; // move to angleExtent var dir = radian < minAngle ? 1 : -1; while (radian < minAngle || radian > maxAngle) { radian += dir * 360; } return [radius, radian]; }, /** * Convert a (radius, angle) coord to (x, y) point * @param {Array.} coord * @return {Array.} */ coordToPoint: function (coord) { var radius = coord[0]; var radian = coord[1] / 180 * Math.PI; var x = Math.cos(radian) * radius + this.cx; // Inverse the y var y = -Math.sin(radian) * radius + this.cy; return [x, y]; } }; module.exports = Polar; /***/ }), /* 341 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var zrUtil = __webpack_require__(4); var Axis = __webpack_require__(103); function RadiusAxis(scale, radiusExtent) { Axis.call(this, 'radius', scale, radiusExtent); /** * Axis type * - 'category' * - 'value' * - 'time' * - 'log' * @type {string} */ this.type = 'category'; } RadiusAxis.prototype = { constructor: RadiusAxis, /** * @override */ pointToData: function (point, clamp) { return this.polar.pointToData(point, clamp)[this.dim === 'radius' ? 0 : 1]; }, dataToRadius: Axis.prototype.dataToCoord, radiusToData: Axis.prototype.coordToData }; zrUtil.inherits(RadiusAxis, Axis); module.exports = RadiusAxis; /***/ }), /* 342 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var zrUtil = __webpack_require__(4); var Axis = __webpack_require__(103); function AngleAxis(scale, angleExtent) { angleExtent = angleExtent || [0, 360]; Axis.call(this, 'angle', scale, angleExtent); /** * Axis type * - 'category' * - 'value' * - 'time' * - 'log' * @type {string} */ this.type = 'category'; } AngleAxis.prototype = { constructor: AngleAxis, /** * @override */ pointToData: function (point, clamp) { return this.polar.pointToData(point, clamp)[this.dim === 'radius' ? 0 : 1]; }, dataToAngle: Axis.prototype.dataToCoord, angleToData: Axis.prototype.coordToData }; zrUtil.inherits(AngleAxis, Axis); module.exports = AngleAxis; /***/ }), /* 343 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(344); __webpack_require__(1).extendComponentModel({ type: 'polar', dependencies: ['polarAxis', 'angleAxis'], /** * @type {module:echarts/coord/polar/Polar} */ coordinateSystem: null, /** * @param {string} axisType * @return {module:echarts/coord/polar/AxisModel} */ findAxisModel: function (axisType) { var foundAxisModel; var ecModel = this.ecModel; ecModel.eachComponent(axisType, function (axisModel) { if (axisModel.getCoordSysModel() === this) { foundAxisModel = axisModel; } }, this); return foundAxisModel; }, defaultOption: { zlevel: 0, z: 0, center: ['50%', '50%'], radius: '80%' } }); /***/ }), /* 344 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var zrUtil = __webpack_require__(4); var ComponentModel = __webpack_require__(72); var axisModelCreator = __webpack_require__(134); var PolarAxisModel = ComponentModel.extend({ type: 'polarAxis', /** * @type {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis} */ axis: null, /** * @override */ getCoordSysModel: function () { return this.ecModel.queryComponents({ mainType: 'polar', index: this.option.polarIndex, id: this.option.polarId })[0]; } }); zrUtil.merge(PolarAxisModel.prototype, __webpack_require__(115)); var polarAxisDefaultExtendedOption = { angle: { // polarIndex: 0, // polarId: '', startAngle: 90, clockwise: true, splitNumber: 12, axisLabel: { rotate: false } }, radius: { // polarIndex: 0, // polarId: '', splitNumber: 5 } }; function getAxisType(axisDim, option) { // Default axis with data is category axis return option.type || (option.data ? 'category' : 'value'); } axisModelCreator('angle', PolarAxisModel, getAxisType, polarAxisDefaultExtendedOption.angle); axisModelCreator('radius', PolarAxisModel, getAxisType, polarAxisDefaultExtendedOption.radius); /***/ }), /* 345 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(339); __webpack_require__(346); /***/ }), /* 346 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var zrUtil = __webpack_require__(4); var graphic = __webpack_require__(20); var Model = __webpack_require__(14); var elementList = ['axisLine', 'axisLabel', 'axisTick', 'splitLine', 'splitArea']; function getAxisLineShape(polar, r0, r, angle) { var start = polar.coordToPoint([r0, angle]); var end = polar.coordToPoint([r, angle]); return { x1: start[0], y1: start[1], x2: end[0], y2: end[1] }; } __webpack_require__(139).extend({ type: 'angleAxis', axisPointerClass: 'PolarAxisPointer', render: function (angleAxisModel, ecModel) { this.group.removeAll(); if (!angleAxisModel.get('show')) { return; } var angleAxis = angleAxisModel.axis; var polar = angleAxis.polar; var radiusExtent = polar.getRadiusAxis().getExtent(); var ticksAngles = angleAxis.getTicksCoords(); if (angleAxis.type !== 'category') { // Remove the last tick which will overlap the first tick ticksAngles.pop(); } zrUtil.each(elementList, function (name) { if (angleAxisModel.get(name +'.show') && (!angleAxis.scale.isBlank() || name === 'axisLine') ) { this['_' + name](angleAxisModel, polar, ticksAngles, radiusExtent); } }, this); }, /** * @private */ _axisLine: function (angleAxisModel, polar, ticksAngles, radiusExtent) { var lineStyleModel = angleAxisModel.getModel('axisLine.lineStyle'); var circle = new graphic.Circle({ shape: { cx: polar.cx, cy: polar.cy, r: radiusExtent[1] }, style: lineStyleModel.getLineStyle(), z2: 1, silent: true }); circle.style.fill = null; this.group.add(circle); }, /** * @private */ _axisTick: function (angleAxisModel, polar, ticksAngles, radiusExtent) { var tickModel = angleAxisModel.getModel('axisTick'); var tickLen = (tickModel.get('inside') ? -1 : 1) * tickModel.get('length'); var lines = zrUtil.map(ticksAngles, function (tickAngle) { return new graphic.Line({ shape: getAxisLineShape(polar, radiusExtent[1], radiusExtent[1] + tickLen, tickAngle) }); }); this.group.add(graphic.mergePath( lines, { style: zrUtil.defaults( tickModel.getModel('lineStyle').getLineStyle(), { stroke: angleAxisModel.get('axisLine.lineStyle.color') } ) } )); }, /** * @private */ _axisLabel: function (angleAxisModel, polar, ticksAngles, radiusExtent) { var axis = angleAxisModel.axis; var categoryData = angleAxisModel.get('data'); var labelModel = angleAxisModel.getModel('axisLabel'); var labels = angleAxisModel.getFormattedLabels(); var labelMargin = labelModel.get('margin'); var labelsAngles = axis.getLabelsCoords(); // Use length of ticksAngles because it may remove the last tick to avoid overlapping for (var i = 0; i < ticksAngles.length; i++) { var r = radiusExtent[1]; var p = polar.coordToPoint([r + labelMargin, labelsAngles[i]]); var cx = polar.cx; var cy = polar.cy; var labelTextAlign = Math.abs(p[0] - cx) / r < 0.3 ? 'center' : (p[0] > cx ? 'left' : 'right'); var labelTextVerticalAlign = Math.abs(p[1] - cy) / r < 0.3 ? 'middle' : (p[1] > cy ? 'top' : 'bottom'); if (categoryData && categoryData[i] && categoryData[i].textStyle) { labelModel = new Model(categoryData[i].textStyle, labelModel, labelModel.ecModel); } var textEl = new graphic.Text({silent: true}); this.group.add(textEl); graphic.setTextStyle(textEl.style, labelModel, { x: p[0], y: p[1], textFill: labelModel.getTextColor() || angleAxisModel.get('axisLine.lineStyle.color'), text: labels[i], textAlign: labelTextAlign, textVerticalAlign: labelTextVerticalAlign }); } }, /** * @private */ _splitLine: function (angleAxisModel, polar, ticksAngles, radiusExtent) { var splitLineModel = angleAxisModel.getModel('splitLine'); var lineStyleModel = splitLineModel.getModel('lineStyle'); var lineColors = lineStyleModel.get('color'); var lineCount = 0; lineColors = lineColors instanceof Array ? lineColors : [lineColors]; var splitLines = []; for (var i = 0; i < ticksAngles.length; i++) { var colorIndex = (lineCount++) % lineColors.length; splitLines[colorIndex] = splitLines[colorIndex] || []; splitLines[colorIndex].push(new graphic.Line({ shape: getAxisLineShape(polar, radiusExtent[0], radiusExtent[1], ticksAngles[i]) })); } // Simple optimization // Batching the lines if color are the same for (var i = 0; i < splitLines.length; i++) { this.group.add(graphic.mergePath(splitLines[i], { style: zrUtil.defaults({ stroke: lineColors[i % lineColors.length] }, lineStyleModel.getLineStyle()), silent: true, z: angleAxisModel.get('z') })); } }, /** * @private */ _splitArea: function (angleAxisModel, polar, ticksAngles, radiusExtent) { var splitAreaModel = angleAxisModel.getModel('splitArea'); var areaStyleModel = splitAreaModel.getModel('areaStyle'); var areaColors = areaStyleModel.get('color'); var lineCount = 0; areaColors = areaColors instanceof Array ? areaColors : [areaColors]; var splitAreas = []; var RADIAN = Math.PI / 180; var prevAngle = -ticksAngles[0] * RADIAN; var r0 = Math.min(radiusExtent[0], radiusExtent[1]); var r1 = Math.max(radiusExtent[0], radiusExtent[1]); var clockwise = angleAxisModel.get('clockwise'); for (var i = 1; i < ticksAngles.length; i++) { var colorIndex = (lineCount++) % areaColors.length; splitAreas[colorIndex] = splitAreas[colorIndex] || []; splitAreas[colorIndex].push(new graphic.Sector({ shape: { cx: polar.cx, cy: polar.cy, r0: r0, r: r1, startAngle: prevAngle, endAngle: -ticksAngles[i] * RADIAN, clockwise: clockwise }, silent: true })); prevAngle = -ticksAngles[i] * RADIAN; } // Simple optimization // Batching the lines if color are the same for (var i = 0; i < splitAreas.length; i++) { this.group.add(graphic.mergePath(splitAreas[i], { style: zrUtil.defaults({ fill: areaColors[i % areaColors.length] }, areaStyleModel.getAreaStyle()), silent: true })); } } }); /***/ }), /* 347 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(339); __webpack_require__(348); /***/ }), /* 348 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var zrUtil = __webpack_require__(4); var graphic = __webpack_require__(20); var AxisBuilder = __webpack_require__(138); var axisBuilderAttrs = [ 'axisLine', 'axisTickLabel', 'axisName' ]; var selfBuilderAttrs = [ 'splitLine', 'splitArea' ]; __webpack_require__(139).extend({ type: 'radiusAxis', axisPointerClass: 'PolarAxisPointer', render: function (radiusAxisModel, ecModel) { this.group.removeAll(); if (!radiusAxisModel.get('show')) { return; } var radiusAxis = radiusAxisModel.axis; var polar = radiusAxis.polar; var angleAxis = polar.getAngleAxis(); var ticksCoords = radiusAxis.getTicksCoords(); var axisAngle = angleAxis.getExtent()[0]; var radiusExtent = radiusAxis.getExtent(); var layout = layoutAxis(polar, radiusAxisModel, axisAngle); var axisBuilder = new AxisBuilder(radiusAxisModel, layout); zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder); this.group.add(axisBuilder.getGroup()); zrUtil.each(selfBuilderAttrs, function (name) { if (radiusAxisModel.get(name +'.show') && !radiusAxis.scale.isBlank()) { this['_' + name](radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords); } }, this); }, /** * @private */ _splitLine: function (radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) { var splitLineModel = radiusAxisModel.getModel('splitLine'); var lineStyleModel = splitLineModel.getModel('lineStyle'); var lineColors = lineStyleModel.get('color'); var lineCount = 0; lineColors = lineColors instanceof Array ? lineColors : [lineColors]; var splitLines = []; for (var i = 0; i < ticksCoords.length; i++) { var colorIndex = (lineCount++) % lineColors.length; splitLines[colorIndex] = splitLines[colorIndex] || []; splitLines[colorIndex].push(new graphic.Circle({ shape: { cx: polar.cx, cy: polar.cy, r: ticksCoords[i] }, silent: true })); } // Simple optimization // Batching the lines if color are the same for (var i = 0; i < splitLines.length; i++) { this.group.add(graphic.mergePath(splitLines[i], { style: zrUtil.defaults({ stroke: lineColors[i % lineColors.length], fill: null }, lineStyleModel.getLineStyle()), silent: true })); } }, /** * @private */ _splitArea: function (radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) { var splitAreaModel = radiusAxisModel.getModel('splitArea'); var areaStyleModel = splitAreaModel.getModel('areaStyle'); var areaColors = areaStyleModel.get('color'); var lineCount = 0; areaColors = areaColors instanceof Array ? areaColors : [areaColors]; var splitAreas = []; var prevRadius = ticksCoords[0]; for (var i = 1; i < ticksCoords.length; i++) { var colorIndex = (lineCount++) % areaColors.length; splitAreas[colorIndex] = splitAreas[colorIndex] || []; splitAreas[colorIndex].push(new graphic.Sector({ shape: { cx: polar.cx, cy: polar.cy, r0: prevRadius, r: ticksCoords[i], startAngle: 0, endAngle: Math.PI * 2 }, silent: true })); prevRadius = ticksCoords[i]; } // Simple optimization // Batching the lines if color are the same for (var i = 0; i < splitAreas.length; i++) { this.group.add(graphic.mergePath(splitAreas[i], { style: zrUtil.defaults({ fill: areaColors[i % areaColors.length] }, areaStyleModel.getAreaStyle()), silent: true })); } } }); /** * @inner */ function layoutAxis(polar, radiusAxisModel, axisAngle) { return { position: [polar.cx, polar.cy], rotation: axisAngle / 180 * Math.PI, labelDirection: -1, tickDirection: -1, nameDirection: 1, labelRotate: radiusAxisModel.getModel('axisLabel').get('rotate'), // Over splitLine and splitArea z2: 1 }; } /***/ }), /* 349 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var formatUtil = __webpack_require__(6); var BaseAxisPointer = __webpack_require__(308); var graphic = __webpack_require__(20); var viewHelper = __webpack_require__(309); var matrix = __webpack_require__(11); var AxisBuilder = __webpack_require__(138); var AxisView = __webpack_require__(139); var PolarAxisPointer = BaseAxisPointer.extend({ /** * @override */ makeElOption: function (elOption, value, axisModel, axisPointerModel, api) { var axis = axisModel.axis; if (axis.dim === 'angle') { this.animationThreshold = Math.PI / 18; } var polar = axis.polar; var otherAxis = polar.getOtherAxis(axis); var otherExtent = otherAxis.getExtent(); var coordValue; coordValue = axis['dataTo' + formatUtil.capitalFirst(axis.dim)](value); var axisPointerType = axisPointerModel.get('type'); if (axisPointerType && axisPointerType !== 'none') { var elStyle = viewHelper.buildElStyle(axisPointerModel); var pointerOption = pointerShapeBuilder[axisPointerType]( axis, polar, coordValue, otherExtent, elStyle ); pointerOption.style = elStyle; elOption.graphicKey = pointerOption.type; elOption.pointer = pointerOption; } var labelMargin = axisPointerModel.get('label.margin'); var labelPos = getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin); viewHelper.buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos); } // Do not support handle, utill any user requires it. }); function getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin) { var axis = axisModel.axis; var coord = axis.dataToCoord(value); var axisAngle = polar.getAngleAxis().getExtent()[0]; axisAngle = axisAngle / 180 * Math.PI; var radiusExtent = polar.getRadiusAxis().getExtent(); var position; var align; var verticalAlign; if (axis.dim === 'radius') { var transform = matrix.create(); matrix.rotate(transform, transform, axisAngle); matrix.translate(transform, transform, [polar.cx, polar.cy]); position = graphic.applyTransform([coord, -labelMargin], transform); var labelRotation = axisModel.getModel('axisLabel').get('rotate') || 0; var labelLayout = AxisBuilder.innerTextLayout( axisAngle, labelRotation * Math.PI / 180, -1 ); align = labelLayout.textAlign; verticalAlign = labelLayout.textVerticalAlign; } else { // angle axis var r = radiusExtent[1]; position = polar.coordToPoint([r + labelMargin, coord]); var cx = polar.cx; var cy = polar.cy; align = Math.abs(position[0] - cx) / r < 0.3 ? 'center' : (position[0] > cx ? 'left' : 'right'); verticalAlign = Math.abs(position[1] - cy) / r < 0.3 ? 'middle' : (position[1] > cy ? 'top' : 'bottom'); } return { position: position, align: align, verticalAlign: verticalAlign }; } var pointerShapeBuilder = { line: function (axis, polar, coordValue, otherExtent, elStyle) { return axis.dim === 'angle' ? { type: 'Line', shape: viewHelper.makeLineShape( polar.coordToPoint([otherExtent[0], coordValue]), polar.coordToPoint([otherExtent[1], coordValue]) ) } : { type: 'Circle', shape: { cx: polar.cx, cy: polar.cy, r: coordValue } }; }, shadow: function (axis, polar, coordValue, otherExtent, elStyle) { var bandWidth = axis.getBandWidth(); var radian = Math.PI / 180; return axis.dim === 'angle' ? { type: 'Sector', shape: viewHelper.makeSectorShape( polar.cx, polar.cy, otherExtent[0], otherExtent[1], // In ECharts y is negative if angle is positive (-coordValue - bandWidth / 2) * radian, (-coordValue + bandWidth / 2) * radian ) } : { type: 'Sector', shape: viewHelper.makeSectorShape( polar.cx, polar.cy, coordValue - bandWidth / 2, coordValue + bandWidth / 2, 0, Math.PI * 2 ) }; } }; AxisView.registerAxisPointerClass('PolarAxisPointer', PolarAxisPointer); module.exports = PolarAxisPointer; /***/ }), /* 350 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var zrUtil = __webpack_require__(4); var parsePercent = __webpack_require__(7).parsePercent; function getSeriesStackId(seriesModel) { return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex; } function getAxisKey(axis) { return axis.dim; } /** * @param {string} seriesType * @param {module:echarts/model/Global} ecModel * @param {module:echarts/ExtensionAPI} api */ function barLayoutPolar(seriesType, ecModel, api) { var width = api.getWidth(); var height = api.getHeight(); var lastStackCoords = {}; var lastStackCoordsOrigin = {}; var barWidthAndOffset = calRadialBar( zrUtil.filter( ecModel.getSeriesByType(seriesType), function (seriesModel) { return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'polar'; } ) ); ecModel.eachSeriesByType(seriesType, function (seriesModel) { // Check series coordinate, do layout for polar only if (seriesModel.coordinateSystem.type !== 'polar') { return; } var data = seriesModel.getData(); var polar = seriesModel.coordinateSystem; var angleAxis = polar.getAngleAxis(); var baseAxis = polar.getBaseAxis(); var stackId = getSeriesStackId(seriesModel); var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId]; var columnOffset = columnLayoutInfo.offset; var columnWidth = columnLayoutInfo.width; var valueAxis = polar.getOtherAxis(baseAxis); var center = seriesModel.get('center') || ['50%', '50%']; var cx = parsePercent(center[0], width); var cy = parsePercent(center[1], height); var barMinHeight = seriesModel.get('barMinHeight') || 0; var barMinAngle = seriesModel.get('barMinAngle') || 0; var valueAxisStart = valueAxis.getExtent()[0]; var valueMax = valueAxis.model.get('max'); var valueMin = valueAxis.model.get('min'); var coordDims = [ seriesModel.coordDimToDataDim('radius')[0], seriesModel.coordDimToDataDim('angle')[0] ]; var coords = data.mapArray(coordDims, function (radius, angle) { return polar.dataToPoint([radius, angle]); }, true); lastStackCoords[stackId] = lastStackCoords[stackId] || []; lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243 data.each(seriesModel.coordDimToDataDim(valueAxis.dim)[0], function (value, idx) { if (isNaN(value)) { return; } if (!lastStackCoords[stackId][idx]) { lastStackCoords[stackId][idx] = { p: valueAxisStart, // Positive stack n: valueAxisStart // Negative stack }; lastStackCoordsOrigin[stackId][idx] = { p: valueAxisStart, // Positive stack n: valueAxisStart // Negative stack }; } var sign = value >= 0 ? 'p' : 'n'; var coord = polar.pointToCoord(coords[idx]); var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign]; var r0; var r; var startAngle; var endAngle; if (valueAxis.dim === 'radius') { // radial sector r0 = lastCoordOrigin; r = coord[0]; startAngle = (-coord[1] + columnOffset) * Math.PI / 180; endAngle = startAngle + columnWidth * Math.PI / 180; if (Math.abs(r) < barMinHeight) { r = r0 + (r < 0 ? -1 : 1) * barMinHeight; } lastStackCoordsOrigin[stackId][idx][sign] = r; } else { // tangential sector r0 = coord[0] + columnOffset; r = r0 + columnWidth; // clamp data if min or max is defined for valueAxis if (valueMax != null) { value = Math.min(value, valueMax); } if (valueMin != null) { value = Math.max(value, valueMin); } var angle = angleAxis.dataToAngle(value); if (Math.abs(angle - lastCoordOrigin) < barMinAngle) { angle = lastCoordOrigin - (value < 0 ? -1 : 1) * barMinAngle; } startAngle = -lastCoordOrigin * Math.PI / 180; endAngle = -angle * Math.PI / 180; // if the previous stack is at the end of the ring, // add a round to differentiate it from origin var extent = angleAxis.getExtent(); var stackCoord = angle; if (stackCoord === extent[0] && value > 0) { stackCoord = extent[1]; } else if (stackCoord === extent[1] && value < 0) { stackCoord = extent[0]; } lastStackCoordsOrigin[stackId][idx][sign] = stackCoord; } data.setItemLayout(idx, { cx: cx, cy: cy, r0: r0, r: r, startAngle: startAngle, endAngle: endAngle }); }, true); }, this); } /** * Calculate bar width and offset for radial bar charts */ function calRadialBar(barSeries, api) { // Columns info on each category axis. Key is polar name var columnsMap = {}; zrUtil.each(barSeries, function (seriesModel, idx) { var data = seriesModel.getData(); var polar = seriesModel.coordinateSystem; var baseAxis = polar.getBaseAxis(); var axisExtent = baseAxis.getExtent(); var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : (Math.abs(axisExtent[1] - axisExtent[0]) / data.count()); var columnsOnAxis = columnsMap[getAxisKey(baseAxis)] || { bandWidth: bandWidth, remainedWidth: bandWidth, autoWidthCount: 0, categoryGap: '20%', gap: '30%', stacks: {} }; var stacks = columnsOnAxis.stacks; columnsMap[getAxisKey(baseAxis)] = columnsOnAxis; var stackId = getSeriesStackId(seriesModel); if (!stacks[stackId]) { columnsOnAxis.autoWidthCount++; } stacks[stackId] = stacks[stackId] || { width: 0, maxWidth: 0 }; var barWidth = parsePercent( seriesModel.get('barWidth'), bandWidth ); var barMaxWidth = parsePercent( seriesModel.get('barMaxWidth'), bandWidth ); var barGap = seriesModel.get('barGap'); var barCategoryGap = seriesModel.get('barCategoryGap'); if (barWidth && !stacks[stackId].width) { barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth); stacks[stackId].width = barWidth; columnsOnAxis.remainedWidth -= barWidth; } barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth); (barGap != null) && (columnsOnAxis.gap = barGap); (barCategoryGap != null) && (columnsOnAxis.categoryGap = barCategoryGap); }); var result = {}; zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) { result[coordSysName] = {}; var stacks = columnsOnAxis.stacks; var bandWidth = columnsOnAxis.bandWidth; var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth); var barGapPercent = parsePercent(columnsOnAxis.gap, 1); var remainedWidth = columnsOnAxis.remainedWidth; var autoWidthCount = columnsOnAxis.autoWidthCount; var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent); autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth zrUtil.each(stacks, function (column, stack) { var maxWidth = column.maxWidth; if (maxWidth && maxWidth < autoWidth) { maxWidth = Math.min(maxWidth, remainedWidth); if (column.width) { maxWidth = Math.min(maxWidth, column.width); } remainedWidth -= maxWidth; column.width = maxWidth; autoWidthCount--; } }); // Recalculate width again autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent); autoWidth = Math.max(autoWidth, 0); var widthSum = 0; var lastColumn; zrUtil.each(stacks, function (column, idx) { if (!column.width) { column.width = autoWidth; } lastColumn = column; widthSum += column.width * (1 + barGapPercent); }); if (lastColumn) { widthSum -= lastColumn.width * barGapPercent; } var offset = -widthSum / 2; zrUtil.each(stacks, function (column, stackId) { result[coordSysName][stackId] = result[coordSysName][stackId] || { offset: offset, width: column.width }; offset += column.width * (1 + barGapPercent); }); }); return result; } module.exports = barLayoutPolar; /***/ }), /* 351 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(352); __webpack_require__(174); __webpack_require__(353); __webpack_require__(190); var echarts = __webpack_require__(1); var zrUtil = __webpack_require__(4); function makeAction(method, actionInfo) { actionInfo.update = 'updateView'; echarts.registerAction(actionInfo, function (payload, ecModel) { var selected = {}; ecModel.eachComponent( { mainType: 'geo', query: payload}, function (geoModel) { geoModel[method](payload.name); var geo = geoModel.coordinateSystem; zrUtil.each(geo.regions, function (region) { selected[region.name] = geoModel.isSelected(region.name) || false; }); } ); return { selected: selected, name: payload.name }; }); } makeAction('toggleSelected', { type: 'geoToggleSelect', event: 'geoselectchanged' }); makeAction('select', { type: 'geoSelect', event: 'geoselected' }); makeAction('unSelect', { type: 'geoUnSelect', event: 'geounselected' }); /***/ }), /* 352 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var modelUtil = __webpack_require__(5); var ComponentModel = __webpack_require__(72); var Model = __webpack_require__(14); var zrUtil = __webpack_require__(4); var selectableMixin = __webpack_require__(151); var geoCreator = __webpack_require__(174); var GeoModel = ComponentModel.extend({ type: 'geo', /** * @type {module:echarts/coord/geo/Geo} */ coordinateSystem: null, layoutMode: 'box', init: function (option) { ComponentModel.prototype.init.apply(this, arguments); // Default label emphasis `show` modelUtil.defaultEmphasis(option.label, ['show']); }, optionUpdated: function () { var option = this.option; var self = this; option.regions = geoCreator.getFilledRegions(option.regions, option.map, option.nameMap); this._optionModelMap = zrUtil.reduce(option.regions || [], function (optionModelMap, regionOpt) { if (regionOpt.name) { optionModelMap.set(regionOpt.name, new Model(regionOpt, self)); } return optionModelMap; }, zrUtil.createHashMap()); this.updateSelectedMap(option.regions); }, defaultOption: { zlevel: 0, z: 0, show: true, left: 'center', top: 'center', // width:, // height:, // right // bottom // Aspect is width / height. Inited to be geoJson bbox aspect // This parameter is used for scale this aspect aspectScale: 0.75, ///// Layout with center and size // If you wan't to put map in a fixed size box with right aspect ratio // This two properties may more conveninet // layoutCenter: [50%, 50%] // layoutSize: 100 silent: false, // Map type map: '', // Define left-top, right-bottom coords to control view // For example, [ [180, 90], [-180, -90] ] boundingCoords: null, // Default on center of map center: null, zoom: 1, scaleLimit: null, // selectedMode: false label: { normal: { show: false, color: '#000' }, emphasis: { show: true, color: 'rgb(100,0,0)' } }, itemStyle: { normal: { // color: 各异, borderWidth: 0.5, borderColor: '#444', color: '#eee' }, emphasis: { // 也是选中样式 color: 'rgba(255,215,0,0.8)' } }, regions: [] }, /** * Get model of region * @param {string} name * @return {module:echarts/model/Model} */ getRegionModel: function (name) { return this._optionModelMap.get(name) || new Model(null, this, this.ecModel); }, /** * Format label * @param {string} name Region name * @param {string} [status='normal'] 'normal' or 'emphasis' * @return {string} */ getFormattedLabel: function (name, status) { var regionModel = this.getRegionModel(name); var formatter = regionModel.get('label.' + status + '.formatter'); var params = { name: name }; if (typeof formatter === 'function') { params.status = status; return formatter(params); } else if (typeof formatter === 'string') { return formatter.replace('{a}', name != null ? name : ''); } }, setZoom: function (zoom) { this.option.zoom = zoom; }, setCenter: function (center) { this.option.center = center; } }); zrUtil.mixin(GeoModel, selectableMixin); module.exports = GeoModel; /***/ }), /* 353 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var MapDraw = __webpack_require__(185); module.exports = __webpack_require__(1).extendComponentView({ type: 'geo', init: function (ecModel, api) { var mapDraw = new MapDraw(api, true); this._mapDraw = mapDraw; this.group.add(mapDraw.group); }, render: function (geoModel, ecModel, api, payload) { // Not render if it is an toggleSelect action from self if (payload && payload.type === 'geoToggleSelect' && payload.from === this.uid ) { return; } var mapDraw = this._mapDraw; if (geoModel.get('show')) { mapDraw.draw(geoModel, ecModel, api, this, payload); } else { this._mapDraw.group.removeAll(); } this.group.silent = geoModel.get('silent'); }, dispose: function () { this._mapDraw && this._mapDraw.remove(); } }); /***/ }), /* 354 */ /***/ (function(module, exports, __webpack_require__) { /** * Brush component entry */ __webpack_require__(1).registerPreprocessor( __webpack_require__(355) ); __webpack_require__(356); __webpack_require__(360); __webpack_require__(361); __webpack_require__(362); __webpack_require__(363); /***/ }), /* 355 */ /***/ (function(module, exports, __webpack_require__) { /** * @file brush preprocessor */ var zrUtil = __webpack_require__(4); var DEFAULT_TOOLBOX_BTNS = ['rect', 'polygon', 'keep', 'clear']; module.exports = function (option, isNew) { var brushComponents = option && option.brush; if (!zrUtil.isArray(brushComponents)) { brushComponents = brushComponents ? [brushComponents] : []; } if (!brushComponents.length) { return; } var brushComponentSpecifiedBtns = []; zrUtil.each(brushComponents, function (brushOpt) { var tbs = brushOpt.hasOwnProperty('toolbox') ? brushOpt.toolbox : []; if (tbs instanceof Array) { brushComponentSpecifiedBtns = brushComponentSpecifiedBtns.concat(tbs); } }); var toolbox = option && option.toolbox; if (zrUtil.isArray(toolbox)) { toolbox = toolbox[0]; } if (!toolbox) { toolbox = {feature: {}}; option.toolbox = [toolbox]; } var toolboxFeature = (toolbox.feature || (toolbox.feature = {})); var toolboxBrush = toolboxFeature.brush || (toolboxFeature.brush = {}); var brushTypes = toolboxBrush.type || (toolboxBrush.type = []); brushTypes.push.apply(brushTypes, brushComponentSpecifiedBtns); removeDuplicate(brushTypes); if (isNew && !brushTypes.length) { brushTypes.push.apply(brushTypes, DEFAULT_TOOLBOX_BTNS); } }; function removeDuplicate(arr) { var map = {}; zrUtil.each(arr, function (val) { map[val] = 1; }); arr.length = 0; zrUtil.each(map, function (flag, val) { arr.push(val); }); } /***/ }), /* 356 */ /***/ (function(module, exports, __webpack_require__) { /** * @file Brush visual coding. */ var echarts = __webpack_require__(1); var visualSolution = __webpack_require__(357); var zrUtil = __webpack_require__(4); var BoundingRect = __webpack_require__(9); var selector = __webpack_require__(358); var throttle = __webpack_require__(86); var BrushTargetManager = __webpack_require__(359); var STATE_LIST = ['inBrush', 'outOfBrush']; var DISPATCH_METHOD = '__ecBrushSelect'; var DISPATCH_FLAG = '__ecInBrushSelectEvent'; var PRIORITY_BRUSH = echarts.PRIORITY.VISUAL.BRUSH; /** * Layout for visual, the priority higher than other layout, and before brush visual. */ echarts.registerLayout(PRIORITY_BRUSH, function (ecModel, api, payload) { ecModel.eachComponent({mainType: 'brush'}, function (brushModel) { payload && payload.type === 'takeGlobalCursor' && brushModel.setBrushOption( payload.key === 'brush' ? payload.brushOption : {brushType: false} ); var brushTargetManager = brushModel.brushTargetManager = new BrushTargetManager(brushModel.option, ecModel); brushTargetManager.setInputRanges(brushModel.areas, ecModel); }); }); /** * Register the visual encoding if this modules required. */ echarts.registerVisual(PRIORITY_BRUSH, function (ecModel, api, payload) { var brushSelected = []; var throttleType; var throttleDelay; ecModel.eachComponent({mainType: 'brush'}, function (brushModel, brushIndex) { var thisBrushSelected = { brushId: brushModel.id, brushIndex: brushIndex, brushName: brushModel.name, areas: zrUtil.clone(brushModel.areas), selected: [] }; // Every brush component exists in event params, convenient // for user to find by index. brushSelected.push(thisBrushSelected); var brushOption = brushModel.option; var brushLink = brushOption.brushLink; var linkedSeriesMap = []; var selectedDataIndexForLink = []; var rangeInfoBySeries = []; var hasBrushExists = 0; if (!brushIndex) { // Only the first throttle setting works. throttleType = brushOption.throttleType; throttleDelay = brushOption.throttleDelay; } // Add boundingRect and selectors to range. var areas = zrUtil.map(brushModel.areas, function (area) { return bindSelector( zrUtil.defaults( {boundingRect: boundingRectBuilders[area.brushType](area)}, area ) ); }); var visualMappings = visualSolution.createVisualMappings( brushModel.option, STATE_LIST, function (mappingOption) { mappingOption.mappingMethod = 'fixed'; } ); zrUtil.isArray(brushLink) && zrUtil.each(brushLink, function (seriesIndex) { linkedSeriesMap[seriesIndex] = 1; }); function linkOthers(seriesIndex) { return brushLink === 'all' || linkedSeriesMap[seriesIndex]; } // If no supported brush or no brush on the series, // all visuals should be in original state. function brushed(rangeInfoList) { return !!rangeInfoList.length; } /** * Logic for each series: (If the logic has to be modified one day, do it carefully!) * * ( brushed ┬ && ┬hasBrushExist ┬ && linkOthers ) => StepA: ┬record, ┬ StepB: ┬visualByRecord. * !brushed┘ ├hasBrushExist ┤ └nothing,┘ ├visualByRecord. * └!hasBrushExist┘ └nothing. * ( !brushed && ┬hasBrushExist ┬ && linkOthers ) => StepA: nothing, StepB: ┬visualByRecord. * └!hasBrushExist┘ └nothing. * ( brushed ┬ && !linkOthers ) => StepA: nothing, StepB: ┬visualByCheck. * !brushed┘ └nothing. * ( !brushed && !linkOthers ) => StepA: nothing, StepB: nothing. */ // Step A ecModel.eachSeries(function (seriesModel, seriesIndex) { var rangeInfoList = rangeInfoBySeries[seriesIndex] = []; seriesModel.subType === 'parallel' ? stepAParallel(seriesModel, seriesIndex, rangeInfoList) : stepAOthers(seriesModel, seriesIndex, rangeInfoList); }); function stepAParallel(seriesModel, seriesIndex) { var coordSys = seriesModel.coordinateSystem; hasBrushExists |= coordSys.hasAxisBrushed(); linkOthers(seriesIndex) && coordSys.eachActiveState( seriesModel.getData(), function (activeState, dataIndex) { activeState === 'active' && (selectedDataIndexForLink[dataIndex] = 1); } ); } function stepAOthers(seriesModel, seriesIndex, rangeInfoList) { var selectorsByBrushType = getSelectorsByBrushType(seriesModel); if (!selectorsByBrushType || brushModelNotControll(brushModel, seriesIndex)) { return; } zrUtil.each(areas, function (area) { selectorsByBrushType[area.brushType] && brushModel.brushTargetManager.controlSeries(area, seriesModel, ecModel) && rangeInfoList.push(area); hasBrushExists |= brushed(rangeInfoList); }); if (linkOthers(seriesIndex) && brushed(rangeInfoList)) { var data = seriesModel.getData(); data.each(function (dataIndex) { if (checkInRange(selectorsByBrushType, rangeInfoList, data, dataIndex)) { selectedDataIndexForLink[dataIndex] = 1; } }); } } // Step B ecModel.eachSeries(function (seriesModel, seriesIndex) { var seriesBrushSelected = { seriesId: seriesModel.id, seriesIndex: seriesIndex, seriesName: seriesModel.name, dataIndex: [] }; // Every series exists in event params, convenient // for user to find series by seriesIndex. thisBrushSelected.selected.push(seriesBrushSelected); var selectorsByBrushType = getSelectorsByBrushType(seriesModel); var rangeInfoList = rangeInfoBySeries[seriesIndex]; var data = seriesModel.getData(); var getValueState = linkOthers(seriesIndex) ? function (dataIndex) { return selectedDataIndexForLink[dataIndex] ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), 'inBrush') : 'outOfBrush'; } : function (dataIndex) { return checkInRange(selectorsByBrushType, rangeInfoList, data, dataIndex) ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), 'inBrush') : 'outOfBrush'; }; // If no supported brush or no brush, all visuals are in original state. (linkOthers(seriesIndex) ? hasBrushExists : brushed(rangeInfoList)) && visualSolution.applyVisual( STATE_LIST, visualMappings, data, getValueState ); }); }); dispatchAction(api, throttleType, throttleDelay, brushSelected, payload); }); function dispatchAction(api, throttleType, throttleDelay, brushSelected, payload) { // This event will not be triggered when `setOpion`, otherwise dead lock may // triggered when do `setOption` in event listener, which we do not find // satisfactory way to solve yet. Some considered resolutions: // (a) Diff with prevoius selected data ant only trigger event when changed. // But store previous data and diff precisely (i.e., not only by dataIndex, but // also detect value changes in selected data) might bring complexity or fragility. // (b) Use spectial param like `silent` to suppress event triggering. // But such kind of volatile param may be weird in `setOption`. if (!payload) { return; } var zr = api.getZr(); if (zr[DISPATCH_FLAG]) { return; } if (!zr[DISPATCH_METHOD]) { zr[DISPATCH_METHOD] = doDispatch; } var fn = throttle.createOrUpdate(zr, DISPATCH_METHOD, throttleDelay, throttleType); fn(api, brushSelected); } function doDispatch(api, brushSelected) { if (!api.isDisposed()) { var zr = api.getZr(); zr[DISPATCH_FLAG] = true; api.dispatchAction({ type: 'brushSelect', batch: brushSelected }); zr[DISPATCH_FLAG] = false; } } function checkInRange(selectorsByBrushType, rangeInfoList, data, dataIndex) { for (var i = 0, len = rangeInfoList.length; i < len; i++) { var area = rangeInfoList[i]; if (selectorsByBrushType[area.brushType]( dataIndex, data, area.selectors, area )) { return true; } } } function getSelectorsByBrushType(seriesModel) { var brushSelector = seriesModel.brushSelector; if (zrUtil.isString(brushSelector)) { var sels = []; zrUtil.each(selector, function (selectorsByElementType, brushType) { sels[brushType] = function (dataIndex, data, selectors, area) { var itemLayout = data.getItemLayout(dataIndex); return selectorsByElementType[brushSelector](itemLayout, selectors, area); }; }); return sels; } else if (zrUtil.isFunction(brushSelector)) { var bSelector = {}; zrUtil.each(selector, function (sel, brushType) { bSelector[brushType] = brushSelector; }); return bSelector; } return brushSelector; } function brushModelNotControll(brushModel, seriesIndex) { var seriesIndices = brushModel.option.seriesIndex; return seriesIndices != null && seriesIndices !== 'all' && ( zrUtil.isArray(seriesIndices) ? zrUtil.indexOf(seriesIndices, seriesIndex) < 0 : seriesIndex !== seriesIndices ); } function bindSelector(area) { var selectors = area.selectors = {}; zrUtil.each(selector[area.brushType], function (selFn, elType) { // Do not use function binding or curry for performance. selectors[elType] = function (itemLayout) { return selFn(itemLayout, selectors, area); }; }); return area; } var boundingRectBuilders = { lineX: zrUtil.noop, lineY: zrUtil.noop, rect: function (area) { return getBoundingRectFromMinMax(area.range); }, polygon: function (area) { var minMax; var range = area.range; for (var i = 0, len = range.length; i < len; i++) { minMax = minMax || [[Infinity, -Infinity], [Infinity, -Infinity]]; var rg = range[i]; rg[0] < minMax[0][0] && (minMax[0][0] = rg[0]); rg[0] > minMax[0][1] && (minMax[0][1] = rg[0]); rg[1] < minMax[1][0] && (minMax[1][0] = rg[1]); rg[1] > minMax[1][1] && (minMax[1][1] = rg[1]); } return minMax && getBoundingRectFromMinMax(minMax); } }; function getBoundingRectFromMinMax(minMax) { return new BoundingRect( minMax[0][0], minMax[1][0], minMax[0][1] - minMax[0][0], minMax[1][1] - minMax[1][0] ); } /***/ }), /* 357 */ /***/ (function(module, exports, __webpack_require__) { /** * @file Visual solution, for consistent option specification. */ var zrUtil = __webpack_require__(4); var VisualMapping = __webpack_require__(206); var each = zrUtil.each; function hasKeys(obj) { if (obj) { for (var name in obj){ if (obj.hasOwnProperty(name)) { return true; } } } } var visualSolution = { /** * @param {Object} option * @param {Array.} stateList * @param {Function} [supplementVisualOption] * @return {Object} visualMappings */ createVisualMappings: function (option, stateList, supplementVisualOption) { var visualMappings = {}; each(stateList, function (state) { var mappings = visualMappings[state] = createMappings(); each(option[state], function (visualData, visualType) { if (!VisualMapping.isValidType(visualType)) { return; } var mappingOption = { type: visualType, visual: visualData }; supplementVisualOption && supplementVisualOption(mappingOption, state); mappings[visualType] = new VisualMapping(mappingOption); // Prepare a alpha for opacity, for some case that opacity // is not supported, such as rendering using gradient color. if (visualType === 'opacity') { mappingOption = zrUtil.clone(mappingOption); mappingOption.type = 'colorAlpha'; mappings.__hidden.__alphaForOpacity = new VisualMapping(mappingOption); } }); }); return visualMappings; function createMappings() { var Creater = function () {}; // Make sure hidden fields will not be visited by // object iteration (with hasOwnProperty checking). Creater.prototype.__hidden = Creater.prototype; var obj = new Creater(); return obj; } }, /** * @param {Object} thisOption * @param {Object} newOption * @param {Array.} keys */ replaceVisualOption: function (thisOption, newOption, keys) { // Visual attributes merge is not supported, otherwise it // brings overcomplicated merge logic. See #2853. So if // newOption has anyone of these keys, all of these keys // will be reset. Otherwise, all keys remain. var has; zrUtil.each(keys, function (key) { if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) { has = true; } }); has && zrUtil.each(keys, function (key) { if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) { thisOption[key] = zrUtil.clone(newOption[key]); } else { delete thisOption[key]; } }); }, /** * @param {Array.} stateList * @param {Object} visualMappings * @param {module:echarts/data/List} list * @param {Function} getValueState param: valueOrIndex, return: state. * @param {object} [scope] Scope for getValueState * @param {string} [dimension] Concrete dimension, if used. */ applyVisual: function (stateList, visualMappings, data, getValueState, scope, dimension) { var visualTypesMap = {}; zrUtil.each(stateList, function (state) { var visualTypes = VisualMapping.prepareVisualTypes(visualMappings[state]); visualTypesMap[state] = visualTypes; }); var dataIndex; function getVisual(key) { return data.getItemVisual(dataIndex, key); } function setVisual(key, value) { data.setItemVisual(dataIndex, key, value); } if (dimension == null) { data.each(eachItem, true); } else { data.each([dimension], eachItem, true); } function eachItem(valueOrIndex, index) { dataIndex = dimension == null ? valueOrIndex : index; var rawDataItem = data.getRawDataItem(dataIndex); // Consider performance if (rawDataItem && rawDataItem.visualMap === false) { return; } var valueState = getValueState.call(scope, valueOrIndex); var mappings = visualMappings[valueState]; var visualTypes = visualTypesMap[valueState]; for (var i = 0, len = visualTypes.length; i < len; i++) { var type = visualTypes[i]; mappings[type] && mappings[type].applyVisual( valueOrIndex, getVisual, setVisual ); } } } }; module.exports = visualSolution; /***/ }), /* 358 */ /***/ (function(module, exports, __webpack_require__) { var polygonContain = __webpack_require__(178).contain; var BoundingRect = __webpack_require__(9); // Key of the first level is brushType: `line`, `rect`, `polygon`. // Key of the second level is chart element type: `point`, `rect`. // See moudule:echarts/component/helper/BrushController // function param: // {Object} itemLayout fetch from data.getItemLayout(dataIndex) // {Object} selectors {point: selector, rect: selector, ...} // {Object} area {range: [[], [], ..], boudingRect} // function return: // {boolean} Whether in the given brush. var selector = { lineX: getLineSelectors(0), lineY: getLineSelectors(1), rect: { point: function (itemLayout, selectors, area) { return area.boundingRect.contain(itemLayout[0], itemLayout[1]); }, rect: function (itemLayout, selectors, area) { return area.boundingRect.intersect(itemLayout); } }, polygon: { point: function (itemLayout, selectors, area) { return area.boundingRect.contain(itemLayout[0], itemLayout[1]) && polygonContain(area.range, itemLayout[0], itemLayout[1]); }, rect: function (itemLayout, selectors, area) { var points = area.range; if (points.length 1) { return false; } return true; } function nearZero(val) { return val = -(1e-6); } function determinant(v1, v2, v3, v4) { return v1 * v4 - v2 * v3; } module.exports = selector; /***/ }), /* 359 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); var graphic = __webpack_require__(20); var modelUtil = __webpack_require__(5); var brushHelper = __webpack_require__(249); var each = zrUtil.each; var indexOf = zrUtil.indexOf; var curry = zrUtil.curry; var COORD_CONVERTS = ['dataToPoint', 'pointToData']; // FIXME // how to genarialize to more coordinate systems. var INCLUDE_FINDER_MAIN_TYPES = [ 'grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap' ]; /** * [option in constructor]: * { * Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder. * } * * * [targetInfo]: * * There can be multiple axes in a single targetInfo. Consider the case * of `grid` component, a targetInfo represents a grid which contains one or more * cartesian and one or more axes. And consider the case of parallel system, * which has multiple axes in a coordinate system. * Can be { * panelId: ..., * coordSys: , * coordSyses: all cartesians. * gridModel: * xAxes: correspond to coordSyses on index * yAxes: correspond to coordSyses on index * } * or { * panelId: ..., * coordSys: * coordSyses: [] * geoModel: * } * * * [panelOpt]: * * Make from targetInfo. Input to BrushController. * { * panelId: ..., * rect: ... * } * * * [area]: * * Generated by BrushController or user input. * { * panelId: Used to locate coordInfo directly. If user inpput, no panelId. * brushType: determine how to convert to/from coord('rect' or 'polygon' or 'lineX/Y'). * Index/Id/Name of geo, xAxis, yAxis, grid: See util/model#parseFinder. * range: pixel range. * coordRange: representitive coord range (the first one of coordRanges). * coordRanges: coord ranges, used in multiple cartesian in one grid. * } */ /** * @param {Object} option contains Index/Id/Name of xAxis/yAxis/geo/grid * Each can be {number|Array.}. like: {xAxisIndex: [3, 4]} * @param {module:echarts/model/Global} ecModel * @param {Object} [opt] * @param {Array.} [opt.include] include coordinate system types. */ function BrushTargetManager(option, ecModel, opt) { /** * @private * @type {Array.} */ var targetInfoList = this._targetInfoList = []; var info = {}; var foundCpts = parseFinder(ecModel, option); each(targetInfoBuilders, function (builder, type) { if (!opt || !opt.include || indexOf(opt.include, type) >= 0) { builder(foundCpts, targetInfoList, info); } }); } var proto = BrushTargetManager.prototype; proto.setOutputRanges = function (areas, ecModel) { this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) { (area.coordRanges || (area.coordRanges = [])).push(coordRange); // area.coordRange is the first of area.coordRanges if (!area.coordRange) { area.coordRange = coordRange; // In 'category' axis, coord to pixel is not reversible, so we can not // rebuild range by coordRange accrately, which may bring trouble when // brushing only one item. So we use __rangeOffset to rebuilding range // by coordRange. And this it only used in brush component so it is no // need to be adapted to coordRanges. var result = coordConvert[area.brushType](0, coordSys, coordRange); area.__rangeOffset = { offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]), xyMinMax: result.xyMinMax }; } }); }; proto.matchOutputRanges = function (areas, ecModel, cb) { each(areas, function (area) { var targetInfo = this.findTargetInfo(area, ecModel); if (targetInfo && targetInfo !== true) { zrUtil.each( targetInfo.coordSyses, function (coordSys) { var result = coordConvert[area.brushType](1, coordSys, area.range); cb(area, result.values, coordSys, ecModel); } ); } }, this); }; proto.setInputRanges = function (areas, ecModel) { each(areas, function (area) { var targetInfo = this.findTargetInfo(area, ecModel); if (true) { zrUtil.assert( !targetInfo || targetInfo === true || area.coordRange, 'coordRange must be specified when coord index specified.' ); zrUtil.assert( !targetInfo || targetInfo !== true || area.range, 'range must be specified in global brush.' ); } area.range = area.range || []; // convert coordRange to global range and set panelId. if (targetInfo && targetInfo !== true) { area.panelId = targetInfo.panelId; // (1) area.range shoule always be calculate from coordRange but does // not keep its original value, for the sake of the dataZoom scenario, // where area.coordRange remains unchanged but area.range may be changed. // (2) Only support converting one coordRange to pixel range in brush // component. So do not consider `coordRanges`. // (3) About __rangeOffset, see comment above. var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange); var rangeOffset = area.__rangeOffset; area.range = rangeOffset ? diffProcessor[area.brushType]( result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax) ) : result.values; } }, this); }; proto.makePanelOpts = function (api, getDefaultBrushType) { return zrUtil.map(this._targetInfoList, function (targetInfo) { var rect = targetInfo.getPanelRect(); return { panelId: targetInfo.panelId, defaultBrushType: getDefaultBrushType && getDefaultBrushType(targetInfo), clipPath: brushHelper.makeRectPanelClipPath(rect), isTargetByCursor: brushHelper.makeRectIsTargetByCursor( rect, api, targetInfo.coordSysModel ), getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect) }; }); }; proto.controlSeries = function (area, seriesModel, ecModel) { // Check whether area is bound in coord, and series do not belong to that coord. // If do not do this check, some brush (like lineX) will controll all axes. var targetInfo = this.findTargetInfo(area, ecModel); return targetInfo === true || ( targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0 ); }; /** * If return Object, a coord found. * If reutrn true, global found. * Otherwise nothing found. * * @param {Object} area * @param {Array} targetInfoList * @return {Object|boolean} */ proto.findTargetInfo = function (area, ecModel) { var targetInfoList = this._targetInfoList; var foundCpts = parseFinder(ecModel, area); for (var i = 0; i < targetInfoList.length; i++) { var targetInfo = targetInfoList[i]; var areaPanelId = area.panelId; if (areaPanelId) { if (targetInfo.panelId === areaPanelId) { return targetInfo; } } else { for (var i = 0; i < targetInfoMatchers.length; i++) { if (targetInfoMatchers[i](foundCpts, targetInfo)) { return targetInfo; } } } } return true; }; function formatMinMax(minMax) { minMax[0] > minMax[1] && minMax.reverse(); return minMax; } function parseFinder(ecModel, option) { return modelUtil.parseFinder( ecModel, option, {includeMainTypes: INCLUDE_FINDER_MAIN_TYPES} ); } var targetInfoBuilders = { grid: function (foundCpts, targetInfoList) { var xAxisModels = foundCpts.xAxisModels; var yAxisModels = foundCpts.yAxisModels; var gridModels = foundCpts.gridModels; // Remove duplicated. var gridModelMap = zrUtil.createHashMap(); var xAxesHas = {}; var yAxesHas = {}; if (!xAxisModels && !yAxisModels && !gridModels) { return; } each(xAxisModels, function (axisModel) { var gridModel = axisModel.axis.grid.model; gridModelMap.set(gridModel.id, gridModel); xAxesHas[gridModel.id] = true; }); each(yAxisModels, function (axisModel) { var gridModel = axisModel.axis.grid.model; gridModelMap.set(gridModel.id, gridModel); yAxesHas[gridModel.id] = true; }); each(gridModels, function (gridModel) { gridModelMap.set(gridModel.id, gridModel); xAxesHas[gridModel.id] = true; yAxesHas[gridModel.id] = true; }); gridModelMap.each(function (gridModel) { var grid = gridModel.coordinateSystem; var cartesians = []; each(grid.getCartesians(), function (cartesian, index) { if (indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0 || indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0 ) { cartesians.push(cartesian); } }); targetInfoList.push({ panelId: 'grid--' + gridModel.id, gridModel: gridModel, coordSysModel: gridModel, // Use the first one as the representitive coordSys. coordSys: cartesians[0], coordSyses: cartesians, getPanelRect: panelRectBuilder.grid, xAxisDeclared: xAxesHas[gridModel.id], yAxisDeclared: yAxesHas[gridModel.id] }); }); }, geo: function (foundCpts, targetInfoList) { each(foundCpts.geoModels, function (geoModel) { var coordSys = geoModel.coordinateSystem; targetInfoList.push({ panelId: 'geo--' + geoModel.id, geoModel: geoModel, coordSysModel: geoModel, coordSys: coordSys, coordSyses: [coordSys], getPanelRect: panelRectBuilder.geo }); }); } }; var targetInfoMatchers = [ // grid function (foundCpts, targetInfo) { var xAxisModel = foundCpts.xAxisModel; var yAxisModel = foundCpts.yAxisModel; var gridModel = foundCpts.gridModel; !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model); !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model); return gridModel && gridModel === targetInfo.gridModel; }, // geo function (foundCpts, targetInfo) { var geoModel = foundCpts.geoModel; return geoModel && geoModel === targetInfo.geoModel; } ]; var panelRectBuilder = { grid: function () { // grid is not Transformable. return this.coordSys.grid.getRect().clone(); }, geo: function () { var coordSys = this.coordSys; var rect = coordSys.getBoundingRect().clone(); // geo roam and zoom transform rect.applyTransform(graphic.getTransform(coordSys)); return rect; } }; var coordConvert = { lineX: curry(axisConvert, 0), lineY: curry(axisConvert, 1), rect: function (to, coordSys, rangeOrCoordRange) { var xminymin = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]]); var xmaxymax = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]]); var values = [ formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]]) ]; return {values: values, xyMinMax: values}; }, polygon: function (to, coordSys, rangeOrCoordRange) { var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]]; var values = zrUtil.map(rangeOrCoordRange, function (item) { var p = coordSys[COORD_CONVERTS[to]](item); xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]); xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]); xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]); xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]); return p; }); return {values: values, xyMinMax: xyMinMax}; } }; function axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) { if (true) { zrUtil.assert( coordSys.type === 'cartesian2d', 'lineX/lineY brush is available only in cartesian2d.' ); } var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]); var values = formatMinMax(zrUtil.map([0, 1], function (i) { return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i])) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i])); })); var xyMinMax = []; xyMinMax[axisNameIndex] = values; xyMinMax[1 - axisNameIndex] = [NaN, NaN]; return {values: values, xyMinMax: xyMinMax}; } var diffProcessor = { lineX: curry(axisDiffProcessor, 0), lineY: curry(axisDiffProcessor, 1), rect: function (values, refer, scales) { return [ [values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]] ]; }, polygon: function (values, refer, scales) { return zrUtil.map(values, function (item, idx) { return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]]; }); } }; function axisDiffProcessor(axisNameIndex, values, refer, scales) { return [ values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1] ]; } // We have to process scale caused by dataZoom manually, // although it might be not accurate. function getScales(xyMinMaxCurr, xyMinMaxOrigin) { var sizeCurr = getSize(xyMinMaxCurr); var sizeOrigin = getSize(xyMinMaxOrigin); var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]]; isNaN(scales[0]) && (scales[0] = 1); isNaN(scales[1]) && (scales[1] = 1); return scales; } function getSize(xyMinMax) { return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN]; } module.exports = BrushTargetManager; /***/ }), /* 360 */ /***/ (function(module, exports, __webpack_require__) { /** * @file Brush model */ var echarts = __webpack_require__(1); var zrUtil = __webpack_require__(4); var visualSolution = __webpack_require__(357); var Model = __webpack_require__(14); var DEFAULT_OUT_OF_BRUSH_COLOR = ['#ddd']; var BrushModel = echarts.extendComponentModel({ type: 'brush', dependencies: ['geo', 'grid', 'xAxis', 'yAxis', 'parallel', 'series'], /** * @protected */ defaultOption: { // inBrush: null, // outOfBrush: null, toolbox: null, // Default value see preprocessor. brushLink: null, // Series indices array, broadcast using dataIndex. // or 'all', which means all series. 'none' or null means no series. seriesIndex: 'all', // seriesIndex array, specify series controlled by this brush component. geoIndex: null, // xAxisIndex: null, yAxisIndex: null, brushType: 'rect', // Default brushType, see BrushController. brushMode: 'single', // Default brushMode, 'single' or 'multiple' transformable: true, // Default transformable. brushStyle: { // Default brushStyle borderWidth: 1, color: 'rgba(120,140,180,0.3)', borderColor: 'rgba(120,140,180,0.8)' }, throttleType: 'fixRate',// Throttle in brushSelected event. 'fixRate' or 'debounce'. // If null, no throttle. Valid only in the first brush component throttleDelay: 0, // Unit: ms, 0 means every event will be triggered. // FIXME // 试验效果 removeOnClick: true, z: 10000 }, /** * @readOnly * @type {Array.} */ areas: [], /** * Current activated brush type. * If null, brush is inactived. * see module:echarts/component/helper/BrushController * @readOnly * @type {string} */ brushType: null, /** * Current brush opt. * see module:echarts/component/helper/BrushController * @readOnly * @type {Object} */ brushOption: {}, /** * @readOnly * @type {Array.} */ coordInfoList: [], optionUpdated: function (newOption, isInit) { var thisOption = this.option; !isInit && visualSolution.replaceVisualOption( thisOption, newOption, ['inBrush', 'outOfBrush'] ); thisOption.inBrush = thisOption.inBrush || {}; // Always give default visual, consider setOption at the second time. thisOption.outOfBrush = thisOption.outOfBrush || {color: DEFAULT_OUT_OF_BRUSH_COLOR}; }, /** * If ranges is null/undefined, range state remain. * * @param {Array.} [ranges] */ setAreas: function (areas) { if (true) { zrUtil.assert(zrUtil.isArray(areas)); zrUtil.each(areas, function (area) { zrUtil.assert(area.brushType, 'Illegal areas'); }); } // If ranges is null/undefined, range state remain. // This helps user to dispatchAction({type: 'brush'}) with no areas // set but just want to get the current brush select info from a `brush` event. if (!areas) { return; } this.areas = zrUtil.map(areas, function (area) { return generateBrushOption(this.option, area); }, this); }, /** * see module:echarts/component/helper/BrushController * @param {Object} brushOption */ setBrushOption: function (brushOption) { this.brushOption = generateBrushOption(this.option, brushOption); this.brushType = this.brushOption.brushType; } }); function generateBrushOption(option, brushOption) { return zrUtil.merge( { brushType: option.brushType, brushMode: option.brushMode, transformable: option.transformable, brushStyle: new Model(option.brushStyle).getItemStyle(), removeOnClick: option.removeOnClick, z: option.z }, brushOption, true ); } module.exports = BrushModel; /***/ }), /* 361 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); var BrushController = __webpack_require__(248); var echarts = __webpack_require__(1); module.exports = echarts.extendComponentView({ type: 'brush', init: function (ecModel, api) { /** * @readOnly * @type {module:echarts/model/Global} */ this.ecModel = ecModel; /** * @readOnly * @type {module:echarts/ExtensionAPI} */ this.api = api; /** * @readOnly * @type {module:echarts/component/brush/BrushModel} */ this.model; /** * @private * @type {module:echarts/component/helper/BrushController} */ (this._brushController = new BrushController(api.getZr())) .on('brush', zrUtil.bind(this._onBrush, this)) .mount(); }, /** * @override */ render: function (brushModel) { this.model = brushModel; return updateController.apply(this, arguments); }, /** * @override */ updateView: updateController, /** * @override */ updateLayout: updateController, /** * @override */ updateVisual: updateController, /** * @override */ dispose: function () { this._brushController.dispose(); }, /** * @private */ _onBrush: function (areas, opt) { var modelId = this.model.id; this.model.brushTargetManager.setOutputRanges(areas, this.ecModel); // Action is not dispatched on drag end, because the drag end // emits the same params with the last drag move event, and // may have some delay when using touch pad, which makes // animation not smooth (when using debounce). (!opt.isEnd || opt.removeOnClick) && this.api.dispatchAction({ type: 'brush', brushId: modelId, areas: zrUtil.clone(areas), $from: modelId }); } }); function updateController(brushModel, ecModel, api, payload) { // Do not update controller when drawing. (!payload || payload.$from !== brushModel.id) && this._brushController .setPanels(brushModel.brushTargetManager.makePanelOpts(api)) .enableBrush(brushModel.brushOption) .updateCovers(brushModel.areas.slice()); } /***/ }), /* 362 */ /***/ (function(module, exports, __webpack_require__) { /** * @file Brush action */ var echarts = __webpack_require__(1); /** * payload: { * brushIndex: number, or, * brushId: string, or, * brushName: string, * globalRanges: Array * } */ echarts.registerAction( {type: 'brush', event: 'brush', update: 'updateView'}, function (payload, ecModel) { ecModel.eachComponent({mainType: 'brush', query: payload}, function (brushModel) { brushModel.setAreas(payload.areas); }); } ); /** * payload: { * brushComponents: [ * { * brushId, * brushIndex, * brushName, * series: [ * { * seriesId, * seriesIndex, * seriesName, * rawIndices: [21, 34, ...] * }, * ... * ] * }, * ... * ] * } */ echarts.registerAction( {type: 'brushSelect', event: 'brushSelected', update: 'none'}, function () {} ); /***/ }), /* 363 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var featureManager = __webpack_require__(364); var zrUtil = __webpack_require__(4); var lang = __webpack_require__(365).toolbox.brush; function Brush(model, ecModel, api) { this.model = model; this.ecModel = ecModel; this.api = api; /** * @private * @type {string} */ this._brushType; /** * @private * @type {string} */ this._brushMode; } Brush.defaultOption = { show: true, type: ['rect', 'polygon', 'lineX', 'lineY', 'keep', 'clear'], icon: { rect: 'M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13', // jshint ignore:line polygon: 'M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2', // jshint ignore:line lineX: 'M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4', // jshint ignore:line lineY: 'M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4', // jshint ignore:line keep: 'M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z', // jshint ignore:line clear: 'M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2' // jshint ignore:line }, // `rect`, `polygon`, `lineX`, `lineY`, `keep`, `clear` title: zrUtil.clone(lang.title) }; var proto = Brush.prototype; proto.render = proto.updateView = proto.updateLayout = function (featureModel, ecModel, api) { var brushType; var brushMode; var isBrushed; ecModel.eachComponent({mainType: 'brush'}, function (brushModel) { brushType = brushModel.brushType; brushMode = brushModel.brushOption.brushMode || 'single'; isBrushed |= brushModel.areas.length; }); this._brushType = brushType; this._brushMode = brushMode; zrUtil.each(featureModel.get('type', true), function (type) { featureModel.setIconStatus( type, ( type === 'keep' ? brushMode === 'multiple' : type === 'clear' ? isBrushed : type === brushType ) ? 'emphasis' : 'normal' ); }); }; proto.getIcons = function () { var model = this.model; var availableIcons = model.get('icon', true); var icons = {}; zrUtil.each(model.get('type', true), function (type) { if (availableIcons[type]) { icons[type] = availableIcons[type]; } }); return icons; }; proto.onclick = function (ecModel, api, type) { var api = this.api; var brushType = this._brushType; var brushMode = this._brushMode; if (type === 'clear') { // Trigger parallel action firstly api.dispatchAction({ type: 'axisAreaSelect', intervals: [] }); api.dispatchAction({ type: 'brush', command: 'clear', // Clear all areas of all brush components. areas: [] }); } else { api.dispatchAction({ type: 'takeGlobalCursor', key: 'brush', brushOption: { brushType: type === 'keep' ? brushType : (brushType === type ? false : type), brushMode: type === 'keep' ? (brushMode === 'multiple' ? 'single' : 'multiple') : brushMode } }); } }; featureManager.register('brush', Brush); module.exports = Brush; /***/ }), /* 364 */ /***/ (function(module, exports) { 'use strict'; var features = {}; module.exports = { register: function (name, ctor) { features[name] = ctor; }, get: function (name) { return features[name]; } }; /***/ }), /* 365 */ /***/ (function(module, exports) { module.exports = { toolbox: { brush: { title: { rect: '矩形选择', polygon: '圈选', lineX: '横向选择', lineY: '纵向选择', keep: '保持选择', clear: '清除选择' } }, dataView: { title: '数据视图', lang: ['数据视图', '关闭', '刷新'] }, dataZoom: { title: { zoom: '区域缩放', back: '区域缩放还原' } }, magicType: { title: { line: '切换为折线图', bar: '切换为柱状图', stack: '切换为堆叠', tiled: '切换为平铺' } }, restore: { title: '还原' }, saveAsImage: { title: '保存为图片', lang: ['右键另存为图片'] } } }; /***/ }), /* 366 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; /** * @file calendar.js * @author dxh */ __webpack_require__(367); __webpack_require__(368); __webpack_require__(369); /***/ }), /* 367 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var layout = __webpack_require__(74); var numberUtil = __webpack_require__(7); var zrUtil = __webpack_require__(4); // (24*60*60*1000) var PROXIMATE_ONE_DAY = 86400000; /** * Calendar * * @constructor * * @param {Object} calendarModel calendarModel * @param {Object} ecModel ecModel * @param {Object} api api */ function Calendar(calendarModel, ecModel, api) { this._model = calendarModel; } Calendar.prototype = { constructor: Calendar, type: 'calendar', dimensions: ['time', 'value'], // Required in createListFromData getDimensionsInfo: function () { return [{name: 'time', type: 'time'}]; }, getRangeInfo: function () { return this._rangeInfo; }, getModel: function () { return this._model; }, getRect: function () { return this._rect; }, getCellWidth: function () { return this._sw; }, getCellHeight: function () { return this._sh; }, getOrient: function () { return this._orient; }, /** * getFirstDayOfWeek * * @example * 0 : start at Sunday * 1 : start at Monday * * @return {number} */ getFirstDayOfWeek: function () { return this._firstDayOfWeek; }, /** * get date info * * @param {string|number} date date * @return {Object} * { * y: string, local full year, eg., '1940', * m: string, local month, from '01' ot '12', * d: string, local date, from '01' to '31' (if exists), * day: It is not date.getDay(). It is the location of the cell in a week, from 0 to 6, * time: timestamp, * formatedDate: string, yyyy-MM-dd, * date: original date object. * } */ getDateInfo: function (date) { date = numberUtil.parseDate(date); var y = date.getFullYear(); var m = date.getMonth() + 1; m = m < 10 ? '0' + m : m; var d = date.getDate(); d = d < 10 ? '0' + d : d; var day = date.getDay(); day = Math.abs((day + 7 - this.getFirstDayOfWeek()) % 7); return { y: y, m: m, d: d, day: day, time: date.getTime(), formatedDate: y + '-' + m + '-' + d, date: date }; }, getNextNDay: function (date, n) { n = n || 0; if (n === 0) { return this.getDateInfo(date); } date = new Date(this.getDateInfo(date).time); date.setDate(date.getDate() + n); return this.getDateInfo(date); }, update: function (ecModel, api) { this._firstDayOfWeek = this._model.getModel('dayLabel').get('firstDay'); this._orient = this._model.get('orient'); this._lineWidth = this._model.getModel('itemStyle.normal').getItemStyle().lineWidth || 0; this._rangeInfo = this._getRangeInfo(this._initRangeOption()); var weeks = this._rangeInfo.weeks || 1; var whNames = ['width', 'height']; var cellSize = this._model.get('cellSize').slice(); var layoutParams = this._model.getBoxLayoutParams(); var cellNumbers = this._orient === 'horizontal' ? [weeks, 7] : [7, weeks]; zrUtil.each([0, 1], function (idx) { if (cellSizeSpecified(cellSize, idx)) { layoutParams[whNames[idx]] = cellSize[idx] * cellNumbers[idx]; } }); var whGlobal = { width: api.getWidth(), height: api.getHeight() }; var calendarRect = this._rect = layout.getLayoutRect(layoutParams, whGlobal); zrUtil.each([0, 1], function (idx) { if (!cellSizeSpecified(cellSize, idx)) { cellSize[idx] = calendarRect[whNames[idx]] / cellNumbers[idx]; } }); function cellSizeSpecified(cellSize, idx) { return cellSize[idx] != null && cellSize[idx] !== 'auto'; } this._sw = cellSize[0]; this._sh = cellSize[1]; }, /** * Convert a time data(time, value) item to (x, y) point. * * @override * @param {Array|number} data data * @param {boolean} [clamp=true] out of range * @return {Array} point */ dataToPoint: function (data, clamp) { zrUtil.isArray(data) && (data = data[0]); clamp == null && (clamp = true); var dayInfo = this.getDateInfo(data); var range = this._rangeInfo; var date = dayInfo.formatedDate; // if not in range return [NaN, NaN] if (clamp && !(dayInfo.time >= range.start.time && dayInfo.time tmp.end.time) { range.reverse(); } return range; }, /** * range info * * @private * @param {Array} range range ['2017-01-01', '2017-07-08'] * If range[0] > range[1], they will not be reversed. * @return {Object} obj */ _getRangeInfo: function (range) { range = [ this.getDateInfo(range[0]), this.getDateInfo(range[1]) ]; var reversed; if (range[0].time > range[1].time) { reversed = true; range.reverse(); } var allDay = Math.floor(range[1].time / PROXIMATE_ONE_DAY) - Math.floor(range[0].time / PROXIMATE_ONE_DAY) + 1; // Consider case: // Firstly set system timezone as \"Time Zone: America/Toronto\", // 1234// var first = new Date(1478412000000 - 3600 * 1000 * 2.5);// var second = new Date(1478412000000);// var allDays = Math.floor(second / ONE_DAY) - Math.floor(first / ONE_DAY) + 1;// // will get wrong result because of DST. So we should fix it. var date = new Date(range[0].time); var startDateNum = date.getDate(); var endDateNum = range[1].date.getDate(); date.setDate(startDateNum + allDay - 1); // The bias can not over a month, so just compare date. if (date.getDate() !== endDateNum) { var sign = date.getTime() - range[1].time > 0 ? 1 : -1; while (date.getDate() !== endDateNum && (date.getTime() - range[1].time) * sign > 0) { allDay -= sign; date.setDate(startDateNum + allDay - 1); } } var weeks = Math.floor((allDay + range[0].day + 6) / 7); var nthWeek = reversed ? -weeks + 1: weeks - 1; reversed && range.reverse(); return { range: [range[0].formatedDate, range[1].formatedDate], start: range[0], end: range[1], allDay: allDay, weeks: weeks, // From 0. nthWeek: nthWeek, fweek: range[0].day, lweek: range[1].day }; }, /** * get date by nthWeeks and week day in range * * @private * @param {number} nthWeek the week * @param {number} day the week day * @param {Array} range [d1, d2] * @return {Object} */ _getDateByWeeksAndDay: function (nthWeek, day, range) { var rangeInfo = this._getRangeInfo(range); if (nthWeek > rangeInfo.weeks || (nthWeek === 0 && day < rangeInfo.fweek) || (nthWeek === rangeInfo.weeks && day > rangeInfo.lweek) ) { return false; } var nthDay = (nthWeek - 1) * 7 - rangeInfo.fweek + day; var date = new Date(rangeInfo.start.time); date.setDate(rangeInfo.start.d + nthDay); return this.getDateInfo(date); } }; Calendar.dimensions = Calendar.prototype.dimensions; Calendar.getDimensionsInfo = Calendar.prototype.getDimensionsInfo; Calendar.create = function (ecModel, api) { var calendarList = []; ecModel.eachComponent('calendar', function (calendarModel) { var calendar = new Calendar(calendarModel, ecModel, api); calendarList.push(calendar); calendarModel.coordinateSystem = calendar; }); ecModel.eachSeries(function (calendarSeries) { if (calendarSeries.get('coordinateSystem') === 'calendar') { // Inject coordinate system calendarSeries.coordinateSystem = calendarList[calendarSeries.get('calendarIndex') || 0]; } }); return calendarList; }; function doConvert(methodName, ecModel, finder, value) { var calendarModel = finder.calendarModel; var seriesModel = finder.seriesModel; var coordSys = calendarModel ? calendarModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem : null; return coordSys === this ? coordSys[methodName](value) : null; } __webpack_require__(79).register('calendar', Calendar); module.exports = Calendar; /***/ }), /* 368 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var ComponentModel = __webpack_require__(72); var zrUtil = __webpack_require__(4); var layout = __webpack_require__(74); var CalendarModel = ComponentModel.extend({ type: 'calendar', /** * @type {module:echarts/coord/calendar/Calendar} */ coordinateSystem: null, defaultOption: { zlevel: 0, z: 2, left: 80, top: 60, cellSize: 20, // horizontal vertical orient: 'horizontal', // month separate line style splitLine: { show: true, lineStyle: { color: '#000', width: 1, type: 'solid' } }, // rect style temporarily unused emphasis itemStyle: { normal: { color: '#fff', borderWidth: 1, borderColor: '#ccc' } }, // week text style dayLabel: { show: true, // a week first day firstDay: 0, // start end position: 'start', margin: '50%', // 50% of cellSize nameMap: 'en', color: '#000' }, // month text style monthLabel: { show: true, // start end position: 'start', margin: 5, // center or left align: 'center', // cn en [] nameMap: 'en', formatter: null, color: '#000' }, // year text style yearLabel: { show: true, // top bottom left right position: null, margin: 30, formatter: null, color: '#ccc', fontFamily: 'sans-serif', fontWeight: 'bolder', fontSize: 20 } }, /** * @override */ init: function (option, parentModel, ecModel, extraOpt) { var inputPositionParams = layout.getLayoutParams(option); CalendarModel.superApply(this, 'init', arguments); mergeAndNormalizeLayoutParams(option, inputPositionParams); }, /** * @override */ mergeOption: function (option, extraOpt) { CalendarModel.superApply(this, 'mergeOption', arguments); mergeAndNormalizeLayoutParams(this.option, option); } }); function mergeAndNormalizeLayoutParams(target, raw) { // Normalize cellSize var cellSize = target.cellSize; if (!zrUtil.isArray(cellSize)) { cellSize = target.cellSize = [cellSize, cellSize]; } else if (cellSize.length === 1) { cellSize[1] = cellSize[0]; } var ignoreSize = zrUtil.map([0, 1], function (hvIdx) { // If user have set `width` or both `left` and `right`, cellSize // will be automatically set to 'auto', otherwise the default // setting of cellSize will make `width` setting not work. if (layout.sizeCalculable(raw, hvIdx)) { cellSize[hvIdx] = 'auto'; } return cellSize[hvIdx] != null && cellSize[hvIdx] !== 'auto'; }); layout.mergeLayoutParam(target, raw, { type: 'box', ignoreSize: ignoreSize }); } module.exports = CalendarModel; /***/ }), /* 369 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var zrUtil = __webpack_require__(4); var graphic = __webpack_require__(20); var formatUtil = __webpack_require__(6); var numberUtil = __webpack_require__(7); var MONTH_TEXT = { EN: [ 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec' ], CN: [ '一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月' ] }; var WEEK_TEXT = { EN: ['S', 'M', 'T', 'W', 'T', 'F', 'S'], CN: ['日', '一', '二', '三', '四', '五', '六'] }; module.exports = __webpack_require__(1).extendComponentView({ type: 'calendar', /** * top/left line points * @private */ _tlpoints: null, /** * bottom/right line points * @private */ _blpoints: null, /** * first day of month * @private */ _firstDayOfMonth: null, /** * first day point of month * @private */ _firstDayPoints: null, render: function (calendarModel, ecModel, api) { var group = this.group; group.removeAll(); var coordSys = calendarModel.coordinateSystem; // range info var rangeData = coordSys.getRangeInfo(); var orient = coordSys.getOrient(); this._renderDayRect(calendarModel, rangeData, group); // _renderLines must be called prior to following function this._renderLines(calendarModel, rangeData, orient, group); this._renderYearText(calendarModel, rangeData, orient, group); this._renderMonthText(calendarModel, orient, group); this._renderWeekText(calendarModel, rangeData, orient, group); }, // render day rect _renderDayRect: function (calendarModel, rangeData, group) { var coordSys = calendarModel.coordinateSystem; var itemRectStyleModel = calendarModel.getModel('itemStyle.normal').getItemStyle(); var sw = coordSys.getCellWidth(); var sh = coordSys.getCellHeight(); for (var i = rangeData.start.time; i 0, // default value is 100, otherwise 20. start: 0, // Start percent. 0 ~ 100 end: 100, // End percent. 0 ~ 100 startValue: null, // Start value. If startValue specified, start is ignored. endValue: null, // End value. If endValue specified, end is ignored. minSpan: null, // 0 ~ 100 maxSpan: null, // 0 ~ 100 minValueSpan: null, // The range of dataZoom can not be smaller than that. maxValueSpan: null, // The range of dataZoom can not be larger than that. rangeMode: null // Array, can be 'value' or 'percent'. }, /** * @override */ init: function (option, parentModel, ecModel) { /** * key like x_0, y_1 * @private * @type {Object} */ this._dataIntervalByAxis = {}; /** * @private */ this._dataInfo = {}; /** * key like x_0, y_1 * @private */ this._axisProxies = {}; /** * @readOnly */ this.textStyleModel; /** * @private */ this._autoThrottle = true; /** * 'percent' or 'value' * @private */ this._rangePropMode = ['percent', 'percent']; var rawOption = retrieveRaw(option); this.mergeDefaultAndTheme(option, ecModel); this.doInit(rawOption); }, /** * @override */ mergeOption: function (newOption) { var rawOption = retrieveRaw(newOption); //FIX #2591 zrUtil.merge(this.option, newOption, true); this.doInit(rawOption); }, /** * @protected */ doInit: function (rawOption) { var thisOption = this.option; // Disable realtime view update if canvas is not supported. if (!env.canvasSupported) { thisOption.realtime = false; } this._setDefaultThrottle(rawOption); updateRangeUse(this, rawOption); each([['start', 'startValue'], ['end', 'endValue']], function (names, index) { // start/end has higher priority over startValue/endValue if they // both set, but we should make chart.setOption({endValue: 1000}) // effective, rather than chart.setOption({endValue: 1000, end: null}). if (this._rangePropMode[index] === 'value') { thisOption[names[0]] = null; } // Otherwise do nothing and use the merge result. }, this); this.textStyleModel = this.getModel('textStyle'); this._resetTarget(); this._giveAxisProxies(); }, /** * @private */ _giveAxisProxies: function () { var axisProxies = this._axisProxies; this.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel, ecModel) { var axisModel = this.dependentModels[dimNames.axis][axisIndex]; // If exists, share axisProxy with other dataZoomModels. var axisProxy = axisModel.__dzAxisProxy || ( // Use the first dataZoomModel as the main model of axisProxy. axisModel.__dzAxisProxy = new AxisProxy( dimNames.name, axisIndex, this, ecModel ) ); // FIXME // dispose __dzAxisProxy axisProxies[dimNames.name + '_' + axisIndex] = axisProxy; }, this); }, /** * @private */ _resetTarget: function () { var thisOption = this.option; var autoMode = this._judgeAutoMode(); eachAxisDim(function (dimNames) { var axisIndexName = dimNames.axisIndex; thisOption[axisIndexName] = modelUtil.normalizeToArray( thisOption[axisIndexName] ); }, this); if (autoMode === 'axisIndex') { this._autoSetAxisIndex(); } else if (autoMode === 'orient') { this._autoSetOrient(); } }, /** * @private */ _judgeAutoMode: function () { // Auto set only works for setOption at the first time. // The following is user's reponsibility. So using merged // option is OK. var thisOption = this.option; var hasIndexSpecified = false; eachAxisDim(function (dimNames) { // When user set axisIndex as a empty array, we think that user specify axisIndex // but do not want use auto mode. Because empty array may be encountered when // some error occured. if (thisOption[dimNames.axisIndex] != null) { hasIndexSpecified = true; } }, this); var orient = thisOption.orient; if (orient == null && hasIndexSpecified) { return 'orient'; } else if (!hasIndexSpecified) { if (orient == null) { thisOption.orient = 'horizontal'; } return 'axisIndex'; } }, /** * @private */ _autoSetAxisIndex: function () { var autoAxisIndex = true; var orient = this.get('orient', true); var thisOption = this.option; var dependentModels = this.dependentModels; if (autoAxisIndex) { // Find axis that parallel to dataZoom as default. var dimName = orient === 'vertical' ? 'y' : 'x'; if (dependentModels[dimName + 'Axis'].length) { thisOption[dimName + 'AxisIndex'] = [0]; autoAxisIndex = false; } else { each(dependentModels.singleAxis, function (singleAxisModel) { if (autoAxisIndex && singleAxisModel.get('orient', true) === orient) { thisOption.singleAxisIndex = [singleAxisModel.componentIndex]; autoAxisIndex = false; } }); } } if (autoAxisIndex) { // Find the first category axis as default. (consider polar) eachAxisDim(function (dimNames) { if (!autoAxisIndex) { return; } var axisIndices = []; var axisModels = this.dependentModels[dimNames.axis]; if (axisModels.length && !axisIndices.length) { for (var i = 0, len = axisModels.length; i < len; i++) { if (axisModels[i].get('type') === 'category') { axisIndices.push(i); } } } thisOption[dimNames.axisIndex] = axisIndices; if (axisIndices.length) { autoAxisIndex = false; } }, this); } if (autoAxisIndex) { // FIXME // 这里是兼容ec2的写法（没指定xAxisIndex和yAxisIndex时把scatter和双数值轴折柱纳入dataZoom控制）， // 但是实际是否需要Grid.js#getScaleByOption来判断（考虑time，log等axis type）？ // If both dataZoom.xAxisIndex and dataZoom.yAxisIndex is not specified, // dataZoom component auto adopts series that reference to // both xAxis and yAxis which type is 'value'. this.ecModel.eachSeries(function (seriesModel) { if (this._isSeriesHasAllAxesTypeOf(seriesModel, 'value')) { eachAxisDim(function (dimNames) { var axisIndices = thisOption[dimNames.axisIndex]; var axisIndex = seriesModel.get(dimNames.axisIndex); var axisId = seriesModel.get(dimNames.axisId); var axisModel = seriesModel.ecModel.queryComponents({ mainType: dimNames.axis, index: axisIndex, id: axisId })[0]; if (true) { if (!axisModel) { throw new Error( dimNames.axis + ' \"' + zrUtil.retrieve( axisIndex, axisId, 0 ) + '\" not found' ); } } axisIndex = axisModel.componentIndex; if (zrUtil.indexOf(axisIndices, axisIndex) < 0) { axisIndices.push(axisIndex); } }); } }, this); } }, /** * @private */ _autoSetOrient: function () { var dim; // Find the first axis this.eachTargetAxis(function (dimNames) { !dim && (dim = dimNames.name); }, this); this.option.orient = dim === 'y' ? 'vertical' : 'horizontal'; }, /** * @private */ _isSeriesHasAllAxesTypeOf: function (seriesModel, axisType) { // FIXME // 需要series的xAxisIndex和yAxisIndex都首先自动设置上。 // 例如series.type === scatter时。 var is = true; eachAxisDim(function (dimNames) { var seriesAxisIndex = seriesModel.get(dimNames.axisIndex); var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex]; if (!axisModel || axisModel.get('type') !== axisType) { is = false; } }, this); return is; }, /** * @private */ _setDefaultThrottle: function (rawOption) { // When first time user set throttle, auto throttle ends. if (rawOption.hasOwnProperty('throttle')) { this._autoThrottle = false; } if (this._autoThrottle) { var globalOption = this.ecModel.option; this.option.throttle = (globalOption.animation && globalOption.animationDurationUpdate > 0) ? 100 : 20; } }, /** * @public */ getFirstTargetAxisModel: function () { var firstAxisModel; eachAxisDim(function (dimNames) { if (firstAxisModel == null) { var indices = this.get(dimNames.axisIndex); if (indices.length) { firstAxisModel = this.dependentModels[dimNames.axis][indices[0]]; } } }, this); return firstAxisModel; }, /** * @public * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel */ eachTargetAxis: function (callback, context) { var ecModel = this.ecModel; eachAxisDim(function (dimNames) { each( this.get(dimNames.axisIndex), function (axisIndex) { callback.call(context, dimNames, axisIndex, this, ecModel); }, this ); }, this); }, /** * @param {string} dimName * @param {number} axisIndex * @return {module:echarts/component/dataZoom/AxisProxy} If not found, return null/undefined. */ getAxisProxy: function (dimName, axisIndex) { return this._axisProxies[dimName + '_' + axisIndex]; }, /** * @param {string} dimName * @param {number} axisIndex * @return {module:echarts/model/Model} If not found, return null/undefined. */ getAxisModel: function (dimName, axisIndex) { var axisProxy = this.getAxisProxy(dimName, axisIndex); return axisProxy && axisProxy.getAxisModel(); }, /** * If not specified, set to undefined. * * @public * @param {Object} opt * @param {number} [opt.start] * @param {number} [opt.end] * @param {number} [opt.startValue] * @param {number} [opt.endValue] * @param {boolean} [ignoreUpdateRangeUsg=false] */ setRawRange: function (opt, ignoreUpdateRangeUsg) { each(['start', 'end', 'startValue', 'endValue'], function (name) { // If any of those prop is null/undefined, we should alos set // them, because only one pair between start/end and // startValue/endValue can work. this.option[name] = opt[name]; }, this); !ignoreUpdateRangeUsg && updateRangeUse(this, opt); }, /** * @public * @return {Array.} [startPercent, endPercent] */ getPercentRange: function () { var axisProxy = this.findRepresentativeAxisProxy(); if (axisProxy) { return axisProxy.getDataPercentWindow(); } }, /** * @public * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0); * * @param {string} [axisDimName] * @param {number} [axisIndex] * @return {Array.} [startValue, endValue] value can only be '-' or finite number. */ getValueRange: function (axisDimName, axisIndex) { if (axisDimName == null && axisIndex == null) { var axisProxy = this.findRepresentativeAxisProxy(); if (axisProxy) { return axisProxy.getDataValueWindow(); } } else { return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow(); } }, /** * @public * @param {module:echarts/model/Model} [axisModel] If axisModel given, find axisProxy * corresponding to the axisModel * @return {module:echarts/component/dataZoom/AxisProxy} */ findRepresentativeAxisProxy: function (axisModel) { if (axisModel) { return axisModel.__dzAxisProxy; } // Find the first hosted axisProxy var axisProxies = this._axisProxies; for (var key in axisProxies) { if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) { return axisProxies[key]; } } // If no hosted axis find not hosted axisProxy. // Consider this case: dataZoomModel1 and dataZoomModel2 control the same axis, // and the option.start or option.end settings are different. The percentRange // should follow axisProxy. // (We encounter this problem in toolbox data zoom.) for (var key in axisProxies) { if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) { return axisProxies[key]; } } }, /** * @return {Array.} */ getRangePropMode: function () { return this._rangePropMode.slice(); } }); function retrieveRaw(option) { var ret = {}; each( ['start', 'end', 'startValue', 'endValue', 'throttle'], function (name) { option.hasOwnProperty(name) && (ret[name] = option[name]); } ); return ret; } function updateRangeUse(dataZoomModel, rawOption) { var rangePropMode = dataZoomModel._rangePropMode; var rangeModeInOption = dataZoomModel.get('rangeMode'); each([['start', 'startValue'], ['end', 'endValue']], function (names, index) { var percentSpecified = rawOption[names[0]] != null; var valueSpecified = rawOption[names[1]] != null; if (percentSpecified && !valueSpecified) { rangePropMode[index] = 'percent'; } else if (!percentSpecified && valueSpecified) { rangePropMode[index] = 'value'; } else if (rangeModeInOption) { rangePropMode[index] = rangeModeInOption[index]; } else if (percentSpecified) { // percentSpecified && valueSpecified rangePropMode[index] = 'percent'; } // else remain its original setting. }); } module.exports = DataZoomModel; /***/ }), /* 374 */ /***/ (function(module, exports, __webpack_require__) { var formatUtil = __webpack_require__(6); var zrUtil = __webpack_require__(4); var helper = {}; var AXIS_DIMS = ['x', 'y', 'z', 'radius', 'angle', 'single']; // Supported coords. var COORDS = ['cartesian2d', 'polar', 'singleAxis']; /** * @param {string} coordType * @return {boolean} */ helper.isCoordSupported = function (coordType) { return zrUtil.indexOf(COORDS, coordType) >= 0; }; /** * Create \"each\" method to iterate names. * * @pubilc * @param {Array.} names * @param {Array.=} attrs * @return {Function} */ helper.createNameEach = function (names, attrs) { names = names.slice(); var capitalNames = zrUtil.map(names, formatUtil.capitalFirst); attrs = (attrs || []).slice(); var capitalAttrs = zrUtil.map(attrs, formatUtil.capitalFirst); return function (callback, context) { zrUtil.each(names, function (name, index) { var nameObj = {name: name, capital: capitalNames[index]}; for (var j = 0; j < attrs.length; j++) { nameObj[attrs[j]] = name + capitalAttrs[j]; } callback.call(context, nameObj); }); }; }; /** * Iterate each dimension name. * * @public * @param {Function} callback The parameter is like: * { * name: 'angle', * capital: 'Angle', * axis: 'angleAxis', * axisIndex: 'angleAixs', * index: 'angleIndex' * } * @param {Object} context */ helper.eachAxisDim = helper.createNameEach(AXIS_DIMS, ['axisIndex', 'axis', 'index', 'id']); /** * If tow dataZoomModels has the same axis controlled, we say that they are 'linked'. * dataZoomModels and 'links' make up one or more graphics. * This function finds the graphic where the source dataZoomModel is in. * * @public * @param {Function} forEachNode Node iterator. * @param {Function} forEachEdgeType edgeType iterator * @param {Function} edgeIdGetter Giving node and edgeType, return an array of edge id. * @return {Function} Input: sourceNode, Output: Like {nodes: [], dims: {}} */ helper.createLinkedNodesFinder = function (forEachNode, forEachEdgeType, edgeIdGetter) { return function (sourceNode) { var result = { nodes: [], records: {} // key: edgeType.name, value: Object (key: edge id, value: boolean). }; forEachEdgeType(function (edgeType) { result.records[edgeType.name] = {}; }); if (!sourceNode) { return result; } absorb(sourceNode, result); var existsLink; do { existsLink = false; forEachNode(processSingleNode); } while (existsLink); function processSingleNode(node) { if (!isNodeAbsorded(node, result) && isLinked(node, result)) { absorb(node, result); existsLink = true; } } return result; }; function isNodeAbsorded(node, result) { return zrUtil.indexOf(result.nodes, node) >= 0; } function isLinked(node, result) { var hasLink = false; forEachEdgeType(function (edgeType) { zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) { result.records[edgeType.name][edgeId] && (hasLink = true); }); }); return hasLink; } function absorb(node, result) { result.nodes.push(node); forEachEdgeType(function (edgeType) { zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) { result.records[edgeType.name][edgeId] = true; }); }); } }; module.exports = helper; /***/ }), /* 375 */ /***/ (function(module, exports, __webpack_require__) { /** * @file Axis operator */ var zrUtil = __webpack_require__(4); var numberUtil = __webpack_require__(7); var helper = __webpack_require__(374); var each = zrUtil.each; var asc = numberUtil.asc; /** * Operate single axis. * One axis can only operated by one axis operator. * Different dataZoomModels may be defined to operate the same axis. * (i.e. 'inside' data zoom and 'slider' data zoom components) * So dataZoomModels share one axisProxy in that case. * * @class */ var AxisProxy = function (dimName, axisIndex, dataZoomModel, ecModel) { /** * @private * @type {string} */ this._dimName = dimName; /** * @private */ this._axisIndex = axisIndex; /** * @private * @type {Array.} */ this._valueWindow; /** * @private * @type {Array.} */ this._percentWindow; /** * @private * @type {Array.} */ this._dataExtent; /** * {minSpan, maxSpan, minValueSpan, maxValueSpan} * @private * @type {Object} */ this._minMaxSpan; /** * @readOnly * @type {module: echarts/model/Global} */ this.ecModel = ecModel; /** * @private * @type {module: echarts/component/dataZoom/DataZoomModel} */ this._dataZoomModel = dataZoomModel; }; AxisProxy.prototype = { constructor: AxisProxy, /** * Whether the axisProxy is hosted by dataZoomModel. * * @public * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel * @return {boolean} */ hostedBy: function (dataZoomModel) { return this._dataZoomModel === dataZoomModel; }, /** * @return {Array.} Value can only be NaN or finite value. */ getDataValueWindow: function () { return this._valueWindow.slice(); }, /** * @return {Array.} */ getDataPercentWindow: function () { return this._percentWindow.slice(); }, /** * @public * @param {number} axisIndex * @return {Array} seriesModels */ getTargetSeriesModels: function () { var seriesModels = []; var ecModel = this.ecModel; ecModel.eachSeries(function (seriesModel) { if (helper.isCoordSupported(seriesModel.get('coordinateSystem'))) { var dimName = this._dimName; var axisModel = ecModel.queryComponents({ mainType: dimName + 'Axis', index: seriesModel.get(dimName + 'AxisIndex'), id: seriesModel.get(dimName + 'AxisId') })[0]; if (this._axisIndex === (axisModel && axisModel.componentIndex)) { seriesModels.push(seriesModel); } } }, this); return seriesModels; }, getAxisModel: function () { return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex); }, getOtherAxisModel: function () { var axisDim = this._dimName; var ecModel = this.ecModel; var axisModel = this.getAxisModel(); var isCartesian = axisDim === 'x' || axisDim === 'y'; var otherAxisDim; var coordSysIndexName; if (isCartesian) { coordSysIndexName = 'gridIndex'; otherAxisDim = axisDim === 'x' ? 'y' : 'x'; } else { coordSysIndexName = 'polarIndex'; otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle'; } var foundOtherAxisModel; ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) { if ((otherAxisModel.get(coordSysIndexName) || 0) === (axisModel.get(coordSysIndexName) || 0) ) { foundOtherAxisModel = otherAxisModel; } }); return foundOtherAxisModel; }, getMinMaxSpan: function () { return zrUtil.clone(this._minMaxSpan); }, /** * Only calculate by given range and this._dataExtent, do not change anything. * * @param {Object} opt * @param {number} [opt.start] * @param {number} [opt.end] * @param {number} [opt.startValue] * @param {number} [opt.endValue] */ calculateDataWindow: function (opt) { var dataExtent = this._dataExtent; var axisModel = this.getAxisModel(); var scale = axisModel.axis.scale; var rangePropMode = this._dataZoomModel.getRangePropMode(); var percentExtent = [0, 100]; var percentWindow = [ opt.start, opt.end ]; var valueWindow = []; each(['startValue', 'endValue'], function (prop) { valueWindow.push(opt[prop] != null ? scale.parse(opt[prop]) : null); }); // Normalize bound. each([0, 1], function (idx) { var boundValue = valueWindow[idx]; var boundPercent = percentWindow[idx]; // Notice: dataZoom is based either on `percentProp` ('start', 'end') or // on `valueProp` ('startValue', 'endValue'). The former one is suitable // for cases that a dataZoom component controls multiple axes with different // unit or extent, and the latter one is suitable for accurate zoom by pixel // (e.g., in dataZoomSelect). `valueProp` can be calculated from `percentProp`, // but it is awkward that `percentProp` can not be obtained from `valueProp` // accurately (because all of values that are overflow the `dataExtent` will // be calculated to percent '100%'). So we have to use // `dataZoom.getRangePropMode()` to mark which prop is used. // `rangePropMode` is updated only when setOption or dispatchAction, otherwise // it remains its original value. if (rangePropMode[idx] === 'percent') { if (boundPercent == null) { boundPercent = percentExtent[idx]; } // Use scale.parse to math round for category or time axis. boundValue = scale.parse(numberUtil.linearMap( boundPercent, percentExtent, dataExtent, true )); } else { // Calculating `percent` from `value` may be not accurate, because // This calculation can not be inversed, because all of values that // are overflow the `dataExtent` will be calculated to percent '100%' boundPercent = numberUtil.linearMap( boundValue, dataExtent, percentExtent, true ); } // valueWindow[idx] = round(boundValue); // percentWindow[idx] = round(boundPercent); valueWindow[idx] = boundValue; percentWindow[idx] = boundPercent; }); return { valueWindow: asc(valueWindow), percentWindow: asc(percentWindow) }; }, /** * Notice: reset should not be called before series.restoreData() called, * so it is recommanded to be called in \"process stage\" but not \"model init * stage\". * * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel */ reset: function (dataZoomModel) { if (dataZoomModel !== this._dataZoomModel) { return; } // Culculate data window and data extent, and record them. this._dataExtent = calculateDataExtent( this, this._dimName, this.getTargetSeriesModels() ); var dataWindow = this.calculateDataWindow(dataZoomModel.option); this._valueWindow = dataWindow.valueWindow; this._percentWindow = dataWindow.percentWindow; setMinMaxSpan(this); // Update axis setting then. setAxisModel(this); }, /** * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel */ restore: function (dataZoomModel) { if (dataZoomModel !== this._dataZoomModel) { return; } this._valueWindow = this._percentWindow = null; setAxisModel(this, true); }, /** * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel */ filterData: function (dataZoomModel) { if (dataZoomModel !== this._dataZoomModel) { return; } var axisDim = this._dimName; var seriesModels = this.getTargetSeriesModels(); var filterMode = dataZoomModel.get('filterMode'); var valueWindow = this._valueWindow; if (filterMode === 'none') { return; } // FIXME // Toolbox may has dataZoom injected. And if there are stacked bar chart // with NaN data, NaN will be filtered and stack will be wrong. // So we need to force the mode to be set empty. // In fect, it is not a big deal that do not support filterMode-'filter' // when using toolbox#dataZoom, utill tooltip#dataZoom support \"single axis // selection\" some day, which might need \"adapt to data extent on the // otherAxis\", which is disabled by filterMode-'empty'. var otherAxisModel = this.getOtherAxisModel(); if (dataZoomModel.get('$fromToolbox') && otherAxisModel && otherAxisModel.get('type') === 'category' ) { filterMode = 'empty'; } // Process series data each(seriesModels, function (seriesModel) { var seriesData = seriesModel.getData(); var dataDims = seriesModel.coordDimToDataDim(axisDim); if (filterMode === 'weakFilter') { seriesData && seriesData.filterSelf(function (dataIndex) { var leftOut; var rightOut; var hasValue; for (var i = 0; i < dataDims.length; i++) { var value = seriesData.get(dataDims[i], dataIndex); var thisHasValue = !isNaN(value); var thisLeftOut = value < valueWindow[0]; var thisRightOut = value > valueWindow[1]; if (thisHasValue && !thisLeftOut && !thisRightOut) { return true; } thisHasValue && (hasValue = true); thisLeftOut && (leftOut = true); thisRightOut && (rightOut = true); } // If both left out and right out, do not filter. return hasValue && leftOut && rightOut; }); } else { seriesData && each(dataDims, function (dim) { if (filterMode === 'empty') { seriesModel.setData( seriesData.map(dim, function (value) { return !isInWindow(value) ? NaN : value; }) ); } else { seriesData.filterSelf(dim, isInWindow); } }); } }); function isInWindow(value) { return value >= valueWindow[0] && value 0 ? 0 : NaN; } var max = axisModel.getMax(true); if (max != null && max !== 'dataMax' && typeof max !== 'function') { dataExtent[1] = max; } else if (isCategoryAxis) { dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN; } if (!axisModel.get('scale', true)) { dataExtent[0] > 0 && (dataExtent[0] = 0); dataExtent[1] < 0 && (dataExtent[1] = 0); } // For value axis, if min/max/scale are not set, we just use the extent obtained // by series data, which may be a little different from the extent calculated by // `axisHelper.getScaleExtent`. But the different just affects the experience a // little when zooming. So it will not be fixed until some users require it strongly. return dataExtent; } function setAxisModel(axisProxy, isRestore) { var axisModel = axisProxy.getAxisModel(); var percentWindow = axisProxy._percentWindow; var valueWindow = axisProxy._valueWindow; if (!percentWindow) { return; } // [0, 500]: arbitrary value, guess axis extent. var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]); precision = Math.min(precision, 20); // isRestore or isFull var useOrigin = isRestore || (percentWindow[0] === 0 && percentWindow[1] === 100); axisModel.setRange( useOrigin ? null : +valueWindow[0].toFixed(precision), useOrigin ? null : +valueWindow[1].toFixed(precision) ); } function setMinMaxSpan(axisProxy) { var minMaxSpan = axisProxy._minMaxSpan = {}; var dataZoomModel = axisProxy._dataZoomModel; each(['min', 'max'], function (minMax) { minMaxSpan[minMax + 'Span'] = dataZoomModel.get(minMax + 'Span'); // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan var valueSpan = dataZoomModel.get(minMax + 'ValueSpan'); if (valueSpan != null) { minMaxSpan[minMax + 'ValueSpan'] = valueSpan; valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan); if (valueSpan != null) { minMaxSpan[minMax + 'Span'] = numberUtil.linearMap( valueSpan, axisProxy._dataExtent, [0, 100], true ); } } }); } module.exports = AxisProxy; /***/ }), /* 376 */ /***/ (function(module, exports, __webpack_require__) { var ComponentView = __webpack_require__(84); module.exports = ComponentView.extend({ type: 'dataZoom', render: function (dataZoomModel, ecModel, api, payload) { this.dataZoomModel = dataZoomModel; this.ecModel = ecModel; this.api = api; }, /** * Find the first target coordinate system. * * @protected * @return {Object} { * grid: [ * {model: coord0, axisModels: [axis1, axis3], coordIndex: 1}, * {model: coord1, axisModels: [axis0, axis2], coordIndex: 0}, * ... * ], // cartesians must not be null/undefined. * polar: [ * {model: coord0, axisModels: [axis4], coordIndex: 0}, * ... * ], // polars must not be null/undefined. * singleAxis: [ * {model: coord0, axisModels: [], coordIndex: 0} * ] */ getTargetCoordInfo: function () { var dataZoomModel = this.dataZoomModel; var ecModel = this.ecModel; var coordSysLists = {}; dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) { var axisModel = ecModel.getComponent(dimNames.axis, axisIndex); if (axisModel) { var coordModel = axisModel.getCoordSysModel(); coordModel && save( coordModel, axisModel, coordSysLists[coordModel.mainType] || (coordSysLists[coordModel.mainType] = []), coordModel.componentIndex ); } }, this); function save(coordModel, axisModel, store, coordIndex) { var item; for (var i = 0; i < store.length; i++) { if (store[i].model === coordModel) { item = store[i]; break; } } if (!item) { store.push(item = { model: coordModel, axisModels: [], coordIndex: coordIndex }); } item.axisModels.push(axisModel); } return coordSysLists; } }); /***/ }), /* 377 */ /***/ (function(module, exports, __webpack_require__) { /** * @file Data zoom model */ var DataZoomModel = __webpack_require__(373); var SliderZoomModel = DataZoomModel.extend({ type: 'dataZoom.slider', layoutMode: 'box', /** * @protected */ defaultOption: { show: true, // ph => placeholder. Using placehoder here because // deault value can only be drived in view stage. right: 'ph', // Default align to grid rect. top: 'ph', // Default align to grid rect. width: 'ph', // Default align to grid rect. height: 'ph', // Default align to grid rect. left: null, // Default align to grid rect. bottom: null, // Default align to grid rect. backgroundColor: 'rgba(47,69,84,0)', // Background of slider zoom component. // dataBackgroundColor: '#ddd', // Background coor of data shadow and border of box, // highest priority, remain for compatibility of // previous version, but not recommended any more. dataBackground: { lineStyle: { color: '#2f4554', width: 0.5, opacity: 0.3 }, areaStyle: { color: 'rgba(47,69,84,0.3)', opacity: 0.3 } }, borderColor: '#ddd', // border color of the box. For compatibility, // if dataBackgroundColor is set, borderColor // is ignored. fillerColor: 'rgba(167,183,204,0.4)', // Color of selected area. // handleColor: 'rgba(89,170,216,0.95)', // Color of handle. // handleIcon: 'path://M4.9,17.8c0-1.4,4.5-10.5,5.5-12.4c0-0.1,0.6-1.1,0.9-1.1c0.4,0,0.9,1,0.9,1.1c1.1,2.2,5.4,11,5.4,12.4v17.8c0,1.5-0.6,2.1-1.3,2.1H6.1c-0.7,0-1.3-0.6-1.3-2.1V17.8z', handleIcon: 'M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z', // Percent of the slider height handleSize: '100%', handleStyle: { color: '#a7b7cc' }, labelPrecision: null, labelFormatter: null, showDetail: true, showDataShadow: 'auto', // Default auto decision. realtime: true, zoomLock: false, // Whether disable zoom. textStyle: { color: '#333' } } }); module.exports = SliderZoomModel; /***/ }), /* 378 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); var graphic = __webpack_require__(20); var throttle = __webpack_require__(86); var DataZoomView = __webpack_require__(376); var Rect = graphic.Rect; var numberUtil = __webpack_require__(7); var linearMap = numberUtil.linearMap; var layout = __webpack_require__(74); var sliderMove = __webpack_require__(242); var eventTool = __webpack_require__(93); var asc = numberUtil.asc; var bind = zrUtil.bind; // var mathMax = Math.max; var each = zrUtil.each; // Constants var DEFAULT_LOCATION_EDGE_GAP = 7; var DEFAULT_FRAME_BORDER_WIDTH = 1; var DEFAULT_FILLER_SIZE = 30; var HORIZONTAL = 'horizontal'; var VERTICAL = 'vertical'; var LABEL_GAP = 5; var SHOW_DATA_SHADOW_SERIES_TYPE = ['line', 'bar', 'candlestick', 'scatter']; var SliderZoomView = DataZoomView.extend({ type: 'dataZoom.slider', init: function (ecModel, api) { /** * @private * @type {Object} */ this._displayables = {}; /** * @private * @type {string} */ this._orient; /** * [0, 100] * @private */ this._range; /** * [coord of the first handle, coord of the second handle] * @private */ this._handleEnds; /** * [length, thick] * @private * @type {Array.} */ this._size; /** * @private * @type {number} */ this._handleWidth; /** * @private * @type {number} */ this._handleHeight; /** * @private */ this._location; /** * @private */ this._dragging; /** * @private */ this._dataShadowInfo; this.api = api; }, /** * @override */ render: function (dataZoomModel, ecModel, api, payload) { SliderZoomView.superApply(this, 'render', arguments); throttle.createOrUpdate( this, '_dispatchZoomAction', this.dataZoomModel.get('throttle'), 'fixRate' ); this._orient = dataZoomModel.get('orient'); if (this.dataZoomModel.get('show') === false) { this.group.removeAll(); return; } // Notice: this._resetInterval() should not be executed when payload.type // is 'dataZoom', origin this._range should be maintained, otherwise 'pan' // or 'zoom' info will be missed because of 'throttle' of this.dispatchAction, if (!payload || payload.type !== 'dataZoom' || payload.from !== this.uid) { this._buildView(); } this._updateView(); }, /** * @override */ remove: function () { SliderZoomView.superApply(this, 'remove', arguments); throttle.clear(this, '_dispatchZoomAction'); }, /** * @override */ dispose: function () { SliderZoomView.superApply(this, 'dispose', arguments); throttle.clear(this, '_dispatchZoomAction'); }, _buildView: function () { var thisGroup = this.group; thisGroup.removeAll(); this._resetLocation(); this._resetInterval(); var barGroup = this._displayables.barGroup = new graphic.Group(); this._renderBackground(); this._renderHandle(); this._renderDataShadow(); thisGroup.add(barGroup); this._positionGroup(); }, /** * @private */ _resetLocation: function () { var dataZoomModel = this.dataZoomModel; var api = this.api; // If some of x/y/width/height are not specified, // auto-adapt according to target grid. var coordRect = this._findCoordRect(); var ecSize = {width: api.getWidth(), height: api.getHeight()}; // Default align by coordinate system rect. var positionInfo = this._orient === HORIZONTAL ? { // Why using 'right', because right should be used in vertical, // and it is better to be consistent for dealing with position param merge. right: ecSize.width - coordRect.x - coordRect.width, top: (ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP), width: coordRect.width, height: DEFAULT_FILLER_SIZE } : { // vertical right: DEFAULT_LOCATION_EDGE_GAP, top: coordRect.y, width: DEFAULT_FILLER_SIZE, height: coordRect.height }; // Do not write back to option and replace value 'ph', because // the 'ph' value should be recalculated when resize. var layoutParams = layout.getLayoutParams(dataZoomModel.option); // Replace the placeholder value. zrUtil.each(['right', 'top', 'width', 'height'], function (name) { if (layoutParams[name] === 'ph') { layoutParams[name] = positionInfo[name]; } }); var layoutRect = layout.getLayoutRect( layoutParams, ecSize, dataZoomModel.padding ); this._location = {x: layoutRect.x, y: layoutRect.y}; this._size = [layoutRect.width, layoutRect.height]; this._orient === VERTICAL && this._size.reverse(); }, /** * @private */ _positionGroup: function () { var thisGroup = this.group; var location = this._location; var orient = this._orient; // Just use the first axis to determine mapping. var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel(); var inverse = targetAxisModel && targetAxisModel.get('inverse'); var barGroup = this._displayables.barGroup; var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse; // Transform barGroup. barGroup.attr( (orient === HORIZONTAL && !inverse) ? {scale: otherAxisInverse ? [1, 1] : [1, -1]} : (orient === HORIZONTAL && inverse) ? {scale: otherAxisInverse ? [-1, 1] : [-1, -1]} : (orient === VERTICAL && !inverse) ? {scale: otherAxisInverse ? [1, -1] : [1, 1], rotation: Math.PI / 2} // Dont use Math.PI, considering shadow direction. : {scale: otherAxisInverse ? [-1, -1] : [-1, 1], rotation: Math.PI / 2} ); // Position barGroup var rect = thisGroup.getBoundingRect([barGroup]); thisGroup.attr('position', [location.x - rect.x, location.y - rect.y]); }, /** * @private */ _getViewExtent: function () { return [0, this._size[0]]; }, _renderBackground: function () { var dataZoomModel = this.dataZoomModel; var size = this._size; var barGroup = this._displayables.barGroup; barGroup.add(new Rect({ silent: true, shape: { x: 0, y: 0, width: size[0], height: size[1] }, style: { fill: dataZoomModel.get('backgroundColor') }, z2: -40 })); // Click panel, over shadow, below handles. barGroup.add(new Rect({ shape: { x: 0, y: 0, width: size[0], height: size[1] }, style: { fill: 'transparent' }, z2: 0, onclick: zrUtil.bind(this._onClickPanelClick, this) })); }, _renderDataShadow: function () { var info = this._dataShadowInfo = this._prepareDataShadowInfo(); if (!info) { return; } var size = this._size; var seriesModel = info.series; var data = seriesModel.getRawData(); var otherDim = seriesModel.getShadowDim ? seriesModel.getShadowDim() // @see candlestick : info.otherDim; if (otherDim == null) { return; } var otherDataExtent = data.getDataExtent(otherDim); // Nice extent. var otherOffset = (otherDataExtent[1] - otherDataExtent[0]) * 0.3; otherDataExtent = [ otherDataExtent[0] - otherOffset, otherDataExtent[1] + otherOffset ]; var otherShadowExtent = [0, size[1]]; var thisShadowExtent = [0, size[0]]; var areaPoints = [[size[0], 0], [0, 0]]; var linePoints = []; var step = thisShadowExtent[1] / (data.count() - 1); var thisCoord = 0; // Optimize for large data shadow var stride = Math.round(data.count() / size[0]); var lastIsEmpty; data.each([otherDim], function (value, index) { if (stride > 0 && (index % stride)) { thisCoord += step; return; } // FIXME // Should consider axis.min/axis.max when drawing dataShadow. // FIXME // 应该使用统一的空判断？还是在list里进行空判断？ var isEmpty = value == null || isNaN(value) || value === ''; // See #4235. var otherCoord = isEmpty ? 0 : linearMap(value, otherDataExtent, otherShadowExtent, true); // Attempt to draw data shadow precisely when there are empty value. if (isEmpty && !lastIsEmpty && index) { areaPoints.push([areaPoints[areaPoints.length - 1][0], 0]); linePoints.push([linePoints[linePoints.length - 1][0], 0]); } else if (!isEmpty && lastIsEmpty) { areaPoints.push([thisCoord, 0]); linePoints.push([thisCoord, 0]); } areaPoints.push([thisCoord, otherCoord]); linePoints.push([thisCoord, otherCoord]); thisCoord += step; lastIsEmpty = isEmpty; }); var dataZoomModel = this.dataZoomModel; // var dataBackgroundModel = dataZoomModel.getModel('dataBackground'); this._displayables.barGroup.add(new graphic.Polygon({ shape: {points: areaPoints}, style: zrUtil.defaults( {fill: dataZoomModel.get('dataBackgroundColor')}, dataZoomModel.getModel('dataBackground.areaStyle').getAreaStyle() ), silent: true, z2: -20 })); this._displayables.barGroup.add(new graphic.Polyline({ shape: {points: linePoints}, style: dataZoomModel.getModel('dataBackground.lineStyle').getLineStyle(), silent: true, z2: -19 })); }, _prepareDataShadowInfo: function () { var dataZoomModel = this.dataZoomModel; var showDataShadow = dataZoomModel.get('showDataShadow'); if (showDataShadow === false) { return; } // Find a representative series. var result; var ecModel = this.ecModel; dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) { var seriesModels = dataZoomModel .getAxisProxy(dimNames.name, axisIndex) .getTargetSeriesModels(); zrUtil.each(seriesModels, function (seriesModel) { if (result) { return; } if (showDataShadow !== true && zrUtil.indexOf( SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get('type') ) < 0 ) { return; } var thisAxis = ecModel.getComponent(dimNames.axis, axisIndex).axis; var otherDim = getOtherDim(dimNames.name); var otherAxisInverse; var coordSys = seriesModel.coordinateSystem; if (otherDim != null && coordSys.getOtherAxis) { otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse; } result = { thisAxis: thisAxis, series: seriesModel, thisDim: dimNames.name, otherDim: otherDim, otherAxisInverse: otherAxisInverse }; }, this); }, this); return result; }, _renderHandle: function () { var displaybles = this._displayables; var handles = displaybles.handles = []; var handleLabels = displaybles.handleLabels = []; var barGroup = this._displayables.barGroup; var size = this._size; var dataZoomModel = this.dataZoomModel; barGroup.add(displaybles.filler = new Rect({ draggable: true, cursor: getCursor(this._orient), drift: bind(this._onDragMove, this, 'all'), onmousemove: function (e) { // Fot mobile devicem, prevent screen slider on the button. eventTool.stop(e.event); }, ondragstart: bind(this._showDataInfo, this, true), ondragend: bind(this._onDragEnd, this), onmouseover: bind(this._showDataInfo, this, true), onmouseout: bind(this._showDataInfo, this, false), style: { fill: dataZoomModel.get('fillerColor'), textPosition : 'inside' } })); // Frame border. barGroup.add(new Rect(graphic.subPixelOptimizeRect({ silent: true, shape: { x: 0, y: 0, width: size[0], height: size[1] }, style: { stroke: dataZoomModel.get('dataBackgroundColor') || dataZoomModel.get('borderColor'), lineWidth: DEFAULT_FRAME_BORDER_WIDTH, fill: 'rgba(0,0,0,0)' } }))); each([0, 1], function (handleIndex) { var path = graphic.createIcon( dataZoomModel.get('handleIcon'), { cursor: getCursor(this._orient), draggable: true, drift: bind(this._onDragMove, this, handleIndex), onmousemove: function (e) { // Fot mobile devicem, prevent screen slider on the button. eventTool.stop(e.event); }, ondragend: bind(this._onDragEnd, this), onmouseover: bind(this._showDataInfo, this, true), onmouseout: bind(this._showDataInfo, this, false) }, {x: -1, y: 0, width: 2, height: 2} ); var bRect = path.getBoundingRect(); this._handleHeight = numberUtil.parsePercent(dataZoomModel.get('handleSize'), this._size[1]); this._handleWidth = bRect.width / bRect.height * this._handleHeight; path.setStyle(dataZoomModel.getModel('handleStyle').getItemStyle()); var handleColor = dataZoomModel.get('handleColor'); // Compatitable with previous version if (handleColor != null) { path.style.fill = handleColor; } barGroup.add(handles[handleIndex] = path); var textStyleModel = dataZoomModel.textStyleModel; this.group.add( handleLabels[handleIndex] = new graphic.Text({ silent: true, invisible: true, style: { x: 0, y: 0, text: '', textVerticalAlign: 'middle', textAlign: 'center', textFill: textStyleModel.getTextColor(), textFont: textStyleModel.getFont() }, z2: 10 })); }, this); }, /** * @private */ _resetInterval: function () { var range = this._range = this.dataZoomModel.getPercentRange(); var viewExtent = this._getViewExtent(); this._handleEnds = [ linearMap(range[0], [0, 100], viewExtent, true), linearMap(range[1], [0, 100], viewExtent, true) ]; }, /** * @private * @param {(number|string)} handleIndex 0 or 1 or 'all' * @param {number} delta */ _updateInterval: function (handleIndex, delta) { var dataZoomModel = this.dataZoomModel; var handleEnds = this._handleEnds; var viewExtend = this._getViewExtent(); var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan(); var percentExtent = [0, 100]; sliderMove( delta, handleEnds, viewExtend, dataZoomModel.get('zoomLock') ? 'all' : handleIndex, minMaxSpan.minSpan != null ? linearMap(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null ); this._range = asc([ linearMap(handleEnds[0], viewExtend, percentExtent, true), linearMap(handleEnds[1], viewExtend, percentExtent, true) ]); }, /** * @private */ _updateView: function (nonRealtime) { var displaybles = this._displayables; var handleEnds = this._handleEnds; var handleInterval = asc(handleEnds.slice()); var size = this._size; each([0, 1], function (handleIndex) { // Handles var handle = displaybles.handles[handleIndex]; var handleHeight = this._handleHeight; handle.attr({ scale: [handleHeight / 2, handleHeight / 2], position: [handleEnds[handleIndex], size[1] / 2 - handleHeight / 2] }); }, this); // Filler displaybles.filler.setShape({ x: handleInterval[0], y: 0, width: handleInterval[1] - handleInterval[0], height: size[1] }); this._updateDataInfo(nonRealtime); }, /** * @private */ _updateDataInfo: function (nonRealtime) { var dataZoomModel = this.dataZoomModel; var displaybles = this._displayables; var handleLabels = displaybles.handleLabels; var orient = this._orient; var labelTexts = ['', '']; // FIXME // date型，支持formatter，autoformatter（ec2 date.getAutoFormatter） if (dataZoomModel.get('showDetail')) { var axisProxy = dataZoomModel.findRepresentativeAxisProxy(); if (axisProxy) { var axis = axisProxy.getAxisModel().axis; var range = this._range; var dataInterval = nonRealtime // See #4434, data and axis are not processed and reset yet in non-realtime mode. ? axisProxy.calculateDataWindow({ start: range[0], end: range[1] }).valueWindow : axisProxy.getDataValueWindow(); labelTexts = [ this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis) ]; } } var orderedHandleEnds = asc(this._handleEnds.slice()); setLabel.call(this, 0); setLabel.call(this, 1); function setLabel(handleIndex) { // Label // Text should not transform by barGroup. // Ignore handlers transform var barTransform = graphic.getTransform( displaybles.handles[handleIndex].parent, this.group ); var direction = graphic.transformDirection( handleIndex === 0 ? 'right' : 'left', barTransform ); var offset = this._handleWidth / 2 + LABEL_GAP; var textPoint = graphic.applyTransform( [ orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2 ], barTransform ); handleLabels[handleIndex].setStyle({ x: textPoint[0], y: textPoint[1], textVerticalAlign: orient === HORIZONTAL ? 'middle' : direction, textAlign: orient === HORIZONTAL ? direction : 'center', text: labelTexts[handleIndex] }); } }, /** * @private */ _formatLabel: function (value, axis) { var dataZoomModel = this.dataZoomModel; var labelFormatter = dataZoomModel.get('labelFormatter'); var labelPrecision = dataZoomModel.get('labelPrecision'); if (labelPrecision == null || labelPrecision === 'auto') { labelPrecision = axis.getPixelPrecision(); } var valueStr = (value == null || isNaN(value)) ? '' // FIXME Glue code : (axis.type === 'category' || axis.type === 'time') ? axis.scale.getLabel(Math.round(value)) // param of toFixed should less then 20. : value.toFixed(Math.min(labelPrecision, 20)); return zrUtil.isFunction(labelFormatter) ? labelFormatter(value, valueStr) : zrUtil.isString(labelFormatter) ? labelFormatter.replace('{value}', valueStr) : valueStr; }, /** * @private * @param {boolean} showOrHide true: show, false: hide */ _showDataInfo: function (showOrHide) { // Always show when drgging. showOrHide = this._dragging || showOrHide; var handleLabels = this._displayables.handleLabels; handleLabels[0].attr('invisible', !showOrHide); handleLabels[1].attr('invisible', !showOrHide); }, _onDragMove: function (handleIndex, dx, dy) { this._dragging = true; // Transform dx, dy to bar coordination. var barTransform = this._displayables.barGroup.getLocalTransform(); var vertex = graphic.applyTransform([dx, dy], barTransform, true); this._updateInterval(handleIndex, vertex[0]); var realtime = this.dataZoomModel.get('realtime'); this._updateView(!realtime); if (realtime) { realtime && this._dispatchZoomAction(); } }, _onDragEnd: function () { this._dragging = false; this._showDataInfo(false); this._dispatchZoomAction(); }, _onClickPanelClick: function (e) { var size = this._size; var localPoint = this._displayables.barGroup.transformCoordToLocal(e.offsetX, e.offsetY); if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1] ) { return; } var handleEnds = this._handleEnds; var center = (handleEnds[0] + handleEnds[1]) / 2; this._updateInterval('all', localPoint[0] - center); this._updateView(); this._dispatchZoomAction(); }, /** * This action will be throttled. * @private */ _dispatchZoomAction: function () { var range = this._range; this.api.dispatchAction({ type: 'dataZoom', from: this.uid, dataZoomId: this.dataZoomModel.id, start: range[0], end: range[1] }); }, /** * @private */ _findCoordRect: function () { // Find the grid coresponding to the first axis referred by dataZoom. var rect; each(this.getTargetCoordInfo(), function (coordInfoList) { if (!rect && coordInfoList.length) { var coordSys = coordInfoList[0].model.coordinateSystem; rect = coordSys.getRect && coordSys.getRect(); } }); if (!rect) { var width = this.api.getWidth(); var height = this.api.getHeight(); rect = { x: width * 0.2, y: height * 0.2, width: width * 0.6, height: height * 0.6 }; } return rect; } }); function getOtherDim(thisDim) { // FIXME // 这个逻辑和getOtherAxis里一致，但是写在这里是否不好 var map = {x: 'y', y: 'x', radius: 'angle', angle: 'radius'}; return map[thisDim]; } function getCursor(orient) { return orient === 'vertical' ? 'ns-resize' : 'ew-resize'; } module.exports = SliderZoomView; /***/ }), /* 379 */ /***/ (function(module, exports, __webpack_require__) { /** * @file Data zoom model */ module.exports = __webpack_require__(373).extend({ type: 'dataZoom.inside', /** * @protected */ defaultOption: { disabled: false, // Whether disable this inside zoom. zoomLock: false, // Whether disable zoom but only pan. zoomOnMouseWheel: true, // Can be: true / false / 'shift' / 'ctrl' / 'alt'. moveOnMouseMove: true, // Can be: true / false / 'shift' / 'ctrl' / 'alt'. preventDefaultMouseMove: true } }); /***/ }), /* 380 */ /***/ (function(module, exports, __webpack_require__) { var DataZoomView = __webpack_require__(376); var zrUtil = __webpack_require__(4); var sliderMove = __webpack_require__(242); var roams = __webpack_require__(381); var bind = zrUtil.bind; var InsideZoomView = DataZoomView.extend({ type: 'dataZoom.inside', /** * @override */ init: function (ecModel, api) { /** * 'throttle' is used in this.dispatchAction, so we save range * to avoid missing some 'pan' info. * @private * @type {Array.} */ this._range; }, /** * @override */ render: function (dataZoomModel, ecModel, api, payload) { InsideZoomView.superApply(this, 'render', arguments); // Notice: origin this._range should be maintained, and should not be re-fetched // from dataZoomModel when payload.type is 'dataZoom', otherwise 'pan' or 'zoom' // info will be missed because of 'throttle' of this.dispatchAction. if (roams.shouldRecordRange(payload, dataZoomModel.id)) { this._range = dataZoomModel.getPercentRange(); } // Reset controllers. zrUtil.each(this.getTargetCoordInfo(), function (coordInfoList, coordSysName) { var allCoordIds = zrUtil.map(coordInfoList, function (coordInfo) { return roams.generateCoordId(coordInfo.model); }); zrUtil.each(coordInfoList, function (coordInfo) { var coordModel = coordInfo.model; var dataZoomOption = dataZoomModel.option; roams.register( api, { coordId: roams.generateCoordId(coordModel), allCoordIds: allCoordIds, containsPoint: function (e, x, y) { return coordModel.coordinateSystem.containPoint([x, y]); }, dataZoomId: dataZoomModel.id, throttleRate: dataZoomModel.get('throttle', true), panGetRange: bind(this._onPan, this, coordInfo, coordSysName), zoomGetRange: bind(this._onZoom, this, coordInfo, coordSysName), zoomLock: dataZoomOption.zoomLock, disabled: dataZoomOption.disabled, roamControllerOpt: { zoomOnMouseWheel: dataZoomOption.zoomOnMouseWheel, moveOnMouseMove: dataZoomOption.moveOnMouseMove, preventDefaultMouseMove: dataZoomOption.preventDefaultMouseMove } } ); }, this); }, this); }, /** * @override */ dispose: function () { roams.unregister(this.api, this.dataZoomModel.id); InsideZoomView.superApply(this, 'dispose', arguments); this._range = null; }, /** * @private */ _onPan: function (coordInfo, coordSysName, controller, dx, dy, oldX, oldY, newX, newY) { var range = this._range.slice(); // Calculate transform by the first axis. var axisModel = coordInfo.axisModels[0]; if (!axisModel) { return; } var directionInfo = getDirectionInfo[coordSysName]( [oldX, oldY], [newX, newY], axisModel, controller, coordInfo ); var percentDelta = directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength; sliderMove(percentDelta, range, [0, 100], 'all'); return (this._range = range); }, /** * @private */ _onZoom: function (coordInfo, coordSysName, controller, scale, mouseX, mouseY) { var range = this._range.slice(); // Calculate transform by the first axis. var axisModel = coordInfo.axisModels[0]; if (!axisModel) { return; } var directionInfo = getDirectionInfo[coordSysName]( null, [mouseX, mouseY], axisModel, controller, coordInfo ); var percentPoint = ( directionInfo.signal > 0 ? (directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel) : (directionInfo.pixel - directionInfo.pixelStart) ) / directionInfo.pixelLength * (range[1] - range[0]) + range[0]; scale = Math.max(1 / scale, 0); range[0] = (range[0] - percentPoint) * scale + percentPoint; range[1] = (range[1] - percentPoint) * scale + percentPoint; // Restrict range. var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan(); sliderMove(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan); return (this._range = range); } }); var getDirectionInfo = { grid: function (oldPoint, newPoint, axisModel, controller, coordInfo) { var axis = axisModel.axis; var ret = {}; var rect = coordInfo.model.coordinateSystem.getRect(); oldPoint = oldPoint || [0, 0]; if (axis.dim === 'x') { ret.pixel = newPoint[0] - oldPoint[0]; ret.pixelLength = rect.width; ret.pixelStart = rect.x; ret.signal = axis.inverse ? 1 : -1; } else { // axis.dim === 'y' ret.pixel = newPoint[1] - oldPoint[1]; ret.pixelLength = rect.height; ret.pixelStart = rect.y; ret.signal = axis.inverse ? -1 : 1; } return ret; }, polar: function (oldPoint, newPoint, axisModel, controller, coordInfo) { var axis = axisModel.axis; var ret = {}; var polar = coordInfo.model.coordinateSystem; var radiusExtent = polar.getRadiusAxis().getExtent(); var angleExtent = polar.getAngleAxis().getExtent(); oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0]; newPoint = polar.pointToCoord(newPoint); if (axisModel.mainType === 'radiusAxis') { ret.pixel = newPoint[0] - oldPoint[0]; // ret.pixelLength = Math.abs(radiusExtent[1] - radiusExtent[0]); // ret.pixelStart = Math.min(radiusExtent[0], radiusExtent[1]); ret.pixelLength = radiusExtent[1] - radiusExtent[0]; ret.pixelStart = radiusExtent[0]; ret.signal = axis.inverse ? 1 : -1; } else { // 'angleAxis' ret.pixel = newPoint[1] - oldPoint[1]; // ret.pixelLength = Math.abs(angleExtent[1] - angleExtent[0]); // ret.pixelStart = Math.min(angleExtent[0], angleExtent[1]); ret.pixelLength = angleExtent[1] - angleExtent[0]; ret.pixelStart = angleExtent[0]; ret.signal = axis.inverse ? -1 : 1; } return ret; }, singleAxis: function (oldPoint, newPoint, axisModel, controller, coordInfo) { var axis = axisModel.axis; var rect = coordInfo.model.coordinateSystem.getRect(); var ret = {}; oldPoint = oldPoint || [0, 0]; if (axis.orient === 'horizontal') { ret.pixel = newPoint[0] - oldPoint[0]; ret.pixelLength = rect.width; ret.pixelStart = rect.x; ret.signal = axis.inverse ? 1 : -1; } else { // 'vertical' ret.pixel = newPoint[1] - oldPoint[1]; ret.pixelLength = rect.height; ret.pixelStart = rect.y; ret.signal = axis.inverse ? -1 : 1; } return ret; } }; module.exports = InsideZoomView; /***/ }), /* 381 */ /***/ (function(module, exports, __webpack_require__) { /** * @file Roam controller manager. */ // Only create one roam controller for each coordinate system. // one roam controller might be refered by two inside data zoom // components (for example, one for x and one for y). When user // pan or zoom, only dispatch one action for those data zoom // components. var zrUtil = __webpack_require__(4); var RoamController = __webpack_require__(186); var throttle = __webpack_require__(86); var curry = zrUtil.curry; var ATTR = '\\0_ec_dataZoom_roams'; var roams = { /** * @public * @param {module:echarts/ExtensionAPI} api * @param {Object} dataZoomInfo * @param {string} dataZoomInfo.coordId * @param {Function} dataZoomInfo.containsPoint * @param {Array.} dataZoomInfo.allCoordIds * @param {string} dataZoomInfo.dataZoomId * @param {number} dataZoomInfo.throttleRate * @param {Function} dataZoomInfo.panGetRange * @param {Function} dataZoomInfo.zoomGetRange * @param {boolean} [dataZoomInfo.zoomLock] * @param {boolean} [dataZoomInfo.disabled] */ register: function (api, dataZoomInfo) { var store = giveStore(api); var theDataZoomId = dataZoomInfo.dataZoomId; var theCoordId = dataZoomInfo.coordId; // Do clean when a dataZoom changes its target coordnate system. // Avoid memory leak, dispose all not-used-registered. zrUtil.each(store, function (record, coordId) { var dataZoomInfos = record.dataZoomInfos; if (dataZoomInfos[theDataZoomId] && zrUtil.indexOf(dataZoomInfo.allCoordIds, theCoordId) < 0 ) { delete dataZoomInfos[theDataZoomId]; record.count--; } }); cleanStore(store); var record = store[theCoordId]; // Create if needed. if (!record) { record = store[theCoordId] = { coordId: theCoordId, dataZoomInfos: {}, count: 0 }; record.controller = createController(api, record); record.dispatchAction = zrUtil.curry(dispatchAction, api); } // Update reference of dataZoom. !(record.dataZoomInfos[theDataZoomId]) && record.count++; record.dataZoomInfos[theDataZoomId] = dataZoomInfo; var controllerParams = mergeControllerParams(record.dataZoomInfos); record.controller.enable(controllerParams.controlType, controllerParams.opt); // Consider resize, area should be always updated. record.controller.setPointerChecker(dataZoomInfo.containsPoint); // Update throttle. throttle.createOrUpdate( record, 'dispatchAction', dataZoomInfo.throttleRate, 'fixRate' ); }, /** * @public * @param {module:echarts/ExtensionAPI} api * @param {string} dataZoomId */ unregister: function (api, dataZoomId) { var store = giveStore(api); zrUtil.each(store, function (record) { record.controller.dispose(); var dataZoomInfos = record.dataZoomInfos; if (dataZoomInfos[dataZoomId]) { delete dataZoomInfos[dataZoomId]; record.count--; } }); cleanStore(store); }, /** * @public */ shouldRecordRange: function (payload, dataZoomId) { if (payload && payload.type === 'dataZoom' && payload.batch) { for (var i = 0, len = payload.batch.length; i < len; i++) { if (payload.batch[i].dataZoomId === dataZoomId) { return false; } } } return true; }, /** * @public */ generateCoordId: function (coordModel) { return coordModel.type + '\\0_' + coordModel.id; } }; /** * Key: coordId, value: {dataZoomInfos: [], count, controller} * @type {Array.} */ function giveStore(api) { // Mount store on zrender instance, so that we do not // need to worry about dispose. var zr = api.getZr(); return zr[ATTR] || (zr[ATTR] = {}); } function createController(api, newRecord) { var controller = new RoamController(api.getZr()); controller.on('pan', curry(onPan, newRecord)); controller.on('zoom', curry(onZoom, newRecord)); return controller; } function cleanStore(store) { zrUtil.each(store, function (record, coordId) { if (!record.count) { record.controller.dispose(); delete store[coordId]; } }); } function onPan(record, dx, dy, oldX, oldY, newX, newY) { wrapAndDispatch(record, function (info) { return info.panGetRange(record.controller, dx, dy, oldX, oldY, newX, newY); }); } function onZoom(record, scale, mouseX, mouseY) { wrapAndDispatch(record, function (info) { return info.zoomGetRange(record.controller, scale, mouseX, mouseY); }); } function wrapAndDispatch(record, getRange) { var batch = []; zrUtil.each(record.dataZoomInfos, function (info) { var range = getRange(info); !info.disabled && range && batch.push({ dataZoomId: info.dataZoomId, start: range[0], end: range[1] }); }); record.dispatchAction(batch); } /** * This action will be throttled. */ function dispatchAction(api, batch) { api.dispatchAction({ type: 'dataZoom', batch: batch }); } /** * Merge roamController settings when multiple dataZooms share one roamController. */ function mergeControllerParams(dataZoomInfos) { var controlType; var opt = {}; var typePriority = { 'true': 2, 'move': 1, 'false': 0, 'undefined': -1 }; zrUtil.each(dataZoomInfos, function (dataZoomInfo) { var oneType = dataZoomInfo.disabled ? false : dataZoomInfo.zoomLock ? 'move' : true; typePriority[oneType] > typePriority[controlType] && (controlType = oneType); // Do not support that different 'shift'/'ctrl'/'alt' setting used in one coord sys. zrUtil.extend(opt, dataZoomInfo.roamControllerOpt); }); return { controlType: controlType, opt: opt }; } module.exports = roams; /***/ }), /* 382 */ /***/ (function(module, exports, __webpack_require__) { /** * @file Data zoom processor */ var echarts = __webpack_require__(1); echarts.registerProcessor(function (ecModel, api) { ecModel.eachComponent('dataZoom', function (dataZoomModel) { // We calculate window and reset axis here but not in model // init stage and not after action dispatch handler, because // reset should be called after seriesData.restoreData. dataZoomModel.eachTargetAxis(resetSingleAxis); // Caution: data zoom filtering is order sensitive when using // percent range and no min/max/scale set on axis. // For example, we have dataZoom definition: // [ // {xAxisIndex: 0, start: 30, end: 70}, // {yAxisIndex: 0, start: 20, end: 80} // ] // In this case, [20, 80] of y-dataZoom should be based on data // that have filtered by x-dataZoom using range of [30, 70], // but should not be based on full raw data. Thus sliding // x-dataZoom will change both ranges of xAxis and yAxis, // while sliding y-dataZoom will only change the range of yAxis. // So we should filter x-axis after reset x-axis immediately, // and then reset y-axis and filter y-axis. dataZoomModel.eachTargetAxis(filterSingleAxis); }); ecModel.eachComponent('dataZoom', function (dataZoomModel) { // Fullfill all of the range props so that user // is able to get them from chart.getOption(). var axisProxy = dataZoomModel.findRepresentativeAxisProxy(); var percentRange = axisProxy.getDataPercentWindow(); var valueRange = axisProxy.getDataValueWindow(); dataZoomModel.setRawRange({ start: percentRange[0], end: percentRange[1], startValue: valueRange[0], endValue: valueRange[1] }, true); }); }); function resetSingleAxis(dimNames, axisIndex, dataZoomModel) { dataZoomModel.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel); } function filterSingleAxis(dimNames, axisIndex, dataZoomModel) { dataZoomModel.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel); } /***/ }), /* 383 */ /***/ (function(module, exports, __webpack_require__) { /** * @file Data zoom action */ var zrUtil = __webpack_require__(4); var helper = __webpack_require__(374); var echarts = __webpack_require__(1); echarts.registerAction('dataZoom', function (payload, ecModel) { var linkedNodesFinder = helper.createLinkedNodesFinder( zrUtil.bind(ecModel.eachComponent, ecModel, 'dataZoom'), helper.eachAxisDim, function (model, dimNames) { return model.get(dimNames.axisIndex); } ); var effectedModels = []; ecModel.eachComponent( {mainType: 'dataZoom', query: payload}, function (model, index) { effectedModels.push.apply( effectedModels, linkedNodesFinder(model).nodes ); } ); zrUtil.each(effectedModels, function (dataZoomModel, index) { dataZoomModel.setRawRange({ start: payload.start, end: payload.end, startValue: payload.startValue, endValue: payload.endValue }); }); }); /***/ }), /* 384 */ /***/ (function(module, exports, __webpack_require__) { /** * visualMap component entry */ __webpack_require__(385); __webpack_require__(396); /***/ }), /* 385 */ /***/ (function(module, exports, __webpack_require__) { /** * DataZoom component entry */ __webpack_require__(1).registerPreprocessor( __webpack_require__(386) ); __webpack_require__(387); __webpack_require__(388); __webpack_require__(389); __webpack_require__(392); __webpack_require__(395); /***/ }), /* 386 */ /***/ (function(module, exports, __webpack_require__) { /** * @file VisualMap preprocessor */ var zrUtil = __webpack_require__(4); var each = zrUtil.each; module.exports = function (option) { var visualMap = option && option.visualMap; if (!zrUtil.isArray(visualMap)) { visualMap = visualMap ? [visualMap] : []; } each(visualMap, function (opt) { if (!opt) { return; } // rename splitList to pieces if (has(opt, 'splitList') && !has(opt, 'pieces')) { opt.pieces = opt.splitList; delete opt.splitList; } var pieces = opt.pieces; if (pieces && zrUtil.isArray(pieces)) { each(pieces, function (piece) { if (zrUtil.isObject(piece)) { if (has(piece, 'start') && !has(piece, 'min')) { piece.min = piece.start; } if (has(piece, 'end') && !has(piece, 'max')) { piece.max = piece.end; } } }); } }); }; function has(obj, name) { return obj && obj.hasOwnProperty && obj.hasOwnProperty(name); } /***/ }), /* 387 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(72).registerSubTypeDefaulter('visualMap', function (option) { // Compatible with ec2, when splitNumber === 0, continuous visualMap will be used. return ( !option.categories && ( !( option.pieces ? option.pieces.length > 0 : option.splitNumber > 0 ) || option.calculable ) ) ? 'continuous' : 'piecewise'; }); /***/ }), /* 388 */ /***/ (function(module, exports, __webpack_require__) { /** * @file Data range visual coding. */ var echarts = __webpack_require__(1); var visualSolution = __webpack_require__(357); var VisualMapping = __webpack_require__(206); var zrUtil = __webpack_require__(4); echarts.registerVisual(echarts.PRIORITY.VISUAL.COMPONENT, function (ecModel) { ecModel.eachComponent('visualMap', function (visualMapModel) { processSingleVisualMap(visualMapModel, ecModel); }); prepareVisualMeta(ecModel); }); function processSingleVisualMap(visualMapModel, ecModel) { visualMapModel.eachTargetSeries(function (seriesModel) { var data = seriesModel.getData(); visualSolution.applyVisual( visualMapModel.stateList, visualMapModel.targetVisuals, data, visualMapModel.getValueState, visualMapModel, visualMapModel.getDataDimension(data) ); }); } // Only support color. function prepareVisualMeta(ecModel) { ecModel.eachSeries(function (seriesModel) { var data = seriesModel.getData(); var visualMetaList = []; ecModel.eachComponent('visualMap', function (visualMapModel) { if (visualMapModel.isTargetSeries(seriesModel)) { var visualMeta = visualMapModel.getVisualMeta( zrUtil.bind(getColorVisual, null, seriesModel, visualMapModel) ) || {stops: [], outerColors: []}; visualMeta.dimension = visualMapModel.getDataDimension(data); visualMetaList.push(visualMeta); } }); // console.log(JSON.stringify(visualMetaList.map(a => a.stops))); seriesModel.getData().setVisual('visualMeta', visualMetaList); }); } // FIXME // performance and export for heatmap? // value can be Infinity or -Infinity function getColorVisual(seriesModel, visualMapModel, value, valueState) { var mappings = visualMapModel.targetVisuals[valueState]; var visualTypes = VisualMapping.prepareVisualTypes(mappings); var resultVisual = { color: seriesModel.getData().getVisual('color') // default color. }; for (var i = 0, len = visualTypes.length; i < len; i++) { var type = visualTypes[i]; var mapping = mappings[ type === 'opacity' ? '__alphaForOpacity' : type ]; mapping && mapping.applyVisual(value, getVisual, setVisual); } return resultVisual.color; function getVisual(key) { return resultVisual[key]; } function setVisual(key, value) { resultVisual[key] = value; } } /***/ }), /* 389 */ /***/ (function(module, exports, __webpack_require__) { /** * @file Data zoom model */ var VisualMapModel = __webpack_require__(390); var zrUtil = __webpack_require__(4); var numberUtil = __webpack_require__(7); // Constant var DEFAULT_BAR_BOUND = [20, 140]; var ContinuousModel = VisualMapModel.extend({ type: 'visualMap.continuous', /** * @protected */ defaultOption: { align: 'auto', // 'auto', 'left', 'right', 'top', 'bottom' calculable: false, // This prop effect default component type determine, // See echarts/component/visualMap/typeDefaulter. range: null, // selected range. In default case `range` is [min, max] // and can auto change along with modification of min max, // util use specifid a range. realtime: true, // Whether realtime update. itemHeight: null, // The length of the range control edge. itemWidth: null, // The length of the other side. hoverLink: true, // Enable hover highlight. hoverLinkDataSize: null,// The size of hovered data. hoverLinkOnHandle: null // Whether trigger hoverLink when hover handle. // If not specified, follow the value of `realtime`. }, /** * @override */ optionUpdated: function (newOption, isInit) { ContinuousModel.superApply(this, 'optionUpdated', arguments); this.resetExtent(); this.resetVisual(function (mappingOption) { mappingOption.mappingMethod = 'linear'; mappingOption.dataExtent = this.getExtent(); }); this._resetRange(); }, /** * @protected * @override */ resetItemSize: function () { ContinuousModel.superApply(this, 'resetItemSize', arguments); var itemSize = this.itemSize; this._orient === 'horizontal' && itemSize.reverse(); (itemSize[0] == null || isNaN(itemSize[0])) && (itemSize[0] = DEFAULT_BAR_BOUND[0]); (itemSize[1] == null || isNaN(itemSize[1])) && (itemSize[1] = DEFAULT_BAR_BOUND[1]); }, /** * @private */ _resetRange: function () { var dataExtent = this.getExtent(); var range = this.option.range; if (!range || range.auto) { // `range` should always be array (so we dont use other // value like 'auto') for user-friend. (consider getOption). dataExtent.auto = 1; this.option.range = dataExtent; } else if (zrUtil.isArray(range)) { if (range[0] > range[1]) { range.reverse(); } range[0] = Math.max(range[0], dataExtent[0]); range[1] = Math.min(range[1], dataExtent[1]); } }, /** * @protected * @override */ completeVisualOption: function () { VisualMapModel.prototype.completeVisualOption.apply(this, arguments); zrUtil.each(this.stateList, function (state) { var symbolSize = this.option.controller[state].symbolSize; if (symbolSize && symbolSize[0] !== symbolSize[1]) { symbolSize[0] = 0; // For good looking. } }, this); }, /** * @override */ setSelected: function (selected) { this.option.range = selected.slice(); this._resetRange(); }, /** * @public */ getSelected: function () { var dataExtent = this.getExtent(); var dataInterval = numberUtil.asc( (this.get('range') || []).slice() ); // Clamp dataInterval[0] > dataExtent[1] && (dataInterval[0] = dataExtent[1]); dataInterval[1] > dataExtent[1] && (dataInterval[1] = dataExtent[1]); dataInterval[0] < dataExtent[0] && (dataInterval[0] = dataExtent[0]); dataInterval[1] < dataExtent[0] && (dataInterval[1] = dataExtent[0]); return dataInterval; }, /** * @override */ getValueState: function (value) { var range = this.option.range; var dataExtent = this.getExtent(); // When range[0] === dataExtent[0], any value larger than dataExtent[0] maps to 'inRange'. // range[1] is processed likewise. return ( (range[0] interval[1]) { console.warn( 'Piece ' + index + 'is illegal: ' + interval + ' lower bound should not greater then uppper bound.' ); } } if (interval[0] === interval[1] && close[0] && close[1]) { // Consider: [{min: 5, max: 5, visual: {...}}, {min: 0, max: 5}], // we use value to lift the priority when min === max item.value = interval[0]; } } item.visual = VisualMapping.retrieveVisuals(pieceListItem); pieceList.push(item); }, this); // See \"Order Rule\". normalizeReverse(thisOption, pieceList); // Only pieces reformIntervals(pieceList); zrUtil.each(pieceList, function (piece) { var close = piece.close; var edgeSymbols = [['', '≥'][close[0]]]; piece.text = piece.text || this.formatValueText( piece.value != null ? piece.value : piece.interval, false, edgeSymbols ); }, this); } }; function normalizeReverse(thisOption, pieceList) { var inverse = thisOption.inverse; if (thisOption.orient === 'vertical' ? !inverse : inverse) { pieceList.reverse(); } } module.exports = PiecewiseModel; /***/ }), /* 398 */ /***/ (function(module, exports, __webpack_require__) { var VisualMapView = __webpack_require__(393); var zrUtil = __webpack_require__(4); var graphic = __webpack_require__(20); var symbolCreators = __webpack_require__(114); var layout = __webpack_require__(74); var helper = __webpack_require__(394); var PiecewiseVisualMapView = VisualMapView.extend({ type: 'visualMap.piecewise', /** * @protected * @override */ doRender: function () { var thisGroup = this.group; thisGroup.removeAll(); var visualMapModel = this.visualMapModel; var textGap = visualMapModel.get('textGap'); var textStyleModel = visualMapModel.textStyleModel; var textFont = textStyleModel.getFont(); var textFill = textStyleModel.getTextColor(); var itemAlign = this._getItemAlign(); var itemSize = visualMapModel.itemSize; var viewData = this._getViewData(); var endsText = viewData.endsText; var showLabel = zrUtil.retrieve(visualMapModel.get('showLabel', true), !endsText); endsText && this._renderEndsText( thisGroup, endsText[0], itemSize, showLabel, itemAlign ); zrUtil.each(viewData.viewPieceList, renderItem, this); endsText && this._renderEndsText( thisGroup, endsText[1], itemSize, showLabel, itemAlign ); layout.box( visualMapModel.get('orient'), thisGroup, visualMapModel.get('itemGap') ); this.renderBackground(thisGroup); this.positionGroup(thisGroup); function renderItem(item) { var piece = item.piece; var itemGroup = new graphic.Group(); itemGroup.onclick = zrUtil.bind(this._onItemClick, this, piece); this._enableHoverLink(itemGroup, item.indexInModelPieceList); var representValue = visualMapModel.getRepresentValue(piece); this._createItemSymbol( itemGroup, representValue, [0, 0, itemSize[0], itemSize[1]] ); if (showLabel) { var visualState = this.visualMapModel.getValueState(representValue); itemGroup.add(new graphic.Text({ style: { x: itemAlign === 'right' ? -textGap : itemSize[0] + textGap, y: itemSize[1] / 2, text: piece.text, textVerticalAlign: 'middle', textAlign: itemAlign, textFont: textFont, textFill: textFill, opacity: visualState === 'outOfRange' ? 0.5 : 1 } })); } thisGroup.add(itemGroup); } }, /** * @private */ _enableHoverLink: function (itemGroup, pieceIndex) { itemGroup .on('mouseover', zrUtil.bind(onHoverLink, this, 'highlight')) .on('mouseout', zrUtil.bind(onHoverLink, this, 'downplay')); function onHoverLink(method) { var visualMapModel = this.visualMapModel; visualMapModel.option.hoverLink && this.api.dispatchAction({ type: method, batch: helper.convertDataIndex( visualMapModel.findTargetDataIndices(pieceIndex) ) }); } }, /** * @private */ _getItemAlign: function () { var visualMapModel = this.visualMapModel; var modelOption = visualMapModel.option; if (modelOption.orient === 'vertical') { return helper.getItemAlign( visualMapModel, this.api, visualMapModel.itemSize ); } else { // horizontal, most case left unless specifying right. var align = modelOption.align; if (!align || align === 'auto') { align = 'left'; } return align; } }, /** * @private */ _renderEndsText: function (group, text, itemSize, showLabel, itemAlign) { if (!text) { return; } var itemGroup = new graphic.Group(); var textStyleModel = this.visualMapModel.textStyleModel; itemGroup.add(new graphic.Text({ style: { x: showLabel ? (itemAlign === 'right' ? itemSize[0] : 0) : itemSize[0] / 2, y: itemSize[1] / 2, textVerticalAlign: 'middle', textAlign: showLabel ? itemAlign : 'center', text: text, textFont: textStyleModel.getFont(), textFill: textStyleModel.getTextColor() } })); group.add(itemGroup); }, /** * @private * @return {Object} {peiceList, endsText} The order is the same as screen pixel order. */ _getViewData: function () { var visualMapModel = this.visualMapModel; var viewPieceList = zrUtil.map(visualMapModel.getPieceList(), function (piece, index) { return {piece: piece, indexInModelPieceList: index}; }); var endsText = visualMapModel.get('text'); // Consider orient and inverse. var orient = visualMapModel.get('orient'); var inverse = visualMapModel.get('inverse'); // Order of model pieceList is always [low, ..., high] if (orient === 'horizontal' ? inverse : !inverse) { viewPieceList.reverse(); } // Origin order of endsText is [high, low] else if (endsText) { endsText = endsText.slice().reverse(); } return {viewPieceList: viewPieceList, endsText: endsText}; }, /** * @private */ _createItemSymbol: function (group, representValue, shapeParam) { group.add(symbolCreators.createSymbol( this.getControllerVisual(representValue, 'symbol'), shapeParam[0], shapeParam[1], shapeParam[2], shapeParam[3], this.getControllerVisual(representValue, 'color') )); }, /** * @private */ _onItemClick: function (piece) { var visualMapModel = this.visualMapModel; var option = visualMapModel.option; var selected = zrUtil.clone(option.selected); var newKey = visualMapModel.getSelectedMapKey(piece); if (option.selectedMode === 'single') { selected[newKey] = true; zrUtil.each(selected, function (o, key) { selected[key] = key === newKey; }); } else { selected[newKey] = !selected[newKey]; } this.api.dispatchAction({ type: 'selectDataRange', from: this.uid, visualMapId: this.visualMapModel.id, selected: selected }); } }); module.exports = PiecewiseVisualMapView; /***/ }), /* 399 */ /***/ (function(module, exports, __webpack_require__) { // HINT Markpoint can't be used too much __webpack_require__(400); __webpack_require__(402); __webpack_require__(1).registerPreprocessor(function (opt) { // Make sure markPoint component is enabled opt.markPoint = opt.markPoint || {}; }); /***/ }), /* 400 */ /***/ (function(module, exports, __webpack_require__) { module.exports = __webpack_require__(401).extend({ type: 'markPoint', defaultOption: { zlevel: 0, z: 5, symbol: 'pin', symbolSize: 50, //symbolRotate: 0, //symbolOffset: [0, 0] tooltip: { trigger: 'item' }, label: { normal: { show: true, position: 'inside' }, emphasis: { show: true } }, itemStyle: { normal: { borderWidth: 2 } } } }); /***/ }), /* 401 */ /***/ (function(module, exports, __webpack_require__) { var modelUtil = __webpack_require__(5); var zrUtil = __webpack_require__(4); var env = __webpack_require__(2); var formatUtil = __webpack_require__(6); var addCommas = formatUtil.addCommas; var encodeHTML = formatUtil.encodeHTML; function fillLabel(opt) { modelUtil.defaultEmphasis(opt.label, ['show']); } var MarkerModel = __webpack_require__(1).extendComponentModel({ type: 'marker', dependencies: ['series', 'grid', 'polar', 'geo'], /** * @overrite */ init: function (option, parentModel, ecModel, extraOpt) { if (true) { if (this.type === 'marker') { throw new Error('Marker component is abstract component. Use markLine, markPoint, markArea instead.'); } } this.mergeDefaultAndTheme(option, ecModel); this.mergeOption(option, ecModel, extraOpt.createdBySelf, true); }, /** * @return {boolean} */ isAnimationEnabled: function () { if (env.node) { return false; } var hostSeries = this.__hostSeries; return this.getShallow('animation') && hostSeries && hostSeries.isAnimationEnabled(); }, mergeOption: function (newOpt, ecModel, createdBySelf, isInit) { var MarkerModel = this.constructor; var modelPropName = this.mainType + 'Model'; if (!createdBySelf) { ecModel.eachSeries(function (seriesModel) { var markerOpt = seriesModel.get(this.mainType); var markerModel = seriesModel[modelPropName]; if (!markerOpt || !markerOpt.data) { seriesModel[modelPropName] = null; return; } if (!markerModel) { if (isInit) { // Default label emphasis `position` and `show` fillLabel(markerOpt); } zrUtil.each(markerOpt.data, function (item) { // FIXME Overwrite fillLabel method ? if (item instanceof Array) { fillLabel(item[0]); fillLabel(item[1]); } else { fillLabel(item); } }); markerModel = new MarkerModel( markerOpt, this, ecModel ); zrUtil.extend(markerModel, { mainType: this.mainType, // Use the same series index and name seriesIndex: seriesModel.seriesIndex, name: seriesModel.name, createdBySelf: true }); markerModel.__hostSeries = seriesModel; } else { markerModel.mergeOption(markerOpt, ecModel, true); } seriesModel[modelPropName] = markerModel; }, this); } }, formatTooltip: function (dataIndex) { var data = this.getData(); var value = this.getRawValue(dataIndex); var formattedValue = zrUtil.isArray(value) ? zrUtil.map(value, addCommas).join(', ') : addCommas(value); var name = data.getName(dataIndex); var html = encodeHTML(this.name); if (value != null || name) { html += ''; } if (name) { html += encodeHTML(name); if (value != null) { html += ' : '; } } if (value != null) { html += encodeHTML(formattedValue); } return html; }, getData: function () { return this._data; }, setData: function (data) { this._data = data; } }); zrUtil.mixin(MarkerModel, modelUtil.dataFormatMixin); module.exports = MarkerModel; /***/ }), /* 402 */ /***/ (function(module, exports, __webpack_require__) { var SymbolDraw = __webpack_require__(119); var zrUtil = __webpack_require__(4); var numberUtil = __webpack_require__(7); var List = __webpack_require__(101); var markerHelper = __webpack_require__(403); function updateMarkerLayout(mpData, seriesModel, api) { var coordSys = seriesModel.coordinateSystem; mpData.each(function (idx) { var itemModel = mpData.getItemModel(idx); var point; var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth()); var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight()); if (!isNaN(xPx) && !isNaN(yPx)) { point = [xPx, yPx]; } // Chart like bar may have there own marker positioning logic else if (seriesModel.getMarkerPosition) { // Use the getMarkerPoisition point = seriesModel.getMarkerPosition( mpData.getValues(mpData.dimensions, idx) ); } else if (coordSys) { var x = mpData.get(coordSys.dimensions[0], idx); var y = mpData.get(coordSys.dimensions[1], idx); point = coordSys.dataToPoint([x, y]); } // Use x, y if has any if (!isNaN(xPx)) { point[0] = xPx; } if (!isNaN(yPx)) { point[1] = yPx; } mpData.setItemLayout(idx, point); }); } __webpack_require__(404).extend({ type: 'markPoint', updateLayout: function (markPointModel, ecModel, api) { ecModel.eachSeries(function (seriesModel) { var mpModel = seriesModel.markPointModel; if (mpModel) { updateMarkerLayout(mpModel.getData(), seriesModel, api); this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel); } }, this); }, renderSeries: function (seriesModel, mpModel, ecModel, api) { var coordSys = seriesModel.coordinateSystem; var seriesId = seriesModel.id; var seriesData = seriesModel.getData(); var symbolDrawMap = this.markerGroupMap; var symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw()); var mpData = createList(coordSys, seriesModel, mpModel); // FIXME mpModel.setData(mpData); updateMarkerLayout(mpModel.getData(), seriesModel, api); mpData.each(function (idx) { var itemModel = mpData.getItemModel(idx); var symbolSize = itemModel.getShallow('symbolSize'); if (typeof symbolSize === 'function') { // FIXME 这里不兼容 ECharts 2.x，2.x 貌似参数是整个数据？ symbolSize = symbolSize( mpModel.getRawValue(idx), mpModel.getDataParams(idx) ); } mpData.setItemVisual(idx, { symbolSize: symbolSize, color: itemModel.get('itemStyle.normal.color') || seriesData.getVisual('color'), symbol: itemModel.getShallow('symbol') }); }); // TODO Text are wrong symbolDraw.updateData(mpData); this.group.add(symbolDraw.group); // Set host model for tooltip // FIXME mpData.eachItemGraphicEl(function (el) { el.traverse(function (child) { child.dataModel = mpModel; }); }); symbolDraw.__keep = true; symbolDraw.group.silent = mpModel.get('silent') || seriesModel.get('silent'); } }); /** * @inner * @param {module:echarts/coord/*} [coordSys] * @param {module:echarts/model/Series} seriesModel * @param {module:echarts/model/Model} mpModel */ function createList(coordSys, seriesModel, mpModel) { var coordDimsInfos; if (coordSys) { coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) { var info = seriesModel.getData().getDimensionInfo( seriesModel.coordDimToDataDim(coordDim)[0] ) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys info.name = coordDim; return info; }); } else { coordDimsInfos =[{ name: 'value', type: 'float' }]; } var mpData = new List(coordDimsInfos, mpModel); var dataOpt = zrUtil.map(mpModel.get('data'), zrUtil.curry( markerHelper.dataTransform, seriesModel )); if (coordSys) { dataOpt = zrUtil.filter( dataOpt, zrUtil.curry(markerHelper.dataFilter, coordSys) ); } mpData.initData(dataOpt, null, coordSys ? markerHelper.dimValueGetter : function (item) { return item.value; } ); return mpData; } /***/ }), /* 403 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); var numberUtil = __webpack_require__(7); var indexOf = zrUtil.indexOf; function hasXOrY(item) { return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y))); } function hasXAndY(item) { return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y)); } function getPrecision(data, valueAxisDim, dataIndex) { var precision = -1; do { precision = Math.max( numberUtil.getPrecision(data.get( valueAxisDim, dataIndex )), precision ); data = data.stackedOn; } while (data); return precision; } function markerTypeCalculatorWithExtent( mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex ) { var coordArr = []; var value = numCalculate(data, targetDataDim, mlType); var dataIndex = data.indicesOfNearest(targetDataDim, value, true)[0]; coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex, true); coordArr[targetCoordIndex] = data.get(targetDataDim, dataIndex, true); var precision = getPrecision(data, targetDataDim, dataIndex); precision = Math.min(precision, 20); if (precision >= 0) { coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision); } return coordArr; } var curry = zrUtil.curry; // TODO Specified percent var markerTypeCalculator = { /** * @method * @param {module:echarts/data/List} data * @param {string} baseAxisDim * @param {string} valueAxisDim */ min: curry(markerTypeCalculatorWithExtent, 'min'), /** * @method * @param {module:echarts/data/List} data * @param {string} baseAxisDim * @param {string} valueAxisDim */ max: curry(markerTypeCalculatorWithExtent, 'max'), /** * @method * @param {module:echarts/data/List} data * @param {string} baseAxisDim * @param {string} valueAxisDim */ average: curry(markerTypeCalculatorWithExtent, 'average') }; /** * Transform markPoint data item to format used in List by do the following * 1. Calculate statistic like `max`, `min`, `average` * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array * @param {module:echarts/model/Series} seriesModel * @param {module:echarts/coord/*} [coordSys] * @param {Object} item * @return {Object} */ var dataTransform = function (seriesModel, item) { var data = seriesModel.getData(); var coordSys = seriesModel.coordinateSystem; // 1. If not specify the position with pixel directly // 2. If `coord` is not a data array. Which uses `xAxis`, // `yAxis` to specify the coord on each dimension // parseFloat first because item.x and item.y can be percent string like '20%' if (item && !hasXAndY(item) && !zrUtil.isArray(item.coord) && coordSys) { var dims = coordSys.dimensions; var axisInfo = getAxisInfo(item, data, coordSys, seriesModel); // Clone the option // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value item = zrUtil.clone(item); if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis ) { var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim); var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim); item.coord = markerTypeCalculator[item.type]( data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex ); // Force to use the value of calculated value. item.value = item.coord[targetCoordIndex]; } else { // FIXME Only has one of xAxis and yAxis. var coord = [ item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis ]; // Each coord support max, min, average for (var i = 0; i < 2; i++) { if (markerTypeCalculator[coord[i]]) { var dataDim = seriesModel.coordDimToDataDim(dims[i])[0]; coord[i] = numCalculate(data, dataDim, coord[i]); } } item.coord = coord; } } return item; }; var getAxisInfo = function (item, data, coordSys, seriesModel) { var ret = {}; if (item.valueIndex != null || item.valueDim != null) { ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim; ret.valueAxis = coordSys.getAxis(seriesModel.dataDimToCoordDim(ret.valueDataDim)); ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis); ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0]; } else { ret.baseAxis = seriesModel.getBaseAxis(); ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis); ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0]; ret.valueDataDim = seriesModel.coordDimToDataDim(ret.valueAxis.dim)[0]; } return ret; }; /** * Filter data which is out of coordinateSystem range * [dataFilter description] * @param {module:echarts/coord/*} [coordSys] * @param {Object} item * @return {boolean} */ var dataFilter = function (coordSys, item) { // Alwalys return true if there is no coordSys return (coordSys && coordSys.containData && item.coord && !hasXOrY(item)) ? coordSys.containData(item.coord) : true; }; var dimValueGetter = function (item, dimName, dataIndex, dimIndex) { // x, y, radius, angle if (dimIndex < 2) { return item.coord && item.coord[dimIndex]; } return item.value; }; var numCalculate = function (data, valueDataDim, type) { if (type === 'average') { var sum = 0; var count = 0; data.each(valueDataDim, function (val, idx) { if (!isNaN(val)) { sum += val; count++; } }, true); return sum / count; } else { return data.getDataExtent(valueDataDim, true)[type === 'max' ? 1 : 0]; } }; module.exports = { dataTransform: dataTransform, dataFilter: dataFilter, dimValueGetter: dimValueGetter, getAxisInfo: getAxisInfo, numCalculate: numCalculate }; /***/ }), /* 404 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); module.exports = __webpack_require__(1).extendComponentView({ type: 'marker', init: function () { /** * Markline grouped by series * @private * @type {module:zrender/core/util.HashMap} */ this.markerGroupMap = zrUtil.createHashMap(); }, render: function (markerModel, ecModel, api) { var markerGroupMap = this.markerGroupMap; markerGroupMap.each(function (item) { item.__keep = false; }); var markerModelKey = this.type + 'Model'; ecModel.eachSeries(function (seriesModel) { var markerModel = seriesModel[markerModelKey]; markerModel && this.renderSeries(seriesModel, markerModel, ecModel, api); }, this); markerGroupMap.each(function (item) { !item.__keep && this.group.remove(item.group); }, this); }, renderSeries: function () {} }); /***/ }), /* 405 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(406); __webpack_require__(407); __webpack_require__(1).registerPreprocessor(function (opt) { // Make sure markLine component is enabled opt.markLine = opt.markLine || {}; }); /***/ }), /* 406 */ /***/ (function(module, exports, __webpack_require__) { module.exports = __webpack_require__(401).extend({ type: 'markLine', defaultOption: { zlevel: 0, z: 5, symbol: ['circle', 'arrow'], symbolSize: [8, 16], //symbolRotate: 0, precision: 2, tooltip: { trigger: 'item' }, label: { normal: { show: true, position: 'end' }, emphasis: { show: true } }, lineStyle: { normal: { type: 'dashed' }, emphasis: { width: 3 } }, animationEasing: 'linear' } }); /***/ }), /* 407 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); var List = __webpack_require__(101); var numberUtil = __webpack_require__(7); var markerHelper = __webpack_require__(403); var LineDraw = __webpack_require__(213); var markLineTransform = function (seriesModel, coordSys, mlModel, item) { var data = seriesModel.getData(); // Special type markLine like 'min', 'max', 'average' var mlType = item.type; if (!zrUtil.isArray(item) && ( mlType === 'min' || mlType === 'max' || mlType === 'average' // In case // data: [{ // yAxis: 10 // }] || (item.xAxis != null || item.yAxis != null) ) ) { var valueAxis; var valueDataDim; var value; if (item.yAxis != null || item.xAxis != null) { valueDataDim = item.yAxis != null ? 'y' : 'x'; valueAxis = coordSys.getAxis(valueDataDim); value = zrUtil.retrieve(item.yAxis, item.xAxis); } else { var axisInfo = markerHelper.getAxisInfo(item, data, coordSys, seriesModel); valueDataDim = axisInfo.valueDataDim; valueAxis = axisInfo.valueAxis; value = markerHelper.numCalculate(data, valueDataDim, mlType); } var valueIndex = valueDataDim === 'x' ? 0 : 1; var baseIndex = 1 - valueIndex; var mlFrom = zrUtil.clone(item); var mlTo = {}; mlFrom.type = null; mlFrom.coord = []; mlTo.coord = []; mlFrom.coord[baseIndex] = -Infinity; mlTo.coord[baseIndex] = Infinity; var precision = mlModel.get('precision'); if (precision >= 0 && typeof value === 'number') { value = +value.toFixed(Math.min(precision, 20)); } mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value; item = [mlFrom, mlTo, { // Extra option for tooltip and label type: mlType, valueIndex: item.valueIndex, // Force to use the value of calculated value. value: value }]; } item = [ markerHelper.dataTransform(seriesModel, item[0]), markerHelper.dataTransform(seriesModel, item[1]), zrUtil.extend({}, item[2]) ]; // Avoid line data type is extended by from(to) data type item[2].type = item[2].type || ''; // Merge from option and to option into line option zrUtil.merge(item[2], item[0]); zrUtil.merge(item[2], item[1]); return item; }; function isInifinity(val) { return !isNaN(val) && !isFinite(val); } // If a markLine has one dim function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) { var otherDimIndex = 1 - dimIndex; var dimName = coordSys.dimensions[dimIndex]; return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]); } function markLineFilter(coordSys, item) { if (coordSys.type === 'cartesian2d') { var fromCoord = item[0].coord; var toCoord = item[1].coord; // In case // { // markLine: { // data: [{ yAxis: 2 }] // } // } if ( fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys)) ) { return true; } } return markerHelper.dataFilter(coordSys, item[0]) && markerHelper.dataFilter(coordSys, item[1]); } function updateSingleMarkerEndLayout( data, idx, isFrom, seriesModel, api ) { var coordSys = seriesModel.coordinateSystem; var itemModel = data.getItemModel(idx); var point; var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth()); var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight()); if (!isNaN(xPx) && !isNaN(yPx)) { point = [xPx, yPx]; } else { // Chart like bar may have there own marker positioning logic if (seriesModel.getMarkerPosition) { // Use the getMarkerPoisition point = seriesModel.getMarkerPosition( data.getValues(data.dimensions, idx) ); } else { var dims = coordSys.dimensions; var x = data.get(dims[0], idx); var y = data.get(dims[1], idx); point = coordSys.dataToPoint([x, y]); } // Expand line to the edge of grid if value on one axis is Inifnity // In case // markLine: { // data: [{ // yAxis: 2 // // or // type: 'average' // }] // } if (coordSys.type === 'cartesian2d') { var xAxis = coordSys.getAxis('x'); var yAxis = coordSys.getAxis('y'); var dims = coordSys.dimensions; if (isInifinity(data.get(dims[0], idx))) { point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]); } else if (isInifinity(data.get(dims[1], idx))) { point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]); } } // Use x, y if has any if (!isNaN(xPx)) { point[0] = xPx; } if (!isNaN(yPx)) { point[1] = yPx; } } data.setItemLayout(idx, point); } __webpack_require__(404).extend({ type: 'markLine', updateLayout: function (markLineModel, ecModel, api) { ecModel.eachSeries(function (seriesModel) { var mlModel = seriesModel.markLineModel; if (mlModel) { var mlData = mlModel.getData(); var fromData = mlModel.__from; var toData = mlModel.__to; // Update visual and layout of from symbol and to symbol fromData.each(function (idx) { updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api); updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api); }); // Update layout of line mlData.each(function (idx) { mlData.setItemLayout(idx, [ fromData.getItemLayout(idx), toData.getItemLayout(idx) ]); }); this.markerGroupMap.get(seriesModel.id).updateLayout(); } }, this); }, renderSeries: function (seriesModel, mlModel, ecModel, api) { var coordSys = seriesModel.coordinateSystem; var seriesId = seriesModel.id; var seriesData = seriesModel.getData(); var lineDrawMap = this.markerGroupMap; var lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw()); this.group.add(lineDraw.group); var mlData = createList(coordSys, seriesModel, mlModel); var fromData = mlData.from; var toData = mlData.to; var lineData = mlData.line; mlModel.__from = fromData; mlModel.__to = toData; // Line data for tooltip and formatter mlModel.setData(lineData); var symbolType = mlModel.get('symbol'); var symbolSize = mlModel.get('symbolSize'); if (!zrUtil.isArray(symbolType)) { symbolType = [symbolType, symbolType]; } if (typeof symbolSize === 'number') { symbolSize = [symbolSize, symbolSize]; } // Update visual and layout of from symbol and to symbol mlData.from.each(function (idx) { updateDataVisualAndLayout(fromData, idx, true); updateDataVisualAndLayout(toData, idx, false); }); // Update visual and layout of line lineData.each(function (idx) { var lineColor = lineData.getItemModel(idx).get('lineStyle.normal.color'); lineData.setItemVisual(idx, { color: lineColor || fromData.getItemVisual(idx, 'color') }); lineData.setItemLayout(idx, [ fromData.getItemLayout(idx), toData.getItemLayout(idx) ]); lineData.setItemVisual(idx, { 'fromSymbolSize': fromData.getItemVisual(idx, 'symbolSize'), 'fromSymbol': fromData.getItemVisual(idx, 'symbol'), 'toSymbolSize': toData.getItemVisual(idx, 'symbolSize'), 'toSymbol': toData.getItemVisual(idx, 'symbol') }); }); lineDraw.updateData(lineData); // Set host model for tooltip // FIXME mlData.line.eachItemGraphicEl(function (el, idx) { el.traverse(function (child) { child.dataModel = mlModel; }); }); function updateDataVisualAndLayout(data, idx, isFrom) { var itemModel = data.getItemModel(idx); updateSingleMarkerEndLayout( data, idx, isFrom, seriesModel, api ); data.setItemVisual(idx, { symbolSize: itemModel.get('symbolSize') || symbolSize[isFrom ? 0 : 1], symbol: itemModel.get('symbol', true) || symbolType[isFrom ? 0 : 1], color: itemModel.get('itemStyle.normal.color') || seriesData.getVisual('color') }); } lineDraw.__keep = true; lineDraw.group.silent = mlModel.get('silent') || seriesModel.get('silent'); } }); /** * @inner * @param {module:echarts/coord/*} coordSys * @param {module:echarts/model/Series} seriesModel * @param {module:echarts/model/Model} mpModel */ function createList(coordSys, seriesModel, mlModel) { var coordDimsInfos; if (coordSys) { coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) { var info = seriesModel.getData().getDimensionInfo( seriesModel.coordDimToDataDim(coordDim)[0] ) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys info.name = coordDim; return info; }); } else { coordDimsInfos =[{ name: 'value', type: 'float' }]; } var fromData = new List(coordDimsInfos, mlModel); var toData = new List(coordDimsInfos, mlModel); // No dimensions var lineData = new List([], mlModel); var optData = zrUtil.map(mlModel.get('data'), zrUtil.curry( markLineTransform, seriesModel, coordSys, mlModel )); if (coordSys) { optData = zrUtil.filter( optData, zrUtil.curry(markLineFilter, coordSys) ); } var dimValueGetter = coordSys ? markerHelper.dimValueGetter : function (item) { return item.value; }; fromData.initData( zrUtil.map(optData, function (item) { return item[0]; }), null, dimValueGetter ); toData.initData( zrUtil.map(optData, function (item) { return item[1]; }), null, dimValueGetter ); lineData.initData( zrUtil.map(optData, function (item) { return item[2]; }) ); lineData.hasItemOption = true; return { from: fromData, to: toData, line: lineData }; } /***/ }), /* 408 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(409); __webpack_require__(410); __webpack_require__(1).registerPreprocessor(function (opt) { // Make sure markArea component is enabled opt.markArea = opt.markArea || {}; }); /***/ }), /* 409 */ /***/ (function(module, exports, __webpack_require__) { module.exports = __webpack_require__(401).extend({ type: 'markArea', defaultOption: { zlevel: 0, // PENDING z: 1, tooltip: { trigger: 'item' }, // markArea should fixed on the coordinate system animation: false, label: { normal: { show: true, position: 'top' }, emphasis: { show: true, position: 'top' } }, itemStyle: { normal: { // color and borderColor default to use color from series // color: 'auto' // borderColor: 'auto' borderWidth: 0 } } } }); /***/ }), /* 410 */ /***/ (function(module, exports, __webpack_require__) { // TODO Better on polar var zrUtil = __webpack_require__(4); var List = __webpack_require__(101); var numberUtil = __webpack_require__(7); var graphic = __webpack_require__(20); var colorUtil = __webpack_require__(33); var markerHelper = __webpack_require__(403); var markAreaTransform = function (seriesModel, coordSys, maModel, item) { var lt = markerHelper.dataTransform(seriesModel, item[0]); var rb = markerHelper.dataTransform(seriesModel, item[1]); var retrieve = zrUtil.retrieve; // FIXME make sure lt is less than rb var ltCoord = lt.coord; var rbCoord = rb.coord; ltCoord[0] = retrieve(ltCoord[0], -Infinity); ltCoord[1] = retrieve(ltCoord[1], -Infinity); rbCoord[0] = retrieve(rbCoord[0], Infinity); rbCoord[1] = retrieve(rbCoord[1], Infinity); // Merge option into one var result = zrUtil.mergeAll([{}, lt, rb]); result.coord = [ lt.coord, rb.coord ]; result.x0 = lt.x; result.y0 = lt.y; result.x1 = rb.x; result.y1 = rb.y; return result; }; function isInifinity(val) { return !isNaN(val) && !isFinite(val); } // If a markArea has one dim function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) { var otherDimIndex = 1 - dimIndex; return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]); } function markAreaFilter(coordSys, item) { var fromCoord = item.coord[0]; var toCoord = item.coord[1]; if (coordSys.type === 'cartesian2d') { // In case // { // markArea: { // data: [{ yAxis: 2 }] // } // } if ( fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys)) ) { return true; } } return markerHelper.dataFilter(coordSys, { coord: fromCoord, x: item.x0, y: item.y0 }) || markerHelper.dataFilter(coordSys, { coord: toCoord, x: item.x1, y: item.y1 }); } // dims can be ['x0', 'y0'], ['x1', 'y1'], ['x0', 'y1'], ['x1', 'y0'] function getSingleMarkerEndPoint(data, idx, dims, seriesModel, api) { var coordSys = seriesModel.coordinateSystem; var itemModel = data.getItemModel(idx); var point; var xPx = numberUtil.parsePercent(itemModel.get(dims[0]), api.getWidth()); var yPx = numberUtil.parsePercent(itemModel.get(dims[1]), api.getHeight()); if (!isNaN(xPx) && !isNaN(yPx)) { point = [xPx, yPx]; } else { // Chart like bar may have there own marker positioning logic if (seriesModel.getMarkerPosition) { // Use the getMarkerPoisition point = seriesModel.getMarkerPosition( data.getValues(dims, idx) ); } else { var x = data.get(dims[0], idx); var y = data.get(dims[1], idx); point = coordSys.dataToPoint([x, y], true); } if (coordSys.type === 'cartesian2d') { var xAxis = coordSys.getAxis('x'); var yAxis = coordSys.getAxis('y'); var x = data.get(dims[0], idx); var y = data.get(dims[1], idx); if (isInifinity(x)) { point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === 'x0' ? 0 : 1]); } else if (isInifinity(y)) { point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === 'y0' ? 0 : 1]); } } // Use x, y if has any if (!isNaN(xPx)) { point[0] = xPx; } if (!isNaN(yPx)) { point[1] = yPx; } } return point; } var dimPermutations = [['x0', 'y0'], ['x1', 'y0'], ['x1', 'y1'], ['x0', 'y1']]; __webpack_require__(404).extend({ type: 'markArea', updateLayout: function (markAreaModel, ecModel, api) { ecModel.eachSeries(function (seriesModel) { var maModel = seriesModel.markAreaModel; if (maModel) { var areaData = maModel.getData(); areaData.each(function (idx) { var points = zrUtil.map(dimPermutations, function (dim) { return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api); }); // Layout areaData.setItemLayout(idx, points); var el = areaData.getItemGraphicEl(idx); el.setShape('points', points); }); } }, this); }, renderSeries: function (seriesModel, maModel, ecModel, api) { var coordSys = seriesModel.coordinateSystem; var seriesName = seriesModel.name; var seriesData = seriesModel.getData(); var areaGroupMap = this.markerGroupMap; var polygonGroup = areaGroupMap.get(seriesName) || areaGroupMap.set(seriesName, {group: new graphic.Group()}); this.group.add(polygonGroup.group); polygonGroup.__keep = true; var areaData = createList(coordSys, seriesModel, maModel); // Line data for tooltip and formatter maModel.setData(areaData); // Update visual and layout of line areaData.each(function (idx) { // Layout areaData.setItemLayout(idx, zrUtil.map(dimPermutations, function (dim) { return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api); })); // Visual areaData.setItemVisual(idx, { color: seriesData.getVisual('color') }); }); areaData.diff(polygonGroup.__data) .add(function (idx) { var polygon = new graphic.Polygon({ shape: { points: areaData.getItemLayout(idx) } }); areaData.setItemGraphicEl(idx, polygon); polygonGroup.group.add(polygon); }) .update(function (newIdx, oldIdx) { var polygon = polygonGroup.__data.getItemGraphicEl(oldIdx); graphic.updateProps(polygon, { shape: { points: areaData.getItemLayout(newIdx) } }, maModel, newIdx); polygonGroup.group.add(polygon); areaData.setItemGraphicEl(newIdx, polygon); }) .remove(function (idx) { var polygon = polygonGroup.__data.getItemGraphicEl(idx); polygonGroup.group.remove(polygon); }) .execute(); areaData.eachItemGraphicEl(function (polygon, idx) { var itemModel = areaData.getItemModel(idx); var labelModel = itemModel.getModel('label.normal'); var labelHoverModel = itemModel.getModel('label.emphasis'); var color = areaData.getItemVisual(idx, 'color'); polygon.useStyle( zrUtil.defaults( itemModel.getModel('itemStyle.normal').getItemStyle(), { fill: colorUtil.modifyAlpha(color, 0.4), stroke: color } ) ); polygon.hoverStyle = itemModel.getModel('itemStyle.emphasis').getItemStyle(); graphic.setLabelStyle( polygon.style, polygon.hoverStyle, labelModel, labelHoverModel, { labelFetcher: maModel, labelDataIndex: idx, defaultText: areaData.getName(idx) || '', isRectText: true, autoColor: color } ); graphic.setHoverStyle(polygon, {}); polygon.dataModel = maModel; }); polygonGroup.__data = areaData; polygonGroup.group.silent = maModel.get('silent') || seriesModel.get('silent'); } }); /** * @inner * @param {module:echarts/coord/*} coordSys * @param {module:echarts/model/Series} seriesModel * @param {module:echarts/model/Model} mpModel */ function createList(coordSys, seriesModel, maModel) { var coordDimsInfos; var areaData; var dims = ['x0', 'y0', 'x1', 'y1']; if (coordSys) { coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) { var info = seriesModel.getData().getDimensionInfo( seriesModel.coordDimToDataDim(coordDim)[0] ) || {}; // In map series data don't have lng and lat dimension. Fallback to same with coordSys info.name = coordDim; return info; }); areaData = new List(zrUtil.map(dims, function (dim, idx) { return { name: dim, type: coordDimsInfos[idx % 2].type }; }), maModel); } else { coordDimsInfos =[{ name: 'value', type: 'float' }]; areaData = new List(coordDimsInfos, maModel); } var optData = zrUtil.map(maModel.get('data'), zrUtil.curry( markAreaTransform, seriesModel, coordSys, maModel )); if (coordSys) { optData = zrUtil.filter( optData, zrUtil.curry(markAreaFilter, coordSys) ); } var dimValueGetter = coordSys ? function (item, dimName, dataIndex, dimIndex) { return item.coord[Math.floor(dimIndex / 2)][dimIndex % 2]; } : function (item) { return item.value; }; areaData.initData(optData, null, dimValueGetter); areaData.hasItemOption = true; return areaData; } /***/ }), /* 411 */ /***/ (function(module, exports, __webpack_require__) { /** * DataZoom component entry */ var echarts = __webpack_require__(1); echarts.registerPreprocessor(__webpack_require__(412)); __webpack_require__(413); __webpack_require__(414); __webpack_require__(415); __webpack_require__(417); /***/ }), /* 412 */ /***/ (function(module, exports, __webpack_require__) { /** * @file Timeline preprocessor */ var zrUtil = __webpack_require__(4); module.exports = function (option) { var timelineOpt = option && option.timeline; if (!zrUtil.isArray(timelineOpt)) { timelineOpt = timelineOpt ? [timelineOpt] : []; } zrUtil.each(timelineOpt, function (opt) { if (!opt) { return; } compatibleEC2(opt); }); }; function compatibleEC2(opt) { var type = opt.type; var ec2Types = {'number': 'value', 'time': 'time'}; // Compatible with ec2 if (ec2Types[type]) { opt.axisType = ec2Types[type]; delete opt.type; } transferItem(opt); if (has(opt, 'controlPosition')) { var controlStyle = opt.controlStyle || (opt.controlStyle = {}); if (!has(controlStyle, 'position')) { controlStyle.position = opt.controlPosition; } if (controlStyle.position === 'none' && !has(controlStyle, 'show')) { controlStyle.show = false; delete controlStyle.position; } delete opt.controlPosition; } zrUtil.each(opt.data || [], function (dataItem) { if (zrUtil.isObject(dataItem) && !zrUtil.isArray(dataItem)) { if (!has(dataItem, 'value') && has(dataItem, 'name')) { // In ec2, using name as value. dataItem.value = dataItem.name; } transferItem(dataItem); } }); } function transferItem(opt) { var itemStyle = opt.itemStyle || (opt.itemStyle = {}); var itemStyleEmphasis = itemStyle.emphasis || (itemStyle.emphasis = {}); // Transfer label out var label = opt.label || (opt.label || {}); var labelNormal = label.normal || (label.normal = {}); var excludeLabelAttr = {normal: 1, emphasis: 1}; zrUtil.each(label, function (value, name) { if (!excludeLabelAttr[name] && !has(labelNormal, name)) { labelNormal[name] = value; } }); if (itemStyleEmphasis.label && !has(label, 'emphasis')) { label.emphasis = itemStyleEmphasis.label; delete itemStyleEmphasis.label; } } function has(obj, attr) { return obj.hasOwnProperty(attr); } /***/ }), /* 413 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(72).registerSubTypeDefaulter('timeline', function () { // Only slider now. return 'slider'; }); /***/ }), /* 414 */ /***/ (function(module, exports, __webpack_require__) { /** * @file Timeilne action */ var echarts = __webpack_require__(1); var zrUtil = __webpack_require__(4); echarts.registerAction( {type: 'timelineChange', event: 'timelineChanged', update: 'prepareAndUpdate'}, function (payload, ecModel) { var timelineModel = ecModel.getComponent('timeline'); if (timelineModel && payload.currentIndex != null) { timelineModel.setCurrentIndex(payload.currentIndex); if (!timelineModel.get('loop', true) && timelineModel.isIndexMax()) { timelineModel.setPlayState(false); } } // Set normalized currentIndex to payload. ecModel.resetOption('timeline'); return zrUtil.defaults({ currentIndex: timelineModel.option.currentIndex }, payload); } ); echarts.registerAction( {type: 'timelinePlayChange', event: 'timelinePlayChanged', update: 'update'}, function (payload, ecModel) { var timelineModel = ecModel.getComponent('timeline'); if (timelineModel && payload.playState != null) { timelineModel.setPlayState(payload.playState); } } ); /***/ }), /* 415 */ /***/ (function(module, exports, __webpack_require__) { /** * @file Silder timeline model */ var TimelineModel = __webpack_require__(416); var zrUtil = __webpack_require__(4); var modelUtil = __webpack_require__(5); var SliderTimelineModel = TimelineModel.extend({ type: 'timeline.slider', /** * @protected */ defaultOption: { backgroundColor: 'rgba(0,0,0,0)', // 时间轴背景颜色 borderColor: '#ccc', // 时间轴边框颜色 borderWidth: 0, // 时间轴边框线宽，单位px，默认为0（无边框） orient: 'horizontal', // 'vertical' inverse: false, tooltip: { // boolean or Object trigger: 'item' // data item may also have tootip attr. }, symbol: 'emptyCircle', symbolSize: 10, lineStyle: { show: true, width: 2, color: '#304654' }, label: { // 文本标签 position: 'auto', // auto left right top bottom // When using number, label position is not // restricted by viewRect. // positive: right/bottom, negative: left/top normal: { show: true, interval: 'auto', rotate: 0, // formatter: null, // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#304654' }, emphasis: { show: true, // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#c23531' } }, itemStyle: { normal: { color: '#304654', borderWidth: 1 }, emphasis: { color: '#c23531' } }, checkpointStyle: { symbol: 'circle', symbolSize: 13, color: '#c23531', borderWidth: 5, borderColor: 'rgba(194,53,49, 0.5)', animation: true, animationDuration: 300, animationEasing: 'quinticInOut' }, controlStyle: { show: true, showPlayBtn: true, showPrevBtn: true, showNextBtn: true, itemSize: 22, itemGap: 12, position: 'left', // 'left' 'right' 'top' 'bottom' playIcon: 'path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z', // jshint ignore:line stopIcon: 'path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z', // jshint ignore:line nextIcon: 'path://M18.6,50.8l22.5-22.5c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.3-0.7L18.7,4.4c-0.1-0.1-0.2-0.3-0.2-0.5 c0-0.4,0.3-0.8,0.8-0.8c0.2,0,0.5,0.1,0.6,0.3l23.5,23.5l0,0c0.2,0.2,0.3,0.4,0.3,0.7c0,0.3-0.1,0.5-0.3,0.7l-0.1,0.1L19.7,52 c-0.1,0.1-0.3,0.2-0.5,0.2c-0.4,0-0.8-0.3-0.8-0.8C18.4,51.2,18.5,51,18.6,50.8z', // jshint ignore:line prevIcon: 'path://M43,52.8L20.4,30.3c-0.2-0.2-0.3-0.4-0.3-0.7c0-0.3,0.1-0.5,0.3-0.7L42.9,6.4c0.1-0.1,0.2-0.3,0.2-0.5 c0-0.4-0.3-0.8-0.8-0.8c-0.2,0-0.5,0.1-0.6,0.3L18.3,28.8l0,0c-0.2,0.2-0.3,0.4-0.3,0.7c0,0.3,0.1,0.5,0.3,0.7l0.1,0.1L41.9,54 c0.1,0.1,0.3,0.2,0.5,0.2c0.4,0,0.8-0.3,0.8-0.8C43.2,53.2,43.1,53,43,52.8z', // jshint ignore:line normal: { color: '#304654', borderColor: '#304654', borderWidth: 1 }, emphasis: { color: '#c23531', borderColor: '#c23531', borderWidth: 2 } }, data: [] } }); zrUtil.mixin(SliderTimelineModel, modelUtil.dataFormatMixin); module.exports = SliderTimelineModel; /***/ }), /* 416 */ /***/ (function(module, exports, __webpack_require__) { /** * @file Timeline model */ var ComponentModel = __webpack_require__(72); var List = __webpack_require__(101); var zrUtil = __webpack_require__(4); var modelUtil = __webpack_require__(5); var TimelineModel = ComponentModel.extend({ type: 'timeline', layoutMode: 'box', /** * @protected */ defaultOption: { zlevel: 0, // 一级层叠 z: 4, // 二级层叠 show: true, axisType: 'time', // 模式是时间类型，支持 value, category realtime: true, left: '20%', top: null, right: '20%', bottom: 0, width: null, height: 40, padding: 5, controlPosition: 'left', // 'left' 'right' 'top' 'bottom' 'none' autoPlay: false, rewind: false, // 反向播放 loop: true, playInterval: 2000, // 播放时间间隔，单位ms currentIndex: 0, itemStyle: { normal: {}, emphasis: {} }, label: { normal: { color: '#000' }, emphasis: {} }, data: [] }, /** * @override */ init: function (option, parentModel, ecModel) { /** * @private * @type {module:echarts/data/List} */ this._data; /** * @private * @type {Array.} */ this._names; this.mergeDefaultAndTheme(option, ecModel); this._initData(); }, /** * @override */ mergeOption: function (option) { TimelineModel.superApply(this, 'mergeOption', arguments); this._initData(); }, /** * @param {number} [currentIndex] */ setCurrentIndex: function (currentIndex) { if (currentIndex == null) { currentIndex = this.option.currentIndex; } var count = this._data.count(); if (this.option.loop) { currentIndex = (currentIndex % count + count) % count; } else { currentIndex >= count && (currentIndex = count - 1); currentIndex < 0 && (currentIndex = 0); } this.option.currentIndex = currentIndex; }, /** * @return {number} currentIndex */ getCurrentIndex: function () { return this.option.currentIndex; }, /** * @return {boolean} */ isIndexMax: function () { return this.getCurrentIndex() >= this._data.count() - 1; }, /** * @param {boolean} state true: play, false: stop */ setPlayState: function (state) { this.option.autoPlay = !!state; }, /** * @return {boolean} true: play, false: stop */ getPlayState: function () { return !!this.option.autoPlay; }, /** * @private */ _initData: function () { var thisOption = this.option; var dataArr = thisOption.data || []; var axisType = thisOption.axisType; var names = this._names = []; if (axisType === 'category') { var idxArr = []; zrUtil.each(dataArr, function (item, index) { var value = modelUtil.getDataItemValue(item); var newItem; if (zrUtil.isObject(item)) { newItem = zrUtil.clone(item); newItem.value = index; } else { newItem = index; } idxArr.push(newItem); if (!zrUtil.isString(value) && (value == null || isNaN(value))) { value = ''; } names.push(value + ''); }); dataArr = idxArr; } var dimType = ({category: 'ordinal', time: 'time'})[axisType] || 'number'; var data = this._data = new List([{name: 'value', type: dimType}], this); data.initData(dataArr, names); }, getData: function () { return this._data; }, /** * @public * @return {Array.} categoreis */ getCategories: function () { if (this.get('axisType') === 'category') { return this._names.slice(); } } }); module.exports = TimelineModel; /***/ }), /* 417 */ /***/ (function(module, exports, __webpack_require__) { /** * @file Silder timeline view */ var zrUtil = __webpack_require__(4); var graphic = __webpack_require__(20); var layout = __webpack_require__(74); var TimelineView = __webpack_require__(418); var TimelineAxis = __webpack_require__(419); var symbolUtil = __webpack_require__(114); var axisHelper = __webpack_require__(104); var BoundingRect = __webpack_require__(9); var matrix = __webpack_require__(11); var numberUtil = __webpack_require__(7); var formatUtil = __webpack_require__(6); var encodeHTML = formatUtil.encodeHTML; var bind = zrUtil.bind; var each = zrUtil.each; var PI = Math.PI; module.exports = TimelineView.extend({ type: 'timeline.slider', init: function (ecModel, api) { this.api = api; /** * @private * @type {module:echarts/component/timeline/TimelineAxis} */ this._axis; /** * @private * @type {module:zrender/core/BoundingRect} */ this._viewRect; /** * @type {number} */ this._timer; /** * @type {module:zrender/Element} */ this._currentPointer; /** * @type {module:zrender/container/Group} */ this._mainGroup; /** * @type {module:zrender/container/Group} */ this._labelGroup; }, /** * @override */ render: function (timelineModel, ecModel, api, payload) { this.model = timelineModel; this.api = api; this.ecModel = ecModel; this.group.removeAll(); if (timelineModel.get('show', true)) { var layoutInfo = this._layout(timelineModel, api); var mainGroup = this._createGroup('mainGroup'); var labelGroup = this._createGroup('labelGroup'); /** * @private * @type {module:echarts/component/timeline/TimelineAxis} */ var axis = this._axis = this._createAxis(layoutInfo, timelineModel); timelineModel.formatTooltip = function (dataIndex) { return encodeHTML(axis.scale.getLabel(dataIndex)); }; each( ['AxisLine', 'AxisTick', 'Control', 'CurrentPointer'], function (name) { this['_render' + name](layoutInfo, mainGroup, axis, timelineModel); }, this ); this._renderAxisLabel(layoutInfo, labelGroup, axis, timelineModel); this._position(layoutInfo, timelineModel); } this._doPlayStop(); }, /** * @override */ remove: function () { this._clearTimer(); this.group.removeAll(); }, /** * @override */ dispose: function () { this._clearTimer(); }, _layout: function (timelineModel, api) { var labelPosOpt = timelineModel.get('label.normal.position'); var orient = timelineModel.get('orient'); var viewRect = getViewRect(timelineModel, api); // Auto label offset. if (labelPosOpt == null || labelPosOpt === 'auto') { labelPosOpt = orient === 'horizontal' ? ((viewRect.y + viewRect.height / 2) < api.getHeight() / 2 ? '-' : '+') : ((viewRect.x + viewRect.width / 2) < api.getWidth() / 2 ? '+' : '-'); } else if (isNaN(labelPosOpt)) { labelPosOpt = ({ horizontal: {top: '-', bottom: '+'}, vertical: {left: '-', right: '+'} })[orient][labelPosOpt]; } var labelAlignMap = { horizontal: 'center', vertical: (labelPosOpt >= 0 || labelPosOpt === '+') ? 'left' : 'right' }; var labelBaselineMap = { horizontal: (labelPosOpt >= 0 || labelPosOpt === '+') ? 'top' : 'bottom', vertical: 'middle' }; var rotationMap = { horizontal: 0, vertical: PI / 2 }; // Position var mainLength = orient === 'vertical' ? viewRect.height : viewRect.width; var controlModel = timelineModel.getModel('controlStyle'); var showControl = controlModel.get('show'); var controlSize = showControl ? controlModel.get('itemSize') : 0; var controlGap = showControl ? controlModel.get('itemGap') : 0; var sizePlusGap = controlSize + controlGap; // Special label rotate. var labelRotation = timelineModel.get('label.normal.rotate') || 0; labelRotation = labelRotation * PI / 180; // To radian. var playPosition; var prevBtnPosition; var nextBtnPosition; var axisExtent; var controlPosition = controlModel.get('position', true); var showControl = controlModel.get('show', true); var showPlayBtn = showControl && controlModel.get('showPlayBtn', true); var showPrevBtn = showControl && controlModel.get('showPrevBtn', true); var showNextBtn = showControl && controlModel.get('showNextBtn', true); var xLeft = 0; var xRight = mainLength; // position[0] means left, position[1] means middle. if (controlPosition === 'left' || controlPosition === 'bottom') { showPlayBtn && (playPosition = [0, 0], xLeft += sizePlusGap); showPrevBtn && (prevBtnPosition = [xLeft, 0], xLeft += sizePlusGap); showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap); } else { // 'top' 'right' showPlayBtn && (playPosition = [xRight - controlSize, 0], xRight -= sizePlusGap); showPrevBtn && (prevBtnPosition = [0, 0], xLeft += sizePlusGap); showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap); } axisExtent = [xLeft, xRight]; if (timelineModel.get('inverse')) { axisExtent.reverse(); } return { viewRect: viewRect, mainLength: mainLength, orient: orient, rotation: rotationMap[orient], labelRotation: labelRotation, labelPosOpt: labelPosOpt, labelAlign: timelineModel.get('label.normal.align') || labelAlignMap[orient], labelBaseline: timelineModel.get('label.normal.verticalAlign') || timelineModel.get('label.normal.baseline') || labelBaselineMap[orient], // Based on mainGroup. playPosition: playPosition, prevBtnPosition: prevBtnPosition, nextBtnPosition: nextBtnPosition, axisExtent: axisExtent, controlSize: controlSize, controlGap: controlGap }; }, _position: function (layoutInfo, timelineModel) { // Position is be called finally, because bounding rect is needed for // adapt content to fill viewRect (auto adapt offset). // Timeline may be not all in the viewRect when 'offset' is specified // as a number, because it is more appropriate that label aligns at // 'offset' but not the other edge defined by viewRect. var mainGroup = this._mainGroup; var labelGroup = this._labelGroup; var viewRect = layoutInfo.viewRect; if (layoutInfo.orient === 'vertical') { // transfrom to horizontal, inverse rotate by left-top point. var m = matrix.create(); var rotateOriginX = viewRect.x; var rotateOriginY = viewRect.y + viewRect.height; matrix.translate(m, m, [-rotateOriginX, -rotateOriginY]); matrix.rotate(m, m, -PI / 2); matrix.translate(m, m, [rotateOriginX, rotateOriginY]); viewRect = viewRect.clone(); viewRect.applyTransform(m); } var viewBound = getBound(viewRect); var mainBound = getBound(mainGroup.getBoundingRect()); var labelBound = getBound(labelGroup.getBoundingRect()); var mainPosition = mainGroup.position; var labelsPosition = labelGroup.position; labelsPosition[0] = mainPosition[0] = viewBound[0][0]; var labelPosOpt = layoutInfo.labelPosOpt; if (isNaN(labelPosOpt)) { // '+' or '-' var mainBoundIdx = labelPosOpt === '+' ? 0 : 1; toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx); toBound(labelsPosition, labelBound, viewBound, 1, 1 - mainBoundIdx); } else { var mainBoundIdx = labelPosOpt >= 0 ? 0 : 1; toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx); labelsPosition[1] = mainPosition[1] + labelPosOpt; } mainGroup.attr('position', mainPosition); labelGroup.attr('position', labelsPosition); mainGroup.rotation = labelGroup.rotation = layoutInfo.rotation; setOrigin(mainGroup); setOrigin(labelGroup); function setOrigin(targetGroup) { var pos = targetGroup.position; targetGroup.origin = [ viewBound[0][0] - pos[0], viewBound[1][0] - pos[1] ]; } function getBound(rect) { // [[xmin, xmax], [ymin, ymax]] return [ [rect.x, rect.x + rect.width], [rect.y, rect.y + rect.height] ]; } function toBound(fromPos, from, to, dimIdx, boundIdx) { fromPos[dimIdx] += to[dimIdx][boundIdx] - from[dimIdx][boundIdx]; } }, _createAxis: function (layoutInfo, timelineModel) { var data = timelineModel.getData(); var axisType = timelineModel.get('axisType'); var scale = axisHelper.createScaleByModel(timelineModel, axisType); var dataExtent = data.getDataExtent('value'); scale.setExtent(dataExtent[0], dataExtent[1]); this._customizeScale(scale, data); scale.niceTicks(); var axis = new TimelineAxis('value', scale, layoutInfo.axisExtent, axisType); axis.model = timelineModel; return axis; }, _customizeScale: function (scale, data) { scale.getTicks = function () { return data.mapArray(['value'], function (value) { return value; }); }; scale.getTicksLabels = function () { return zrUtil.map(this.getTicks(), scale.getLabel, scale); }; }, _createGroup: function (name) { var newGroup = this['_' + name] = new graphic.Group(); this.group.add(newGroup); return newGroup; }, _renderAxisLine: function (layoutInfo, group, axis, timelineModel) { var axisExtent = axis.getExtent(); if (!timelineModel.get('lineStyle.show')) { return; } group.add(new graphic.Line({ shape: { x1: axisExtent[0], y1: 0, x2: axisExtent[1], y2: 0 }, style: zrUtil.extend( {lineCap: 'round'}, timelineModel.getModel('lineStyle').getLineStyle() ), silent: true, z2: 1 })); }, /** * @private */ _renderAxisTick: function (layoutInfo, group, axis, timelineModel) { var data = timelineModel.getData(); var ticks = axis.scale.getTicks(); each(ticks, function (value, dataIndex) { var tickCoord = axis.dataToCoord(value); var itemModel = data.getItemModel(dataIndex); var itemStyleModel = itemModel.getModel('itemStyle.normal'); var hoverStyleModel = itemModel.getModel('itemStyle.emphasis'); var symbolOpt = { position: [tickCoord, 0], onclick: bind(this._changeTimeline, this, dataIndex) }; var el = giveSymbol(itemModel, itemStyleModel, group, symbolOpt); graphic.setHoverStyle(el, hoverStyleModel.getItemStyle()); if (itemModel.get('tooltip')) { el.dataIndex = dataIndex; el.dataModel = timelineModel; } else { el.dataIndex = el.dataModel = null; } }, this); }, /** * @private */ _renderAxisLabel: function (layoutInfo, group, axis, timelineModel) { var labelModel = timelineModel.getModel('label.normal'); if (!labelModel.get('show')) { return; } var data = timelineModel.getData(); var ticks = axis.scale.getTicks(); var labels = axisHelper.getFormattedLabels( axis, labelModel.get('formatter') ); var labelInterval = axis.getLabelInterval(); each(ticks, function (tick, dataIndex) { if (axis.isLabelIgnored(dataIndex, labelInterval)) { return; } var itemModel = data.getItemModel(dataIndex); var normalLabelModel = itemModel.getModel('label.normal'); var hoverLabelModel = itemModel.getModel('label.emphasis'); var tickCoord = axis.dataToCoord(tick); var textEl = new graphic.Text({ position: [tickCoord, 0], rotation: layoutInfo.labelRotation - layoutInfo.rotation, onclick: bind(this._changeTimeline, this, dataIndex), silent: false }); graphic.setTextStyle(textEl.style, normalLabelModel, { text: labels[dataIndex], textAlign: layoutInfo.labelAlign, textVerticalAlign: layoutInfo.labelBaseline }); group.add(textEl); graphic.setHoverStyle( textEl, graphic.setTextStyle({}, hoverLabelModel) ); }, this); }, /** * @private */ _renderControl: function (layoutInfo, group, axis, timelineModel) { var controlSize = layoutInfo.controlSize; var rotation = layoutInfo.rotation; var itemStyle = timelineModel.getModel('controlStyle.normal').getItemStyle(); var hoverStyle = timelineModel.getModel('controlStyle.emphasis').getItemStyle(); var rect = [0, -controlSize / 2, controlSize, controlSize]; var playState = timelineModel.getPlayState(); var inverse = timelineModel.get('inverse', true); makeBtn( layoutInfo.nextBtnPosition, 'controlStyle.nextIcon', bind(this._changeTimeline, this, inverse ? '-' : '+') ); makeBtn( layoutInfo.prevBtnPosition, 'controlStyle.prevIcon', bind(this._changeTimeline, this, inverse ? '+' : '-') ); makeBtn( layoutInfo.playPosition, 'controlStyle.' + (playState ? 'stopIcon' : 'playIcon'), bind(this._handlePlayClick, this, !playState), true ); function makeBtn(position, iconPath, onclick, willRotate) { if (!position) { return; } var opt = { position: position, origin: [controlSize / 2, 0], rotation: willRotate ? -rotation : 0, rectHover: true, style: itemStyle, onclick: onclick }; var btn = makeIcon(timelineModel, iconPath, rect, opt); group.add(btn); graphic.setHoverStyle(btn, hoverStyle); } }, _renderCurrentPointer: function (layoutInfo, group, axis, timelineModel) { var data = timelineModel.getData(); var currentIndex = timelineModel.getCurrentIndex(); var pointerModel = data.getItemModel(currentIndex).getModel('checkpointStyle'); var me = this; var callback = { onCreate: function (pointer) { pointer.draggable = true; pointer.drift = bind(me._handlePointerDrag, me); pointer.ondragend = bind(me._handlePointerDragend, me); pointerMoveTo(pointer, currentIndex, axis, timelineModel, true); }, onUpdate: function (pointer) { pointerMoveTo(pointer, currentIndex, axis, timelineModel); } }; // Reuse when exists, for animation and drag. this._currentPointer = giveSymbol( pointerModel, pointerModel, this._mainGroup, {}, this._currentPointer, callback ); }, _handlePlayClick: function (nextState) { this._clearTimer(); this.api.dispatchAction({ type: 'timelinePlayChange', playState: nextState, from: this.uid }); }, _handlePointerDrag: function (dx, dy, e) { this._clearTimer(); this._pointerChangeTimeline([e.offsetX, e.offsetY]); }, _handlePointerDragend: function (e) { this._pointerChangeTimeline([e.offsetX, e.offsetY], true); }, _pointerChangeTimeline: function (mousePos, trigger) { var toCoord = this._toAxisCoord(mousePos)[0]; var axis = this._axis; var axisExtent = numberUtil.asc(axis.getExtent().slice()); toCoord > axisExtent[1] && (toCoord = axisExtent[1]); toCoord < axisExtent[0] && (toCoord = axisExtent[0]); this._currentPointer.position[0] = toCoord; this._currentPointer.dirty(); var targetDataIndex = this._findNearestTick(toCoord); var timelineModel = this.model; if (trigger || ( targetDataIndex !== timelineModel.getCurrentIndex() && timelineModel.get('realtime') )) { this._changeTimeline(targetDataIndex); } }, _doPlayStop: function () { this._clearTimer(); if (this.model.getPlayState()) { this._timer = setTimeout( bind(handleFrame, this), this.model.get('playInterval') ); } function handleFrame() { // Do not cache var timelineModel = this.model; this._changeTimeline( timelineModel.getCurrentIndex() + (timelineModel.get('rewind', true) ? -1 : 1) ); } }, _toAxisCoord: function (vertex) { var trans = this._mainGroup.getLocalTransform(); return graphic.applyTransform(vertex, trans, true); }, _findNearestTick: function (axisCoord) { var data = this.model.getData(); var dist = Infinity; var targetDataIndex; var axis = this._axis; data.each(['value'], function (value, dataIndex) { var coord = axis.dataToCoord(value); var d = Math.abs(coord - axisCoord); if (d < dist) { dist = d; targetDataIndex = dataIndex; } }); return targetDataIndex; }, _clearTimer: function () { if (this._timer) { clearTimeout(this._timer); this._timer = null; } }, _changeTimeline: function (nextIndex) { var currentIndex = this.model.getCurrentIndex(); if (nextIndex === '+') { nextIndex = currentIndex + 1; } else if (nextIndex === '-') { nextIndex = currentIndex - 1; } this.api.dispatchAction({ type: 'timelineChange', currentIndex: nextIndex, from: this.uid }); } }); function getViewRect(model, api) { return layout.getLayoutRect( model.getBoxLayoutParams(), { width: api.getWidth(), height: api.getHeight() }, model.get('padding') ); } function makeIcon(timelineModel, objPath, rect, opts) { var icon = graphic.makePath( timelineModel.get(objPath).replace(/^path:\\/\\//, ''), zrUtil.clone(opts || {}), new BoundingRect(rect[0], rect[1], rect[2], rect[3]), 'center' ); return icon; } /** * Create symbol or update symbol * opt: basic position and event handlers */ function giveSymbol(hostModel, itemStyleModel, group, opt, symbol, callback) { var color = itemStyleModel.get('color'); if (!symbol) { var symbolType = hostModel.get('symbol'); symbol = symbolUtil.createSymbol(symbolType, -1, -1, 2, 2, color); symbol.setStyle('strokeNoScale', true); group.add(symbol); callback && callback.onCreate(symbol); } else { symbol.setColor(color); group.add(symbol); // Group may be new, also need to add. callback && callback.onUpdate(symbol); } // Style var itemStyle = itemStyleModel.getItemStyle(['color', 'symbol', 'symbolSize']); symbol.setStyle(itemStyle); // Transform and events. opt = zrUtil.merge({ rectHover: true, z2: 100 }, opt, true); var symbolSize = hostModel.get('symbolSize'); symbolSize = symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize]; symbolSize[0] /= 2; symbolSize[1] /= 2; opt.scale = symbolSize; var symbolOffset = hostModel.get('symbolOffset'); if (symbolOffset) { var pos = opt.position = opt.position || [0, 0]; pos[0] += numberUtil.parsePercent(symbolOffset[0], symbolSize[0]); pos[1] += numberUtil.parsePercent(symbolOffset[1], symbolSize[1]); } var symbolRotate = hostModel.get('symbolRotate'); opt.rotation = (symbolRotate || 0) * Math.PI / 180 || 0; symbol.attr(opt); // FIXME // (1) When symbol.style.strokeNoScale is true and updateTransform is not performed, // getBoundingRect will return wrong result. // (This is supposed to be resolved in zrender, but it is a little difficult to // leverage performance and auto updateTransform) // (2) All of ancesters of symbol do not scale, so we can just updateTransform symbol. symbol.updateTransform(); return symbol; } function pointerMoveTo(pointer, dataIndex, axis, timelineModel, noAnimation) { if (pointer.dragging) { return; } var pointerModel = timelineModel.getModel('checkpointStyle'); var toCoord = axis.dataToCoord(timelineModel.getData().get(['value'], dataIndex)); if (noAnimation || !pointerModel.get('animation', true)) { pointer.attr({position: [toCoord, 0]}); } else { pointer.stopAnimation(true); pointer.animateTo( {position: [toCoord, 0]}, pointerModel.get('animationDuration', true), pointerModel.get('animationEasing', true) ); } } /***/ }), /* 418 */ /***/ (function(module, exports, __webpack_require__) { /** * @file Timeline view */ // var zrUtil = require('zrender/lib/core/util'); // var graphic = require('../../util/graphic'); var ComponentView = __webpack_require__(84); module.exports = ComponentView.extend({ type: 'timeline' }); /***/ }), /* 419 */ /***/ (function(module, exports, __webpack_require__) { var zrUtil = __webpack_require__(4); var Axis = __webpack_require__(103); var axisHelper = __webpack_require__(104); /** * Extend axis 2d * @constructor module:echarts/coord/cartesian/Axis2D * @extends {module:echarts/coord/cartesian/Axis} * @param {string} dim * @param {*} scale * @param {Array.} coordExtent * @param {string} axisType * @param {string} position */ var TimelineAxis = function (dim, scale, coordExtent, axisType) { Axis.call(this, dim, scale, coordExtent); /** * Axis type * - 'category' * - 'value' * - 'time' * - 'log' * @type {string} */ this.type = axisType || 'value'; /** * @private * @type {number} */ this._autoLabelInterval; /** * Axis model * @param {module:echarts/component/TimelineModel} */ this.model = null; }; TimelineAxis.prototype = { constructor: TimelineAxis, /** * @public * @return {number} */ getLabelInterval: function () { var timelineModel = this.model; var labelModel = timelineModel.getModel('label.normal'); var labelInterval = labelModel.get('interval'); if (labelInterval != null && labelInterval != 'auto') { return labelInterval; } var labelInterval = this._autoLabelInterval; if (!labelInterval) { labelInterval = this._autoLabelInterval = axisHelper.getAxisLabelInterval( zrUtil.map(this.scale.getTicks(), this.dataToCoord, this), axisHelper.getFormattedLabels(this, labelModel.get('formatter')), labelModel.getFont(), timelineModel.get('orient') === 'horizontal' ); } return labelInterval; }, /** * If label is ignored. * Automatically used when axis is category and label can not be all shown * @public * @param {number} idx * @return {boolean} */ isLabelIgnored: function (idx) { if (this.type === 'category') { var labelInterval = this.getLabelInterval(); return ((typeof labelInterval === 'function') && !labelInterval(idx, this.scale.getLabel(idx))) || idx % (labelInterval + 1); } } }; zrUtil.inherits(TimelineAxis, Axis); module.exports = TimelineAxis; /***/ }), /* 420 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(421); __webpack_require__(422); __webpack_require__(423); __webpack_require__(424); __webpack_require__(425); __webpack_require__(426); __webpack_require__(431); /***/ }), /* 421 */ /***/ (function(module, exports, __webpack_require__) { var featureManager = __webpack_require__(364); var zrUtil = __webpack_require__(4); var ToolboxModel = __webpack_require__(1).extendComponentModel({ type: 'toolbox', layoutMode: { type: 'box', ignoreSize: true }, mergeDefaultAndTheme: function (option) { ToolboxModel.superApply(this, 'mergeDefaultAndTheme', arguments); zrUtil.each(this.option.feature, function (featureOpt, featureName) { var Feature = featureManager.get(featureName); Feature && zrUtil.merge(featureOpt, Feature.defaultOption); }); }, defaultOption: { show: true, z: 6, zlevel: 0, orient: 'horizontal', left: 'right', top: 'top', // right // bottom backgroundColor: 'transparent', borderColor: '#ccc', borderRadius: 0, borderWidth: 0, padding: 5, itemSize: 15, itemGap: 8, showTitle: true, iconStyle: { normal: { borderColor: '#666', color: 'none' }, emphasis: { borderColor: '#3E98C5' } } // textStyle: {}, // feature } }); module.exports = ToolboxModel; /***/ }), /* 422 */ /***/ (function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */(function(process) { var featureManager = __webpack_require__(364); var zrUtil = __webpack_require__(4); var graphic = __webpack_require__(20); var Model = __webpack_require__(14); var DataDiffer = __webpack_require__(102); var listComponentHelper = __webpack_require__(329); var textContain = __webpack_require__(8); module.exports = __webpack_require__(1).extendComponentView({ type: 'toolbox', render: function (toolboxModel, ecModel, api, payload) { var group = this.group; group.removeAll(); if (!toolboxModel.get('show')) { return; } var itemSize = +toolboxModel.get('itemSize'); var featureOpts = toolboxModel.get('feature') || {}; var features = this._features || (this._features = {}); var featureNames = []; zrUtil.each(featureOpts, function (opt, name) { featureNames.push(name); }); (new DataDiffer(this._featureNames || [], featureNames)) .add(process) .update(process) .remove(zrUtil.curry(process, null)) .execute(); // Keep for diff. this._featureNames = featureNames; function process(newIndex, oldIndex) { var featureName = featureNames[newIndex]; var oldName = featureNames[oldIndex]; var featureOpt = featureOpts[featureName]; var featureModel = new Model(featureOpt, toolboxModel, toolboxModel.ecModel); var feature; if (featureName && !oldName) { // Create if (isUserFeatureName(featureName)) { feature = { model: featureModel, onclick: featureModel.option.onclick, featureName: featureName }; } else { var Feature = featureManager.get(featureName); if (!Feature) { return; } feature = new Feature(featureModel, ecModel, api); } features[featureName] = feature; } else { feature = features[oldName]; // If feature does not exsit. if (!feature) { return; } feature.model = featureModel; feature.ecModel = ecModel; feature.api = api; } if (!featureName && oldName) { feature.dispose && feature.dispose(ecModel, api); return; } if (!featureModel.get('show') || feature.unusable) { feature.remove && feature.remove(ecModel, api); return; } createIconPaths(featureModel, feature, featureName); featureModel.setIconStatus = function (iconName, status) { var option = this.option; var iconPaths = this.iconPaths; option.iconStatus = option.iconStatus || {}; option.iconStatus[iconName] = status; // FIXME iconPaths[iconName] && iconPaths[iconName].trigger(status); }; if (feature.render) { feature.render(featureModel, ecModel, api, payload); } } function createIconPaths(featureModel, feature, featureName) { var iconStyleModel = featureModel.getModel('iconStyle'); // If one feature has mutiple icon. they are orginaized as // { // icon: { // foo: '', // bar: '' // }, // title: { // foo: '', // bar: '' // } // } var icons = feature.getIcons ? feature.getIcons() : featureModel.get('icon'); var titles = featureModel.get('title') || {}; if (typeof icons === 'string') { var icon = icons; var title = titles; icons = {}; titles = {}; icons[featureName] = icon; titles[featureName] = title; } var iconPaths = featureModel.iconPaths = {}; zrUtil.each(icons, function (iconStr, iconName) { var path = graphic.createIcon( iconStr, {}, { x: -itemSize / 2, y: -itemSize / 2, width: itemSize, height: itemSize } ); path.setStyle(iconStyleModel.getModel('normal').getItemStyle()); path.hoverStyle = iconStyleModel.getModel('emphasis').getItemStyle(); graphic.setHoverStyle(path); if (toolboxModel.get('showTitle')) { path.__title = titles[iconName]; path.on('mouseover', function () { // Should not reuse above hoverStyle, which might be modified. var hoverStyle = iconStyleModel.getModel('emphasis').getItemStyle(); path.setStyle({ text: titles[iconName], textPosition: hoverStyle.textPosition || 'bottom', textFill: hoverStyle.fill || hoverStyle.stroke || '#000', textAlign: hoverStyle.textAlign || 'center' }); }) .on('mouseout', function () { path.setStyle({ textFill: null }); }); } path.trigger(featureModel.get('iconStatus.' + iconName) || 'normal'); group.add(path); path.on('click', zrUtil.bind( feature.onclick, feature, ecModel, api, iconName )); iconPaths[iconName] = path; }); } listComponentHelper.layout(group, toolboxModel, api); // Render background after group is layout // FIXME group.add(listComponentHelper.makeBackground(group.getBoundingRect(), toolboxModel)); // Adjust icon title positions to avoid them out of screen group.eachChild(function (icon) { var titleText = icon.__title; var hoverStyle = icon.hoverStyle; // May be background element if (hoverStyle && titleText) { var rect = textContain.getBoundingRect( titleText, textContain.makeFont(hoverStyle) ); var offsetX = icon.position[0] + group.position[0]; var offsetY = icon.position[1] + group.position[1] + itemSize; var needPutOnTop = false; if (offsetY + rect.height > api.getHeight()) { hoverStyle.textPosition = 'top'; needPutOnTop = true; } var topOffset = needPutOnTop ? (-5 - rect.height) : (itemSize + 8); if (offsetX + rect.width / 2 > api.getWidth()) { hoverStyle.textPosition = ['100%', topOffset]; hoverStyle.textAlign = 'right'; } else if (offsetX - rect.width / 2 < 0) { hoverStyle.textPosition = [0, topOffset]; hoverStyle.textAlign = 'left'; } } }); }, updateView: function (toolboxModel, ecModel, api, payload) { zrUtil.each(this._features, function (feature) { feature.updateView && feature.updateView(feature.model, ecModel, api, payload); }); }, updateLayout: function (toolboxModel, ecModel, api, payload) { zrUtil.each(this._features, function (feature) { feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload); }); }, remove: function (ecModel, api) { zrUtil.each(this._features, function (feature) { feature.remove && feature.remove(ecModel, api); }); this.group.removeAll(); }, dispose: function (ecModel, api) { zrUtil.each(this._features, function (feature) { feature.dispose && feature.dispose(ecModel, api); }); } }); function isUserFeatureName(featureName) { return featureName.indexOf('my') === 0; } /* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(313))) /***/ }), /* 423 */ /***/ (function(module, exports, __webpack_require__) { var env = __webpack_require__(2); var lang = __webpack_require__(365).toolbox.saveAsImage; function SaveAsImage (model) { this.model = model; } SaveAsImage.defaultOption = { show: true, icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0', title: lang.title, type: 'png', // Default use option.backgroundColor // backgroundColor: '#fff', name: '', excludeComponents: ['toolbox'], pixelRatio: 1, lang: lang.lang.slice() }; SaveAsImage.prototype.unusable = !env.canvasSupported; var proto = SaveAsImage.prototype; proto.onclick = function (ecModel, api) { var model = this.model; var title = model.get('name') || ecModel.get('title.0.text') || 'echarts'; var $a = document.createElement('a'); var type = model.get('type', true) || 'png'; $a.download = title + '.' + type; $a.target = '_blank'; var url = api.getConnectedDataURL({ type: type, backgroundColor: model.get('backgroundColor', true) || ecModel.get('backgroundColor') || '#fff', excludeComponents: model.get('excludeComponents'), pixelRatio: model.get('pixelRatio') }); $a.href = url; // Chrome and Firefox if (typeof MouseEvent === 'function' && !env.browser.ie && !env.browser.edge) { var evt = new MouseEvent('click', { view: window, bubbles: true, cancelable: false }); $a.dispatchEvent(evt); } // IE else { if (window.navigator.msSaveOrOpenBlob) { var bstr = atob(url.split(',')[1]); var n = bstr.length; var u8arr = new Uint8Array(n); while(n--) { u8arr[n] = bstr.charCodeAt(n); } var blob = new Blob([u8arr]); window.navigator.msSaveOrOpenBlob(blob, title + '.' + type); } else { var lang = model.get('lang'); var html = '' + '' + '' + ''; var tab = window.open(); tab.document.write(html); } } }; __webpack_require__(364).register( 'saveAsImage', SaveAsImage ); module.exports = SaveAsImage; /***/ }), /* 424 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var zrUtil = __webpack_require__(4); var lang = __webpack_require__(365).toolbox.magicType; function MagicType(model) { this.model = model; } MagicType.defaultOption = { show: true, type: [], // Icon group icon: { line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4', bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7', stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z', // jshint ignore:line tiled: 'M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z' }, // `line`, `bar`, `stack`, `tiled` title: zrUtil.clone(lang.title), option: {}, seriesIndex: {} }; var proto = MagicType.prototype; proto.getIcons = function () { var model = this.model; var availableIcons = model.get('icon'); var icons = {}; zrUtil.each(model.get('type'), function (type) { if (availableIcons[type]) { icons[type] = availableIcons[type]; } }); return icons; }; var seriesOptGenreator = { 'line': function (seriesType, seriesId, seriesModel, model) { if (seriesType === 'bar') { return zrUtil.merge({ id: seriesId, type: 'line', // Preserve data related option data: seriesModel.get('data'), stack: seriesModel.get('stack'), markPoint: seriesModel.get('markPoint'), markLine: seriesModel.get('markLine') }, model.get('option.line') || {}, true); } }, 'bar': function (seriesType, seriesId, seriesModel, model) { if (seriesType === 'line') { return zrUtil.merge({ id: seriesId, type: 'bar', // Preserve data related option data: seriesModel.get('data'), stack: seriesModel.get('stack'), markPoint: seriesModel.get('markPoint'), markLine: seriesModel.get('markLine') }, model.get('option.bar') || {}, true); } }, 'stack': function (seriesType, seriesId, seriesModel, model) { if (seriesType === 'line' || seriesType === 'bar') { return zrUtil.merge({ id: seriesId, stack: '__ec_magicType_stack__' }, model.get('option.stack') || {}, true); } }, 'tiled': function (seriesType, seriesId, seriesModel, model) { if (seriesType === 'line' || seriesType === 'bar') { return zrUtil.merge({ id: seriesId, stack: '' }, model.get('option.tiled') || {}, true); } } }; var radioTypes = [ ['line', 'bar'], ['stack', 'tiled'] ]; proto.onclick = function (ecModel, api, type) { var model = this.model; var seriesIndex = model.get('seriesIndex.' + type); // Not supported magicType if (!seriesOptGenreator[type]) { return; } var newOption = { series: [] }; var generateNewSeriesTypes = function (seriesModel) { var seriesType = seriesModel.subType; var seriesId = seriesModel.id; var newSeriesOpt = seriesOptGenreator[type]( seriesType, seriesId, seriesModel, model ); if (newSeriesOpt) { // PENDING If merge original option? zrUtil.defaults(newSeriesOpt, seriesModel.option); newOption.series.push(newSeriesOpt); } // Modify boundaryGap var coordSys = seriesModel.coordinateSystem; if (coordSys && coordSys.type === 'cartesian2d' && (type === 'line' || type === 'bar')) { var categoryAxis = coordSys.getAxesByScale('ordinal')[0]; if (categoryAxis) { var axisDim = categoryAxis.dim; var axisType = axisDim + 'Axis'; var axisModel = ecModel.queryComponents({ mainType: axisType, index: seriesModel.get(name + 'Index'), id: seriesModel.get(name + 'Id') })[0]; var axisIndex = axisModel.componentIndex; newOption[axisType] = newOption[axisType] || []; for (var i = 0; i = 0) { zrUtil.each(radio, function (item) { model.setIconStatus(item, 'normal'); }); } }); model.setIconStatus(type, 'emphasis'); ecModel.eachComponent( { mainType: 'series', query: seriesIndex == null ? null : { seriesIndex: seriesIndex } }, generateNewSeriesTypes ); api.dispatchAction({ type: 'changeMagicType', currentType: type, newOption: newOption }); }; var echarts = __webpack_require__(1); echarts.registerAction({ type: 'changeMagicType', event: 'magicTypeChanged', update: 'prepareAndUpdate' }, function (payload, ecModel) { ecModel.mergeOption(payload.newOption); }); __webpack_require__(364).register('magicType', MagicType); module.exports = MagicType; /***/ }), /* 425 */ /***/ (function(module, exports, __webpack_require__) { /** * @module echarts/component/toolbox/feature/DataView */ var zrUtil = __webpack_require__(4); var eventTool = __webpack_require__(93); var lang = __webpack_require__(365).toolbox.dataView; var BLOCK_SPLITER = new Array(60).join('-'); var ITEM_SPLITER = '\\t'; /** * Group series into two types * 1. on category axis, like line, bar * 2. others, like scatter, pie * @param {module:echarts/model/Global} ecModel * @return {Object} * @inner */ function groupSeries(ecModel) { var seriesGroupByCategoryAxis = {}; var otherSeries = []; var meta = []; ecModel.eachRawSeries(function (seriesModel) { var coordSys = seriesModel.coordinateSystem; if (coordSys && (coordSys.type === 'cartesian2d' || coordSys.type === 'polar')) { var baseAxis = coordSys.getBaseAxis(); if (baseAxis.type === 'category') { var key = baseAxis.dim + '_' + baseAxis.index; if (!seriesGroupByCategoryAxis[key]) { seriesGroupByCategoryAxis[key] = { categoryAxis: baseAxis, valueAxis: coordSys.getOtherAxis(baseAxis), series: [] }; meta.push({ axisDim: baseAxis.dim, axisIndex: baseAxis.index }); } seriesGroupByCategoryAxis[key].series.push(seriesModel); } else { otherSeries.push(seriesModel); } } else { otherSeries.push(seriesModel); } }); return { seriesGroupByCategoryAxis: seriesGroupByCategoryAxis, other: otherSeries, meta: meta }; } /** * Assemble content of series on cateogory axis * @param {Array.} series * @return {string} * @inner */ function assembleSeriesWithCategoryAxis(series) { var tables = []; zrUtil.each(series, function (group, key) { var categoryAxis = group.categoryAxis; var valueAxis = group.valueAxis; var valueAxisDim = valueAxis.dim; var headers = [' '].concat(zrUtil.map(group.series, function (series) { return series.name; })); var columns = [categoryAxis.model.getCategories()]; zrUtil.each(group.series, function (series) { columns.push(series.getRawData().mapArray(valueAxisDim, function (val) { return val; })); }); // Assemble table content var lines = [headers.join(ITEM_SPLITER)]; for (var i = 0; i < columns[0].length; i++) { var items = []; for (var j = 0; j < columns.length; j++) { items.push(columns[j][i]); } lines.push(items.join(ITEM_SPLITER)); } tables.push(lines.join('\\n')); }); return tables.join('\\n\\n' + BLOCK_SPLITER + '\\n\\n'); } /** * Assemble content of other series * @param {Array.} series * @return {string} * @inner */ function assembleOtherSeries(series) { return zrUtil.map(series, function (series) { var data = series.getRawData(); var lines = [series.name]; var vals = []; data.each(data.dimensions, function () { var argLen = arguments.length; var dataIndex = arguments[argLen - 1]; var name = data.getName(dataIndex); for (var i = 0; i < argLen - 1; i++) { vals[i] = arguments[i]; } lines.push((name ? (name + ITEM_SPLITER) : '') + vals.join(ITEM_SPLITER)); }); return lines.join('\\n'); }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n'); } /** * @param {module:echarts/model/Global} * @return {Object} * @inner */ function getContentFromModel(ecModel) { var result = groupSeries(ecModel); return { value: zrUtil.filter([ assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis), assembleOtherSeries(result.other) ], function (str) { return str.replace(/[\\n\\t\\s]/g, ''); }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n'), meta: result.meta }; } function trim(str) { return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, ''); } /** * If a block is tsv format */ function isTSVFormat(block) { // Simple method to find out if a block is tsv format var firstLine = block.slice(0, block.indexOf('\\n')); if (firstLine.indexOf(ITEM_SPLITER) >= 0) { return true; } } var itemSplitRegex = new RegExp('[' + ITEM_SPLITER + ']+', 'g'); /** * @param {string} tsv * @return {Object} */ function parseTSVContents(tsv) { var tsvLines = tsv.split(/\\n+/g); var headers = trim(tsvLines.shift()).split(itemSplitRegex); var categories = []; var series = zrUtil.map(headers, function (header) { return { name: header, data: [] }; }); for (var i = 0; i < tsvLines.length; i++) { var items = trim(tsvLines[i]).split(itemSplitRegex); categories.push(items.shift()); for (var j = 0; j < items.length; j++) { series[j] && (series[j].data[i] = items[j]); } } return { series: series, categories: categories }; } /** * @param {string} str * @return {Array.} * @inner */ function parseListContents(str) { var lines = str.split(/\\n+/g); var seriesName = trim(lines.shift()); var data = []; for (var i = 0; i < lines.length; i++) { var items = trim(lines[i]).split(itemSplitRegex); var name = ''; var value; var hasName = false; if (isNaN(items[0])) { // First item is name hasName = true; name = items[0]; items = items.slice(1); data[i] = { name: name, value: [] }; value = data[i].value; } else { value = data[i] = []; } for (var j = 0; j < items.length; j++) { value.push(+items[j]); } if (value.length === 1) { hasName ? (data[i].value = value[0]) : (data[i] = value[0]); } } return { name: seriesName, data: data }; } /** * @param {string} str * @param {Array.} blockMetaList * @return {Object} * @inner */ function parseContents(str, blockMetaList) { var blocks = str.split(new RegExp('\\n*' + BLOCK_SPLITER + '\\n*', 'g')); var newOption = { series: [] }; zrUtil.each(blocks, function (block, idx) { if (isTSVFormat(block)) { var result = parseTSVContents(block); var blockMeta = blockMetaList[idx]; var axisKey = blockMeta.axisDim + 'Axis'; if (blockMeta) { newOption[axisKey] = newOption[axisKey] || []; newOption[axisKey][blockMeta.axisIndex] = { data: result.categories }; newOption.series = newOption.series.concat(result.series); } } else { var result = parseListContents(block); newOption.series.push(result); } }); return newOption; } /** * @alias {module:echarts/component/toolbox/feature/DataView} * @constructor * @param {module:echarts/model/Model} model */ function DataView(model) { this._dom = null; this.model = model; } DataView.defaultOption = { show: true, readOnly: false, optionToContent: null, contentToOption: null, icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28', title: zrUtil.clone(lang.title), lang: zrUtil.clone(lang.lang), backgroundColor: '#fff', textColor: '#000', textareaColor: '#fff', textareaBorderColor: '#333', buttonColor: '#c23531', buttonTextColor: '#fff' }; DataView.prototype.onclick = function (ecModel, api) { var container = api.getDom(); var model = this.model; if (this._dom) { container.removeChild(this._dom); } var root = document.createElement('div'); root.style.cssText = 'position:absolute;left:5px;top:5px;bottom:5px;right:5px;'; root.style.backgroundColor = model.get('backgroundColor') || '#fff'; // Create elements var header = document.createElement('h4'); var lang = model.get('lang') || []; header.innerHTML = lang[0] || model.get('title'); header.style.cssText = 'margin: 10px 20px;'; header.style.color = model.get('textColor'); var viewMain = document.createElement('div'); var textarea = document.createElement('textarea'); viewMain.style.cssText = 'display:block;width:100%;overflow:auto;'; var optionToContent = model.get('optionToContent'); var contentToOption = model.get('contentToOption'); var result = getContentFromModel(ecModel); if (typeof optionToContent === 'function') { var htmlOrDom = optionToContent(api.getOption()); if (typeof htmlOrDom === 'string') { viewMain.innerHTML = htmlOrDom; } else if (zrUtil.isDom(htmlOrDom)) { viewMain.appendChild(htmlOrDom); } } else { // Use default textarea viewMain.appendChild(textarea); textarea.readOnly = model.get('readOnly'); textarea.style.cssText = 'width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;'; textarea.style.color = model.get('textColor'); textarea.style.borderColor = model.get('textareaBorderColor'); textarea.style.backgroundColor = model.get('textareaColor'); textarea.value = result.value; } var blockMetaList = result.meta; var buttonContainer = document.createElement('div'); buttonContainer.style.cssText = 'position:absolute;bottom:0;left:0;right:0;'; var buttonStyle = 'float:right;margin-right:20px;border:none;' + 'cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px'; var closeButton = document.createElement('div'); var refreshButton = document.createElement('div'); buttonStyle += ';background-color:' + model.get('buttonColor'); buttonStyle += ';color:' + model.get('buttonTextColor'); var self = this; function close() { container.removeChild(root); self._dom = null; } eventTool.addEventListener(closeButton, 'click', close); eventTool.addEventListener(refreshButton, 'click', function () { var newOption; try { if (typeof contentToOption === 'function') { newOption = contentToOption(viewMain, api.getOption()); } else { newOption = parseContents(textarea.value, blockMetaList); } } catch (e) { close(); throw new Error('Data view format error ' + e); } if (newOption) { api.dispatchAction({ type: 'changeDataView', newOption: newOption }); } close(); }); closeButton.innerHTML = lang[1]; refreshButton.innerHTML = lang[2]; refreshButton.style.cssText = buttonStyle; closeButton.style.cssText = buttonStyle; !model.get('readOnly') && buttonContainer.appendChild(refreshButton); buttonContainer.appendChild(closeButton); // http://stackoverflow.com/questions/6637341/use-tab-to-indent-in-textarea eventTool.addEventListener(textarea, 'keydown', function (e) { if ((e.keyCode || e.which) === 9) { // get caret position/selection var val = this.value; var start = this.selectionStart; var end = this.selectionEnd; // set textarea value to: text before caret + tab + text after caret this.value = val.substring(0, start) + ITEM_SPLITER + val.substring(end); // put caret at right position again this.selectionStart = this.selectionEnd = start + 1; // prevent the focus lose eventTool.stop(e); } }); root.appendChild(header); root.appendChild(viewMain); root.appendChild(buttonContainer); viewMain.style.height = (container.clientHeight - 80) + 'px'; container.appendChild(root); this._dom = root; }; DataView.prototype.remove = function (ecModel, api) { this._dom && api.getDom().removeChild(this._dom); }; DataView.prototype.dispose = function (ecModel, api) { this.remove(ecModel, api); }; /** * @inner */ function tryMergeDataOption(newData, originalData) { return zrUtil.map(newData, function (newVal, idx) { var original = originalData && originalData[idx]; if (zrUtil.isObject(original) && !zrUtil.isArray(original)) { if (zrUtil.isObject(newVal) && !zrUtil.isArray(newVal)) { newVal = newVal.value; } // Original data has option return zrUtil.defaults({ value: newVal }, original); } else { return newVal; } }); } __webpack_require__(364).register('dataView', DataView); __webpack_require__(1).registerAction({ type: 'changeDataView', event: 'dataViewChanged', update: 'prepareAndUpdate' }, function (payload, ecModel) { var newSeriesOptList = []; zrUtil.each(payload.newOption.series, function (seriesOpt) { var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0]; if (!seriesModel) { // New created series // Geuss the series type newSeriesOptList.push(zrUtil.extend({ // Default is scatter type: 'scatter' }, seriesOpt)); } else { var originalData = seriesModel.get('data'); newSeriesOptList.push({ name: seriesOpt.name, data: tryMergeDataOption(seriesOpt.data, originalData) }); } }); ecModel.mergeOption(zrUtil.defaults({ series: newSeriesOptList }, payload.newOption)); }); module.exports = DataView; /***/ }), /* 426 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var zrUtil = __webpack_require__(4); var BrushController = __webpack_require__(248); var BrushTargetManager = __webpack_require__(359); var history = __webpack_require__(427); var sliderMove = __webpack_require__(242); var lang = __webpack_require__(365).toolbox.dataZoom; var each = zrUtil.each; // Use dataZoomSelect __webpack_require__(428); // Spectial component id start with \\0ec\\0, see echarts/model/Global.js~hasInnerId var DATA_ZOOM_ID_BASE = '\\0_ec_\\0toolbox-dataZoom_'; function DataZoom(model, ecModel, api) { /** * @private * @type {module:echarts/component/helper/BrushController} */ (this._brushController = new BrushController(api.getZr())) .on('brush', zrUtil.bind(this._onBrush, this)) .mount(); /** * @private * @type {boolean} */ this._isZoomActive; } DataZoom.defaultOption = { show: true, // Icon group icon: { zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1', back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26' }, // `zoom`, `back` title: zrUtil.clone(lang.title) }; var proto = DataZoom.prototype; proto.render = function (featureModel, ecModel, api, payload) { this.model = featureModel; this.ecModel = ecModel; this.api = api; updateZoomBtnStatus(featureModel, ecModel, this, payload, api); updateBackBtnStatus(featureModel, ecModel); }; proto.onclick = function (ecModel, api, type) { handlers[type].call(this); }; proto.remove = function (ecModel, api) { this._brushController.unmount(); }; proto.dispose = function (ecModel, api) { this._brushController.dispose(); }; /** * @private */ var handlers = { zoom: function () { var nextActive = !this._isZoomActive; this.api.dispatchAction({ type: 'takeGlobalCursor', key: 'dataZoomSelect', dataZoomSelectActive: nextActive }); }, back: function () { this._dispatchZoomAction(history.pop(this.ecModel)); } }; /** * @private */ proto._onBrush = function (areas, opt) { if (!opt.isEnd || !areas.length) { return; } var snapshot = {}; var ecModel = this.ecModel; this._brushController.updateCovers([]); // remove cover var brushTargetManager = new BrushTargetManager( retrieveAxisSetting(this.model.option), ecModel, {include: ['grid']} ); brushTargetManager.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) { if (coordSys.type !== 'cartesian2d') { return; } var brushType = area.brushType; if (brushType === 'rect') { setBatch('x', coordSys, coordRange[0]); setBatch('y', coordSys, coordRange[1]); } else { setBatch(({lineX: 'x', lineY: 'y'})[brushType], coordSys, coordRange); } }); history.push(ecModel, snapshot); this._dispatchZoomAction(snapshot); function setBatch(dimName, coordSys, minMax) { var axis = coordSys.getAxis(dimName); var axisModel = axis.model; var dataZoomModel = findDataZoom(dimName, axisModel, ecModel); // Restrict range. var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan(); if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) { minMax = sliderMove( 0, minMax.slice(), axis.scale.getExtent(), 0, minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan ); } dataZoomModel && (snapshot[dataZoomModel.id] = { dataZoomId: dataZoomModel.id, startValue: minMax[0], endValue: minMax[1] }); } function findDataZoom(dimName, axisModel, ecModel) { var found; ecModel.eachComponent({mainType: 'dataZoom', subType: 'select'}, function (dzModel) { var has = dzModel.getAxisModel(dimName, axisModel.componentIndex); has && (found = dzModel); }); return found; } }; /** * @private */ proto._dispatchZoomAction = function (snapshot) { var batch = []; // Convert from hash map to array. each(snapshot, function (batchItem, dataZoomId) { batch.push(zrUtil.clone(batchItem)); }); batch.length && this.api.dispatchAction({ type: 'dataZoom', from: this.uid, batch: batch }); }; function retrieveAxisSetting(option) { var setting = {}; // Compatible with previous setting: null => all axis, false => no axis. zrUtil.each(['xAxisIndex', 'yAxisIndex'], function (name) { setting[name] = option[name]; setting[name] == null && (setting[name] = 'all'); (setting[name] === false || setting[name] === 'none') && (setting[name] = []); }); return setting; } function updateBackBtnStatus(featureModel, ecModel) { featureModel.setIconStatus( 'back', history.count(ecModel) > 1 ? 'emphasis' : 'normal' ); } function updateZoomBtnStatus(featureModel, ecModel, view, payload, api) { var zoomActive = view._isZoomActive; if (payload && payload.type === 'takeGlobalCursor') { zoomActive = payload.key === 'dataZoomSelect' ? payload.dataZoomSelectActive : false; } view._isZoomActive = zoomActive; featureModel.setIconStatus('zoom', zoomActive ? 'emphasis' : 'normal'); var brushTargetManager = new BrushTargetManager( retrieveAxisSetting(featureModel.option), ecModel, {include: ['grid']} ); view._brushController .setPanels(brushTargetManager.makePanelOpts(api, function (targetInfo) { return (targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared) ? 'lineX' : (!targetInfo.xAxisDeclared && targetInfo.yAxisDeclared) ? 'lineY' : 'rect'; })) .enableBrush( zoomActive ? { brushType: 'auto', brushStyle: { // FIXME user customized? lineWidth: 0, fill: 'rgba(0,0,0,0.2)' } } : false ); } __webpack_require__(364).register('dataZoom', DataZoom); // Create special dataZoom option for select __webpack_require__(1).registerPreprocessor(function (option) { if (!option) { return; } var dataZoomOpts = option.dataZoom || (option.dataZoom = []); if (!zrUtil.isArray(dataZoomOpts)) { option.dataZoom = dataZoomOpts = [dataZoomOpts]; } var toolboxOpt = option.toolbox; if (toolboxOpt) { // Assume there is only one toolbox if (zrUtil.isArray(toolboxOpt)) { toolboxOpt = toolboxOpt[0]; } if (toolboxOpt && toolboxOpt.feature) { var dataZoomOpt = toolboxOpt.feature.dataZoom; addForAxis('xAxis', dataZoomOpt); addForAxis('yAxis', dataZoomOpt); } } function addForAxis(axisName, dataZoomOpt) { if (!dataZoomOpt) { return; } // Try not to modify model, because it is not merged yet. var axisIndicesName = axisName + 'Index'; var givenAxisIndices = dataZoomOpt[axisIndicesName]; if (givenAxisIndices != null && givenAxisIndices != 'all' && !zrUtil.isArray(givenAxisIndices) ) { givenAxisIndices = (givenAxisIndices === false || givenAxisIndices === 'none') ? [] : [givenAxisIndices]; } forEachComponent(axisName, function (axisOpt, axisIndex) { if (givenAxisIndices != null && givenAxisIndices != 'all' && zrUtil.indexOf(givenAxisIndices, axisIndex) === -1 ) { return; } var newOpt = { type: 'select', $fromToolbox: true, // Id for merge mapping. id: DATA_ZOOM_ID_BASE + axisName + axisIndex }; // FIXME // Only support one axis now. newOpt[axisIndicesName] = axisIndex; dataZoomOpts.push(newOpt); }); } function forEachComponent(mainType, cb) { var opts = option[mainType]; if (!zrUtil.isArray(opts)) { opts = opts ? [opts] : []; } each(opts, cb); } }); module.exports = DataZoom; /***/ }), /* 427 */ /***/ (function(module, exports, __webpack_require__) { /** * @file History manager. */ var zrUtil = __webpack_require__(4); var each = zrUtil.each; var ATTR = '\\0_ec_hist_store'; var history = { /** * @public * @param {module:echarts/model/Global} ecModel * @param {Object} newSnapshot {dataZoomId, batch: [payloadInfo, ...]} */ push: function (ecModel, newSnapshot) { var store = giveStore(ecModel); // If previous dataZoom can not be found, // complete an range with current range. each(newSnapshot, function (batchItem, dataZoomId) { var i = store.length - 1; for (; i >= 0; i--) { var snapshot = store[i]; if (snapshot[dataZoomId]) { break; } } if (i < 0) { // No origin range set, create one by current range. var dataZoomModel = ecModel.queryComponents( {mainType: 'dataZoom', subType: 'select', id: dataZoomId} )[0]; if (dataZoomModel) { var percentRange = dataZoomModel.getPercentRange(); store[0][dataZoomId] = { dataZoomId: dataZoomId, start: percentRange[0], end: percentRange[1] }; } } }); store.push(newSnapshot); }, /** * @public * @param {module:echarts/model/Global} ecModel * @return {Object} snapshot */ pop: function (ecModel) { var store = giveStore(ecModel); var head = store[store.length - 1]; store.length > 1 && store.pop(); // Find top for all dataZoom. var snapshot = {}; each(head, function (batchItem, dataZoomId) { for (var i = store.length - 1; i >= 0; i--) { var batchItem = store[i][dataZoomId]; if (batchItem) { snapshot[dataZoomId] = batchItem; break; } } }); return snapshot; }, /** * @public */ clear: function (ecModel) { ecModel[ATTR] = null; }, /** * @public * @param {module:echarts/model/Global} ecModel * @return {number} records. always >= 1. */ count: function (ecModel) { return giveStore(ecModel).length; } }; /** * [{key: dataZoomId, value: {dataZoomId, range}}, ...] * History length of each dataZoom may be different. * this._history[0] is used to store origin range. * @type {Array.} */ function giveStore(ecModel) { var store = ecModel[ATTR]; if (!store) { store = ecModel[ATTR] = [{}]; } return store; } module.exports = history; /***/ }), /* 428 */ /***/ (function(module, exports, __webpack_require__) { /** * DataZoom component entry */ __webpack_require__(372); __webpack_require__(373); __webpack_require__(376); __webpack_require__(429); __webpack_require__(430); __webpack_require__(382); __webpack_require__(383); /***/ }), /* 429 */ /***/ (function(module, exports, __webpack_require__) { /** * @file Data zoom model */ var DataZoomModel = __webpack_require__(373); module.exports = DataZoomModel.extend({ type: 'dataZoom.select' }); /***/ }), /* 430 */ /***/ (function(module, exports, __webpack_require__) { module.exports = __webpack_require__(376).extend({ type: 'dataZoom.select' }); /***/ }), /* 431 */ /***/ (function(module, exports, __webpack_require__) { 'use strict'; var history = __webpack_require__(427); var lang = __webpack_require__(365).toolbox.restore; function Restore(model) { this.model = model; } Restore.defaultOption = { show: true, icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5', title: lang.title }; var proto = Restore.prototype; proto.onclick = function (ecModel, api, type) { history.clear(ecModel); api.dispatchAction({ type: 'restore', from: this.uid }); }; __webpack_require__(364).register('restore', Restore); __webpack_require__(1).registerAction( {type: 'restore', event: 'restore', update: 'prepareAndUpdate'}, function (payload, ecModel) { ecModel.resetOption('recreate'); } ); module.exports = Restore; /***/ }), /* 432 */ /***/ (function(module, exports, __webpack_require__) { __webpack_require__(433); __webpack_require__(87).registerPainter('vml', __webpack_require__(435)); /***/ }), /* 433 */ /***/ (function(module, exports, __webpack_require__) { // http://www.w3.org/TR/NOTE-VML // TODO Use proxy like svg instead of overwrite brush methods if (!__webpack_require__(2).canvasSupported) { var vec2 = __webpack_require__(10); var BoundingRect = __webpack_require__(9); var CMD = __webpack_require__(39).CMD; var colorTool = __webpack_require__(33); var textContain = __webpack_require__(8); var textHelper = __webpack_require__(37); var RectText = __webpack_require__(36); var Displayable = __webpack_require__(23); var ZImage = __webpack_require__(52); var Text = __webpack_require__(53); var Path = __webpack_require__(22); var PathProxy = __webpack_require__(39); var Gradient = __webpack_require__(69); var vmlCore = __webpack_require__(434); var round = Math.round; var sqrt = Math.sqrt; var abs = Math.abs; var cos = Math.cos; var sin = Math.sin; var mathMax = Math.max; var applyTransform = vec2.applyTransform; var comma = ','; var imageTransformPrefix = 'progid:DXImageTransform.Microsoft'; var Z = 21600; var Z2 = Z / 2; var ZLEVEL_BASE = 100000; var Z_BASE = 1000; var initRootElStyle = function (el) { el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;'; el.coordsize = Z + ',' + Z; el.coordorigin = '0,0'; }; var encodeHtmlAttribute = function (s) { return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;'); }; var rgb2Str = function (r, g, b) { return 'rgb(' + [r, g, b].join(',') + ')'; }; var append = function (parent, child) { if (child && parent && child.parentNode !== parent) { parent.appendChild(child); } }; var remove = function (parent, child) { if (child && parent && child.parentNode === parent) { parent.removeChild(child); } }; var getZIndex = function (zlevel, z, z2) { // z 的取值范围为 [0, 1000] return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2; }; var parsePercent = function (value, maxValue) { if (typeof value === 'string') { if (value.lastIndexOf('%') >= 0) { return parseFloat(value) / 100 * maxValue; } return parseFloat(value); } return value; }; /*************************************************** * PATH **************************************************/ var setColorAndOpacity = function (el, color, opacity) { var colorArr = colorTool.parse(color); opacity = +opacity; if (isNaN(opacity)) { opacity = 1; } if (colorArr) { el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]); el.opacity = opacity * colorArr[3]; } }; var getColorAndAlpha = function (color) { var colorArr = colorTool.parse(color); return [ rgb2Str(colorArr[0], colorArr[1], colorArr[2]), colorArr[3] ]; }; var updateFillNode = function (el, style, zrEl) { // TODO pattern var fill = style.fill; if (fill != null) { // Modified from excanvas if (fill instanceof Gradient) { var gradientType; var angle = 0; var focus = [0, 0]; // additional offset var shift = 0; // scale factor for offset var expansion = 1; var rect = zrEl.getBoundingRect(); var rectWidth = rect.width; var rectHeight = rect.height; if (fill.type === 'linear') { gradientType = 'gradient'; var transform = zrEl.transform; var p0 = [fill.x * rectWidth, fill.y * rectHeight]; var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight]; if (transform) { applyTransform(p0, p0, transform); applyTransform(p1, p1, transform); } var dx = p1[0] - p0[0]; var dy = p1[1] - p0[1]; angle = Math.atan2(dx, dy) * 180 / Math.PI; // The angle should be a non-negative number. if (angle < 0) { angle += 360; } // Very small angles produce an unexpected result because they are // converted to a scientific notation string. if (angle < 1e-6) { angle = 0; } } else { gradientType = 'gradientradial'; var p0 = [fill.x * rectWidth, fill.y * rectHeight]; var transform = zrEl.transform; var scale = zrEl.scale; var width = rectWidth; var height = rectHeight; focus = [ // Percent in bounding rect (p0[0] - rect.x) / width, (p0[1] - rect.y) / height ]; if (transform) { applyTransform(p0, p0, transform); } width /= scale[0] * Z; height /= scale[1] * Z; var dimension = mathMax(width, height); shift = 2 * 0 / dimension; expansion = 2 * fill.r / dimension - shift; } // We need to sort the color stops in ascending order by offset, // otherwise IE won't interpret it correctly. var stops = fill.colorStops.slice(); stops.sort(function(cs1, cs2) { return cs1.offset - cs2.offset; }); var length = stops.length; // Color and alpha list of first and last stop var colorAndAlphaList = []; var colors = []; for (var i = 0; i < length; i++) { var stop = stops[i]; var colorAndAlpha = getColorAndAlpha(stop.color); colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]); if (i === 0 || i === length - 1) { colorAndAlphaList.push(colorAndAlpha); } } if (length >= 2) { var color1 = colorAndAlphaList[0][0]; var color2 = colorAndAlphaList[1][0]; var opacity1 = colorAndAlphaList[0][1] * style.opacity; var opacity2 = colorAndAlphaList[1][1] * style.opacity; el.type = gradientType; el.method = 'none'; el.focus = '100%'; el.angle = angle; el.color = color1; el.color2 = color2; el.colors = colors.join(','); // When colors attribute is used, the meanings of opacity and o:opacity2 // are reversed. el.opacity = opacity2; // FIXME g_o_:opacity ? el.opacity2 = opacity1; } if (gradientType === 'radial') { el.focusposition = focus.join(','); } } else { // FIXME Change from Gradient fill to color fill setColorAndOpacity(el, fill, style.opacity); } } }; var updateStrokeNode = function (el, style) { // if (style.lineJoin != null) { // el.joinstyle = style.lineJoin; // } // if (style.miterLimit != null) { // el.miterlimit = style.miterLimit * Z; // } // if (style.lineCap != null) { // el.endcap = style.lineCap; // } if (style.lineDash != null) { el.dashstyle = style.lineDash.join(' '); } if (style.stroke != null && !(style.stroke instanceof Gradient)) { setColorAndOpacity(el, style.stroke, style.opacity); } }; var updateFillAndStroke = function (vmlEl, type, style, zrEl) { var isFill = type == 'fill'; var el = vmlEl.getElementsByTagName(type)[0]; // Stroke must have lineWidth if (style[type] != null && style[type] !== 'none' && (isFill || (!isFill && style.lineWidth))) { vmlEl[isFill ? 'filled' : 'stroked'] = 'true'; // FIXME Remove before updating, or set `colors` will throw error if (style[type] instanceof Gradient) { remove(vmlEl, el); } if (!el) { el = vmlCore.createNode(type); } isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style); append(vmlEl, el); } else { vmlEl[isFill ? 'filled' : 'stroked'] = 'false'; remove(vmlEl, el); } }; var points = [[], [], []]; var pathDataToString = function (data, m) { var M = CMD.M; var C = CMD.C; var L = CMD.L; var A = CMD.A; var Q = CMD.Q; var str = []; var nPoint; var cmdStr; var cmd; var i; var xi; var yi; for (i = 0; i < data.length;) { cmd = data[i++]; cmdStr = ''; nPoint = 0; switch (cmd) { case M: cmdStr = ' m '; nPoint = 1; xi = data[i++]; yi = data[i++]; points[0][0] = xi; points[0][1] = yi; break; case L: cmdStr = ' l '; nPoint = 1; xi = data[i++]; yi = data[i++]; points[0][0] = xi; points[0][1] = yi; break; case Q: case C: cmdStr = ' c '; nPoint = 3; var x1 = data[i++]; var y1 = data[i++]; var x2 = data[i++]; var y2 = data[i++]; var x3; var y3; if (cmd === Q) { // Convert quadratic to cubic using degree elevation x3 = x2; y3 = y2; x2 = (x2 + 2 * x1) / 3; y2 = (y2 + 2 * y1) / 3; x1 = (xi + 2 * x1) / 3; y1 = (yi + 2 * y1) / 3; } else { x3 = data[i++]; y3 = data[i++]; } points[0][0] = x1; points[0][1] = y1; points[1][0] = x2; points[1][1] = y2; points[2][0] = x3; points[2][1] = y3; xi = x3; yi = y3; break; case A: var x = 0; var y = 0; var sx = 1; var sy = 1; var angle = 0; if (m) { // Extract SRT from matrix x = m[4]; y = m[5]; sx = sqrt(m[0] * m[0] + m[1] * m[1]); sy = sqrt(m[2] * m[2] + m[3] * m[3]); angle = Math.atan2(-m[1] / sy, m[0] / sx); } var cx = data[i++]; var cy = data[i++]; var rx = data[i++]; var ry = data[i++]; var startAngle = data[i++] + angle; var endAngle = data[i++] + startAngle + angle; // FIXME // var psi = data[i++]; i++; var clockwise = data[i++]; var x0 = cx + cos(startAngle) * rx; var y0 = cy + sin(startAngle) * ry; var x1 = cx + cos(endAngle) * rx; var y1 = cy + sin(endAngle) * ry; var type = clockwise ? ' wa ' : ' at '; if (Math.abs(x0 - x1) < 1e-4) { // IE won't render arches drawn counter clockwise if x0 == x1. if (Math.abs(endAngle - startAngle) > 1e-2) { // Offset x0 by 1/80 of a pixel. Use something // that can be represented in binary if (clockwise) { x0 += 270 / Z; } } else { // Avoid case draw full circle if (Math.abs(y0 - cy) < 1e-4) { if ((clockwise && x0 < cx) || (!clockwise && x0 > cx)) { y1 -= 270 / Z; } else { y1 += 270 / Z; } } else if ((clockwise && y0 < cy) || (!clockwise && y0 > cy)) { x1 += 270 / Z; } else { x1 -= 270 / Z; } } } str.push( type, round(((cx - rx) * sx + x) * Z - Z2), comma, round(((cy - ry) * sy + y) * Z - Z2), comma, round(((cx + rx) * sx + x) * Z - Z2), comma, round(((cy + ry) * sy + y) * Z - Z2), comma, round((x0 * sx + x) * Z - Z2), comma, round((y0 * sy + y) * Z - Z2), comma, round((x1 * sx + x) * Z - Z2), comma, round((y1 * sy + y) * Z - Z2) ); xi = x1; yi = y1; break; case CMD.R: var p0 = points[0]; var p1 = points[1]; // x0, y0 p0[0] = data[i++]; p0[1] = data[i++]; // x1, y1 p1[0] = p0[0] + data[i++]; p1[1] = p0[1] + data[i++]; if (m) { applyTransform(p0, p0, m); applyTransform(p1, p1, m); } p0[0] = round(p0[0] * Z - Z2); p1[0] = round(p1[0] * Z - Z2); p0[1] = round(p0[1] * Z - Z2); p1[1] = round(p1[1] * Z - Z2); str.push( // x0, y0 ' m ', p0[0], comma, p0[1], // x1, y0 ' l ', p1[0], comma, p0[1], // x1, y1 ' l ', p1[0], comma, p1[1], // x0, y1 ' l ', p0[0], comma, p1[1] ); break; case CMD.Z: // FIXME Update xi, yi str.push(' x '); } if (nPoint > 0) { str.push(cmdStr); for (var k = 0; k < nPoint; k++) { var p = points[k]; m && applyTransform(p, p, m); // 不 round 会非常慢 str.push( round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2), k < nPoint - 1 ? comma : '' ); } } } return str.join(''); }; // Rewrite the original path method Path.prototype.brushVML = function (vmlRoot) { var style = this.style; var vmlEl = this._vmlEl; if (!vmlEl) { vmlEl = vmlCore.createNode('shape'); initRootElStyle(vmlEl); this._vmlEl = vmlEl; } updateFillAndStroke(vmlEl, 'fill', style, this); updateFillAndStroke(vmlEl, 'stroke', style, this); var m = this.transform; var needTransform = m != null; var strokeEl = vmlEl.getElementsByTagName('stroke')[0]; if (strokeEl) { var lineWidth = style.lineWidth; // Get the line scale. // Determinant of this.m_ means how much the area is enlarged by the // transformation. So its square root can be used as a scale factor // for width. if (needTransform && !style.strokeNoScale) { var det = m[0] * m[3] - m[1] * m[2]; lineWidth *= sqrt(abs(det)); } strokeEl.weight = lineWidth + 'px'; } var path = this.path || (this.path = new PathProxy()); if (this.__dirtyPath) { path.beginPath(); this.buildPath(path, this.shape); path.toStatic(); this.__dirtyPath = false; } vmlEl.path = pathDataToString(path.data, this.transform); vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root append(vmlRoot, vmlEl); // Text if (style.text != null) { this.drawRectText(vmlRoot, this.getBoundingRect()); } else { this.removeRectText(vmlRoot); } }; Path.prototype.onRemove = function (vmlRoot) { remove(vmlRoot, this._vmlEl); this.removeRectText(vmlRoot); }; Path.prototype.onAdd = function (vmlRoot) { append(vmlRoot, this._vmlEl); this.appendRectText(vmlRoot); }; /*************************************************** * IMAGE **************************************************/ var isImage = function (img) { // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错 return (typeof img === 'object') && img.tagName && img.tagName.toUpperCase() === 'IMG'; // return img instanceof Image; }; // Rewrite the original path method ZImage.prototype.brushVML = function (vmlRoot) { var style = this.style; var image = style.image; // Image original width, height var ow; var oh; if (isImage(image)) { var src = image.src; if (src === this._imageSrc) { ow = this._imageWidth; oh = this._imageHeight; } else { var imageRuntimeStyle = image.runtimeStyle; var oldRuntimeWidth = imageRuntimeStyle.width; var oldRuntimeHeight = imageRuntimeStyle.height; imageRuntimeStyle.width = 'auto'; imageRuntimeStyle.height = 'auto'; // get the original size ow = image.width; oh = image.height; // and remove overides imageRuntimeStyle.width = oldRuntimeWidth; imageRuntimeStyle.height = oldRuntimeHeight; // Caching image original width, height and src this._imageSrc = src; this._imageWidth = ow; this._imageHeight = oh; } image = src; } else { if (image === this._imageSrc) { ow = this._imageWidth; oh = this._imageHeight; } } if (!image) { return; } var x = style.x || 0; var y = style.y || 0; var dw = style.width; var dh = style.height; var sw = style.sWidth; var sh = style.sHeight; var sx = style.sx || 0; var sy = style.sy || 0; var hasCrop = sw && sh; var vmlEl = this._vmlEl; if (!vmlEl) { // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。 // vmlEl = vmlCore.createNode('group'); vmlEl = vmlCore.doc.createElement('div'); initRootElStyle(vmlEl); this._vmlEl = vmlEl; } var vmlElStyle = vmlEl.style; var hasRotation = false; var m; var scaleX = 1; var scaleY = 1; if (this.transform) { m = this.transform; scaleX = sqrt(m[0] * m[0] + m[1] * m[1]); scaleY = sqrt(m[2] * m[2] + m[3] * m[3]); hasRotation = m[1] || m[2]; } if (hasRotation) { // If filters are necessary (rotation exists), create them // filters are bog-slow, so only create them if abbsolutely necessary // The following check doesn't account for skews (which don't exist // in the canvas spec (yet) anyway. // From excanvas var p0 = [x, y]; var p1 = [x + dw, y]; var p2 = [x, y + dh]; var p3 = [x + dw, y + dh]; applyTransform(p0, p0, m); applyTransform(p1, p1, m); applyTransform(p2, p2, m); applyTransform(p3, p3, m); var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]); var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]); var transformFilter = []; transformFilter.push('M11=', m[0] / scaleX, comma, 'M12=', m[2] / scaleY, comma, 'M21=', m[1] / scaleX, comma, 'M22=', m[3] / scaleY, comma, 'Dx=', round(x * scaleX + m[4]), comma, 'Dy=', round(y * scaleY + m[5])); vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0'; // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用 vmlElStyle.filter = imageTransformPrefix + '.Matrix(' + transformFilter.join('') + ', SizingMethod=clip)'; } else { if (m) { x = x * scaleX + m[4]; y = y * scaleY + m[5]; } vmlElStyle.filter = ''; vmlElStyle.left = round(x) + 'px'; vmlElStyle.top = round(y) + 'px'; } var imageEl = this._imageEl; var cropEl = this._cropEl; if (!imageEl) { imageEl = vmlCore.doc.createElement('div'); this._imageEl = imageEl; } var imageELStyle = imageEl.style; if (hasCrop) { // Needs know image original width and height if (! (ow && oh)) { var tmpImage = new Image(); var self = this; tmpImage.onload = function () { tmpImage.onload = null; ow = tmpImage.width; oh = tmpImage.height; // Adjust image width and height to fit the ratio destinationSize / sourceSize imageELStyle.width = round(scaleX * ow * dw / sw) + 'px'; imageELStyle.height = round(scaleY * oh * dh / sh) + 'px'; // Caching image original width, height and src self._imageWidth = ow; self._imageHeight = oh; self._imageSrc = image; }; tmpImage.src = image; } else { imageELStyle.width = round(scaleX * ow * dw / sw) + 'px'; imageELStyle.height = round(scaleY * oh * dh / sh) + 'px'; } if (! cropEl) { cropEl = vmlCore.doc.createElement('div'); cropEl.style.overflow = 'hidden'; this._cropEl = cropEl; } var cropElStyle = cropEl.style; cropElStyle.width = round((dw + sx * dw / sw) * scaleX); cropElStyle.height = round((dh + sy * dh / sh) * scaleY); cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx=' + (-sx * dw / sw * scaleX) + ',Dy=' + (-sy * dh / sh * scaleY) + ')'; if (! cropEl.parentNode) { vmlEl.appendChild(cropEl); } if (imageEl.parentNode != cropEl) { cropEl.appendChild(imageEl); } } else { imageELStyle.width = round(scaleX * dw) + 'px'; imageELStyle.height = round(scaleY * dh) + 'px'; vmlEl.appendChild(imageEl); if (cropEl && cropEl.parentNode) { vmlEl.removeChild(cropEl); this._cropEl = null; } } var filterStr = ''; var alpha = style.opacity; if (alpha < 1) { filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') '; } filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)'; imageELStyle.filter = filterStr; vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root append(vmlRoot, vmlEl); // Text if (style.text != null) { this.drawRectText(vmlRoot, this.getBoundingRect()); } }; ZImage.prototype.onRemove = function (vmlRoot) { remove(vmlRoot, this._vmlEl); this._vmlEl = null; this._cropEl = null; this._imageEl = null; this.removeRectText(vmlRoot); }; ZImage.prototype.onAdd = function (vmlRoot) { append(vmlRoot, this._vmlEl); this.appendRectText(vmlRoot); }; /*************************************************** * TEXT **************************************************/ var DEFAULT_STYLE_NORMAL = 'normal'; var fontStyleCache = {}; var fontStyleCacheCount = 0; var MAX_FONT_CACHE_SIZE = 100; var fontEl = document.createElement('div'); var getFontStyle = function (fontString) { var fontStyle = fontStyleCache[fontString]; if (!fontStyle) { // Clear cache if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) { fontStyleCacheCount = 0; fontStyleCache = {}; } var style = fontEl.style; var fontFamily; try { style.font = fontString; fontFamily = style.fontFamily.split(',')[0]; } catch (e) { } fontStyle = { style: style.fontStyle || DEFAULT_STYLE_NORMAL, variant: style.fontVariant || DEFAULT_STYLE_NORMAL, weight: style.fontWeight || DEFAULT_STYLE_NORMAL, size: parseFloat(style.fontSize || 12) | 0, family: fontFamily || 'Microsoft YaHei' }; fontStyleCache[fontString] = fontStyle; fontStyleCacheCount++; } return fontStyle; }; var textMeasureEl; // Overwrite measure text method textContain.measureText = function (text, textFont) { var doc = vmlCore.doc; if (!textMeasureEl) { textMeasureEl = doc.createElement('div'); textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;' + 'padding:0;margin:0;border:none;white-space:pre;'; vmlCore.doc.body.appendChild(textMeasureEl); } try { textMeasureEl.style.font = textFont; } catch (ex) { // Ignore failures to set to invalid font. } textMeasureEl.innerHTML = ''; // Don't use innerHTML or innerText because they allow markup/whitespace. textMeasureEl.appendChild(doc.createTextNode(text)); return { width: textMeasureEl.offsetWidth }; }; var tmpRect = new BoundingRect(); var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) { var style = this.style; // Optimize, avoid normalize every time. this.__dirty && textHelper.normalizeTextStyle(style, true); var text = style.text; // Convert to string text != null && (text += ''); if (!text) { return; } // Convert rich text to plain text. Rich text is not supported in // IE8-, but tags in rich text template will be removed. if (style.rich) { var contentBlock = textContain.parseRichText(text, style); text = []; for (var i = 0; i < contentBlock.lines.length; i++) { var tokens = contentBlock.lines[i].tokens; var textLine = []; for (var j = 0; j < tokens.length; j++) { textLine.push(tokens[j].text); } text.push(textLine.join('')); } text = text.join('\\n'); } var x; var y; var align = style.textAlign; var verticalAlign = style.textVerticalAlign; var fontStyle = getFontStyle(style.font); // FIXME encodeHtmlAttribute ? var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' ' + fontStyle.size + 'px \"' + fontStyle.family + '\"'; textRect = textRect || textContain.getBoundingRect(text, font, align, verticalAlign); // Transform rect to view space var m = this.transform; // Ignore transform for text in other element if (m && !fromTextEl) { tmpRect.copy(rect); tmpRect.applyTransform(m); rect = tmpRect; } if (!fromTextEl) { var textPosition = style.textPosition; var distance = style.textDistance; // Text position represented by coord if (textPosition instanceof Array) { x = rect.x + parsePercent(textPosition[0], rect.width); y = rect.y + parsePercent(textPosition[1], rect.height); align = align || 'left'; } else { var res = textContain.adjustTextPositionOnRect( textPosition, rect, distance ); x = res.x; y = res.y; // Default align and baseline when has textPosition align = align || res.textAlign; verticalAlign = verticalAlign || res.textVerticalAlign; } } else { x = rect.x; y = rect.y; } x = textContain.adjustTextX(x, textRect.width, align); y = textContain.adjustTextY(y, textRect.height, verticalAlign); // Force baseline 'middle' y += textRect.height / 2; // var fontSize = fontStyle.size; // 1.75 is an arbitrary number, as there is no info about the text baseline // switch (baseline) { // case 'hanging': // case 'top': // y += fontSize / 1.75; // break; // case 'middle': // break; // default: // // case null: // // case 'alphabetic': // // case 'ideographic': // // case 'bottom': // y -= fontSize / 2.25; // break; // } // switch (align) { // case 'left': // break; // case 'center': // x -= textRect.width / 2; // break; // case 'right': // x -= textRect.width; // break; // case 'end': // align = elementStyle.direction == 'ltr' ? 'right' : 'left'; // break; // case 'start': // align = elementStyle.direction == 'rtl' ? 'right' : 'left'; // break; // default: // align = 'left'; // } var createNode = vmlCore.createNode; var textVmlEl = this._textVmlEl; var pathEl; var textPathEl; var skewEl; if (!textVmlEl) { textVmlEl = createNode('line'); pathEl = createNode('path'); textPathEl = createNode('textpath'); skewEl = createNode('skew'); // FIXME Why here is not cammel case // Align 'center' seems wrong textPathEl.style['v-text-align'] = 'left'; initRootElStyle(textVmlEl); pathEl.textpathok = true; textPathEl.on = true; textVmlEl.from = '0 0'; textVmlEl.to = '1000 0.05'; append(textVmlEl, skewEl); append(textVmlEl, pathEl); append(textVmlEl, textPathEl); this._textVmlEl = textVmlEl; } else { // 这里是在前面 appendChild 保证顺序的前提下 skewEl = textVmlEl.firstChild; pathEl = skewEl.nextSibling; textPathEl = pathEl.nextSibling; } var coords = [x, y]; var textVmlElStyle = textVmlEl.style; // Ignore transform for text in other element if (m && fromTextEl) { applyTransform(coords, coords, m); skewEl.on = true; skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma + m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0'; // Text position skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0); // Left top point as origin skewEl.origin = '0 0'; textVmlElStyle.left = '0px'; textVmlElStyle.top = '0px'; } else { skewEl.on = false; textVmlElStyle.left = round(x) + 'px'; textVmlElStyle.top = round(y) + 'px'; } textPathEl.string = encodeHtmlAttribute(text); // TODO try { textPathEl.style.font = font; } // Error font format catch (e) {} updateFillAndStroke(textVmlEl, 'fill', { fill: style.textFill, opacity: style.opacity }, this); updateFillAndStroke(textVmlEl, 'stroke', { stroke: style.textStroke, opacity: style.opacity, lineDash: style.lineDash }, this); textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Attached to root append(vmlRoot, textVmlEl); }; var removeRectText = function (vmlRoot) { remove(vmlRoot, this._textVmlEl); this._textVmlEl = null; }; var appendRectText = function (vmlRoot) { append(vmlRoot, this._textVmlEl); }; var list = [RectText, Displayable, ZImage, Path, Text]; // In case Displayable has been mixed in RectText for (var i = 0; i < list.length; i++) { var proto = list[i].prototype; proto.drawRectText = drawRectText; proto.removeRectText = removeRectText; proto.appendRectText = appendRectText; } Text.prototype.brushVML = function (vmlRoot) { var style = this.style; if (style.text != null) { this.drawRectText(vmlRoot, { x: style.x || 0, y: style.y || 0, width: 0, height: 0 }, this.getBoundingRect(), true); } else { this.removeRectText(vmlRoot); } }; Text.prototype.onRemove = function (vmlRoot) { this.removeRectText(vmlRoot); }; Text.prototype.onAdd = function (vmlRoot) { this.appendRectText(vmlRoot); }; } /***/ }), /* 434 */ /***/ (function(module, exports, __webpack_require__) { if (!__webpack_require__(2).canvasSupported) { var urn = 'urn:schemas-microsoft-com:vml'; var createNode; var win = window; var doc = win.document; var vmlInited = false; try { !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn); createNode = function (tagName) { return doc.createElement(''); }; } catch (e) { createNode = function (tagName) { return doc.createElement(''); }; } // From raphael var initVML = function () { if (vmlInited) { return; } vmlInited = true; var styleSheets = doc.styleSheets; if (styleSheets.length < 31) { doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)'); } else { // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)'); } }; // Not useing return to avoid error when converting to CommonJS module module.exports = { doc: doc, initVML: initVML, createNode: createNode }; } /***/ }), /* 435 */ /***/ (function(module, exports, __webpack_require__) { /** * VML Painter. * * @module zrender/vml/Painter */ var zrLog = __webpack_require__(34); var vmlCore = __webpack_require__(434); function parseInt10(val) { return parseInt(val, 10); } /** * @alias module:zrender/vml/Painter */ function VMLPainter(root, storage) { vmlCore.initVML(); this.root = root; this.storage = storage; var vmlViewport = document.createElement('div'); var vmlRoot = document.createElement('div'); vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;'; vmlRoot.style.cssText = 'position:absolute;left:0;top:0;'; root.appendChild(vmlViewport); this._vmlRoot = vmlRoot; this._vmlViewport = vmlViewport; this.resize(); // Modify storage var oldDelFromStorage = storage.delFromStorage; var oldAddToStorage = storage.addToStorage; storage.delFromStorage = function (el) { oldDelFromStorage.call(storage, el); if (el) { el.onRemove && el.onRemove(vmlRoot); } }; storage.addToStorage = function (el) { // Displayable already has a vml node el.onAdd && el.onAdd(vmlRoot); oldAddToStorage.call(storage, el); }; this._firstPaint = true; } VMLPainter.prototype = { constructor: VMLPainter, getType: function () { return 'vml'; }, /** * @return {HTMLDivElement} */ getViewportRoot: function () { return this._vmlViewport; }, getViewportRootOffset: function () { var viewportRoot = this.getViewportRoot(); if (viewportRoot) { return { offsetLeft: viewportRoot.offsetLeft || 0, offsetTop: viewportRoot.offsetTop || 0 }; } }, /** * 刷新 */ refresh: function () { var list = this.storage.getDisplayList(true, true); this._paintList(list); }, _paintList: function (list) { var vmlRoot = this._vmlRoot; for (var i = 0; i < list.length; i++) { var el = list[i]; if (el.invisible || el.ignore) { if (!el.__alreadyNotVisible) { el.onRemove(vmlRoot); } // Set as already invisible el.__alreadyNotVisible = true; } else { if (el.__alreadyNotVisible) { el.onAdd(vmlRoot); } el.__alreadyNotVisible = false; if (el.__dirty) { el.beforeBrush && el.beforeBrush(); (el.brushVML || el.brush).call(el, vmlRoot); el.afterBrush && el.afterBrush(); } } el.__dirty = false; } if (this._firstPaint) { // Detached from document at first time // to avoid page refreshing too many times // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变 this._vmlViewport.appendChild(vmlRoot); this._firstPaint = false; } }, resize: function (width, height) { var width = width == null ? this._getWidth() : width; var height = height == null ? this._getHeight() : height; if (this._width != width || this._height != height) { this._width = width; this._height = height; var vmlViewportStyle = this._vmlViewport.style; vmlViewportStyle.width = width + 'px'; vmlViewportStyle.height = height + 'px'; } }, dispose: function () { this.root.innerHTML = ''; this._vmlRoot = this._vmlViewport = this.storage = null; }, getWidth: function () { return this._width; }, getHeight: function () { return this._height; }, clear: function () { if (this._vmlViewport) { this.root.removeChild(this._vmlViewport); } }, _getWidth: function () { var root = this.root; var stl = root.currentStyle; return ((root.clientWidth || parseInt10(stl.width)) - parseInt10(stl.paddingLeft) - parseInt10(stl.paddingRight)) | 0; }, _getHeight: function () { var root = this.root; var stl = root.currentStyle; return ((root.clientHeight || parseInt10(stl.height)) - parseInt10(stl.paddingTop) - parseInt10(stl.paddingBottom)) | 0; } }; // Not supported methods function createMethodNotSupport(method) { return function () { zrLog('In IE8.0 VML mode painter not support method \"' + method + '\"'); }; } var notSupportedMethods = [ 'getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage' ]; for (var i = 0; i < notSupportedMethods.length; i++) { var name = notSupportedMethods[i]; VMLPainter.prototype[name] = createMethodNotSupport(name); } module.exports = VMLPainter; /***/ }) /******/ ]) }); ;"}],"posts":[{"title":"promise的初步使用","slug":"promise的初步使用","date":"2017-10-17T12:06:00.000Z","updated":"2017-10-22T03:31:40.141Z","comments":true,"path":"20171017/200600/","link":"","permalink":"https://www.onlystar.site/20171017/200600/","excerpt":"","text":"背景在前端开发中，经常会遇到这样的困境：一个接口的参数会需要使用另一个接口获取，这时候聪明的做法就是使用回调函数，这样就可以解决问题，但是这种做法增加了函数的嵌套深度，如果需要的是好几个接口的返回数据,这样层层的回调,就比较头疼痛了，这就是所谓的回调地狱。Promise正是在这种情况下应运而生,它完美优雅的解决了回调地狱难题。123456789step1(function (value1) &#123; step2(value1, function(value2)&#123; step3(value2,function(value3) &#123; step4(value3,function(value4) &#123; // ... &#125;); &#125;); &#125;);&#125;); Promise 是异步编程的一种解决方案，Promise 可以认为是一个对象，它可以获取异步操的最终完成（或失败）及其结果值的表示 Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（成功时）和rejected（失败时） Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected. 基本用法ES6 规定，Promise对象是一个构造函数，用来生成Promise实例,该函数的两个参数分别是两个函数resolve和reject1234567var promise = new Promise(function(resolve, reject) &#123; if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); then方法then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数,then方法返回的是一个新的Promise实例12345promise.then(function(value) &#123; // success&#125;, function(value) &#123; // failure&#125;); 如果异步操作成功，则用 resolve 方法将状态从“未完成”变为“成功”，如果异步操作失败，则用 reject方法将状态从“未完成”变为“失败” 这里是promised基本使用的一个demo,定义做饭，吃饭,洗碗三个方法1234567891011121314151617181920212223242526272829303132333435363738//做饭function cook()&#123; console.log(&apos;开始做饭。&apos;); var p = new Promise(function(resolve, reject)&#123; console.log(&apos;做饭完毕！&apos;); resolve(&apos;鸡蛋炒饭&apos;); &#125;); return p;&#125;//吃饭function eat(data)&#123; console.log(&apos;开始吃饭：&apos; + data); var p = new Promise(function(resolve, reject)&#123; console.log(&apos;吃饭完毕!&apos;); resolve(&apos;一块碗和一双筷子&apos;); &#125;); return p;&#125;//洗碗function wash(data)&#123; console.log(&apos;开始洗碗：&apos; + data); var p = new Promise(function(resolve, reject)&#123; console.log(&apos;洗碗完毕!&apos;); resolve(&apos;干净的碗筷&apos;); &#125;); return p;&#125;//调用三个过程cook().then(function(data)&#123; return eat(data);&#125;).then(function(data)&#123; return wash(data);&#125;).then(function(data)&#123; console.log(data);&#125;); 程序成功运行的结果:1234567开始做饭。做饭完毕！开始吃饭：鸡蛋炒饭吃饭完毕!开始洗碗：一块碗和一双筷子洗碗完毕!干净的碗筷 all方法有时候需要多个异步任务全部执行完成后再执行后面的操作，这时候就需要用到Promise.all()，它接收一个Promise的对象的数组作为参数，当这个数组里的所有Promise对象全部变成resolve或者reject的时候，它才会去调用后面的.then()。123456Promise.all([cook(), eat(),wash()]).then(function(results)&#123; console.log(results); console.log(&quot;做吃洗完毕：&quot;);&#125;); 成功的运行结果:12345678开始做饭。做饭完毕！开始吃饭：undefined吃饭完毕!开始洗碗：undefined洗碗完毕!做吃洗完毕：[&quot;鸡蛋炒饭&quot;, &quot;一块碗和一双筷子&quot;, &quot;干净的碗筷&quot;]","categories":[{"name":"ES6","slug":"ES6","permalink":"https://www.onlystar.site/categories/ES6/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.onlystar.site/tags/js/"},{"name":"promise","slug":"promise","permalink":"https://www.onlystar.site/tags/promise/"}]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2017-10-15T13:09:39.000Z","updated":"2017-10-21T14:11:56.956Z","comments":true,"path":"20171015/210939/","link":"","permalink":"https://www.onlystar.site/20171015/210939/","excerpt":"","text":"这是我个人博客搭建好的第一篇博客，欢迎大家来捧捧场哦","categories":[{"name":"web","slug":"web","permalink":"https://www.onlystar.site/categories/web/"}],"tags":[{"name":"测试","slug":"测试","permalink":"https://www.onlystar.site/tags/测试/"}]}]}